/*
IaaS-API

This API allows you to create and modify IaaS resources.

API version: 1alpha1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iaasalpha

import (
	"bytes"
	"encoding/json"
	"fmt"
)

// checks if the PublicNetwork type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &PublicNetwork{}

/*
	types and functions for cidr
*/

// isNotNullableString
type PublicNetworkGetCidrAttributeType = *string

func getPublicNetworkGetCidrAttributeTypeOk(arg PublicNetworkGetCidrAttributeType) (ret PublicNetworkGetCidrRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setPublicNetworkGetCidrAttributeType(arg *PublicNetworkGetCidrAttributeType, val PublicNetworkGetCidrRetType) {
	*arg = &val
}

type PublicNetworkGetCidrArgType = string
type PublicNetworkGetCidrRetType = string

// PublicNetwork Public network.
type PublicNetwork struct {
	// Classless Inter-Domain Routing (CIDR).
	// REQUIRED
	Cidr PublicNetworkGetCidrAttributeType `json:"cidr" validate:"regexp=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\/(3[0-2]|2[0-9]|1[0-9]|[0-9]))$|^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(\\/((1(1[0-9]|2[0-8]))|([0-9][0-9])|([0-9])))?$"`
}

type _PublicNetwork PublicNetwork

// NewPublicNetwork instantiates a new PublicNetwork object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewPublicNetwork(cidr PublicNetworkGetCidrArgType) *PublicNetwork {
	this := PublicNetwork{}
	setPublicNetworkGetCidrAttributeType(&this.Cidr, cidr)
	return &this
}

// NewPublicNetworkWithDefaults instantiates a new PublicNetwork object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewPublicNetworkWithDefaults() *PublicNetwork {
	this := PublicNetwork{}
	return &this
}

// GetCidr returns the Cidr field value
func (o *PublicNetwork) GetCidr() (ret PublicNetworkGetCidrRetType) {
	ret, _ = o.GetCidrOk()
	return ret
}

// GetCidrOk returns a tuple with the Cidr field value
// and a boolean to check if the value has been set.
func (o *PublicNetwork) GetCidrOk() (ret PublicNetworkGetCidrRetType, ok bool) {
	return getPublicNetworkGetCidrAttributeTypeOk(o.Cidr)
}

// SetCidr sets field value
func (o *PublicNetwork) SetCidr(v PublicNetworkGetCidrRetType) {
	setPublicNetworkGetCidrAttributeType(&o.Cidr, v)
}

func (o PublicNetwork) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o PublicNetwork) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if val, ok := getPublicNetworkGetCidrAttributeTypeOk(o.Cidr); ok {
		toSerialize["Cidr"] = val
	}
	return toSerialize, nil
}

func (o *PublicNetwork) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"cidr",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varPublicNetwork := _PublicNetwork{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varPublicNetwork)

	if err != nil {
		return err
	}

	*o = PublicNetwork(varPublicNetwork)

	return err
}

type NullablePublicNetwork struct {
	value *PublicNetwork
	isSet bool
}

func (v NullablePublicNetwork) Get() *PublicNetwork {
	return v.value
}

func (v *NullablePublicNetwork) Set(val *PublicNetwork) {
	v.value = val
	v.isSet = true
}

func (v NullablePublicNetwork) IsSet() bool {
	return v.isSet
}

func (v *NullablePublicNetwork) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePublicNetwork(val *PublicNetwork) *NullablePublicNetwork {
	return &NullablePublicNetwork{value: val, isSet: true}
}

func (v NullablePublicNetwork) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePublicNetwork) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
