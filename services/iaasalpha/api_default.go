/*
IaaS-API

This API allows you to create and modify IaaS resources.

API version: 2alpha1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iaasalpha

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		AddRoutesToRoutingTable Create new routes in a routing table.
		Create new routes in an existing routing table.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return ApiAddRoutesToRoutingTableRequest
	*/
	AddRoutesToRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiAddRoutesToRoutingTableRequest
	/*
		AddRoutesToRoutingTableExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return RouteListResponse

	*/
	AddRoutesToRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RouteListResponse, error)
	/*
		AddRoutingTableToArea Create new routing table in a network area.
		Create a new routing table in an existing network area.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@return ApiAddRoutingTableToAreaRequest
	*/
	AddRoutingTableToArea(ctx context.Context, organizationId string, areaId string, region string) ApiAddRoutingTableToAreaRequest
	/*
		AddRoutingTableToAreaExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@return RoutingTable

	*/
	AddRoutingTableToAreaExecute(ctx context.Context, organizationId string, areaId string, region string) (*RoutingTable, error)
	/*
		CreateNetwork Create new network.
		Create a new network in a project. `nameservers` will be filled from `defaultNameservers` of the respective area if not specified. If the project has `internetAccess` enabled and this is the first network in the project this might incur cost.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@return ApiCreateNetworkRequest
	*/
	CreateNetwork(ctx context.Context, projectId string, region string) ApiCreateNetworkRequest
	/*
		CreateNetworkExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@return Network

	*/
	CreateNetworkExecute(ctx context.Context, projectId string, region string) (*Network, error)
	/*
		DeleteNetwork Delete network.
		Delete a network. If the network is still in use, the deletion will fail.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@param networkId The identifier (ID) of a STACKIT Network.
		@return ApiDeleteNetworkRequest
	*/
	DeleteNetwork(ctx context.Context, projectId string, region string, networkId string) ApiDeleteNetworkRequest
	/*
		DeleteNetworkExecute executes the request

	*/
	DeleteNetworkExecute(ctx context.Context, projectId string, region string, networkId string) error
	/*
		DeleteRouteFromRoutingTable Delete a route in a routing table.
		Delete a route in an existing routing table.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@param routeId The identifier (ID) of a STACKIT Route.
		@return ApiDeleteRouteFromRoutingTableRequest
	*/
	DeleteRouteFromRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) ApiDeleteRouteFromRoutingTableRequest
	/*
		DeleteRouteFromRoutingTableExecute executes the request

	*/
	DeleteRouteFromRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) error
	/*
		DeleteRoutingTableFromArea Delete a routing table.
		Delete a routing table of a network area.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return ApiDeleteRoutingTableFromAreaRequest
	*/
	DeleteRoutingTableFromArea(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiDeleteRoutingTableFromAreaRequest
	/*
		DeleteRoutingTableFromAreaExecute executes the request

	*/
	DeleteRoutingTableFromAreaExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) error
	/*
		GetNetwork Get network details.
		Get details about a network of a project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@param networkId The identifier (ID) of a STACKIT Network.
		@return ApiGetNetworkRequest
	*/
	GetNetwork(ctx context.Context, projectId string, region string, networkId string) ApiGetNetworkRequest
	/*
		GetNetworkExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@param networkId The identifier (ID) of a STACKIT Network.
		@return Network

	*/
	GetNetworkExecute(ctx context.Context, projectId string, region string, networkId string) (*Network, error)
	/*
		GetRouteOfRoutingTable Get details about a route of a routing table.
		Get details about a route defined in a routing table.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@param routeId The identifier (ID) of a STACKIT Route.
		@return ApiGetRouteOfRoutingTableRequest
	*/
	GetRouteOfRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) ApiGetRouteOfRoutingTableRequest
	/*
		GetRouteOfRoutingTableExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@param routeId The identifier (ID) of a STACKIT Route.
		@return Route

	*/
	GetRouteOfRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) (*Route, error)
	/*
		GetRoutingTableOfArea Get details about a routing table.
		Get details about a routing table defined in a network area.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return ApiGetRoutingTableOfAreaRequest
	*/
	GetRoutingTableOfArea(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiGetRoutingTableOfAreaRequest
	/*
		GetRoutingTableOfAreaExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return RoutingTable

	*/
	GetRoutingTableOfAreaExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RoutingTable, error)
	/*
		ListNetworks List all networks inside a project.
		Get a list of all networks inside a project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@return ApiListNetworksRequest
	*/
	ListNetworks(ctx context.Context, projectId string, region string) ApiListNetworksRequest
	/*
		ListNetworksExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@return NetworkListResponse

	*/
	ListNetworksExecute(ctx context.Context, projectId string, region string) (*NetworkListResponse, error)
	/*
		ListRoutesOfRoutingTable List all routes in a routing table.
		Get a list of all routes in a routing table.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return ApiListRoutesOfRoutingTableRequest
	*/
	ListRoutesOfRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiListRoutesOfRoutingTableRequest
	/*
		ListRoutesOfRoutingTableExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return RouteListResponse

	*/
	ListRoutesOfRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RouteListResponse, error)
	/*
		ListRoutingTablesOfArea List all routing tables in a network area.
		Get a list of all routing tables in a network area.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@return ApiListRoutingTablesOfAreaRequest
	*/
	ListRoutingTablesOfArea(ctx context.Context, organizationId string, areaId string, region string) ApiListRoutingTablesOfAreaRequest
	/*
		ListRoutingTablesOfAreaExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@return RoutingTableListResponse

	*/
	ListRoutingTablesOfAreaExecute(ctx context.Context, organizationId string, areaId string, region string) (*RoutingTableListResponse, error)
	/*
		PartialUpdateNetwork Update network settings.
		Update the settings of a network inside a project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The identifier (ID) of a STACKIT Project.
		@param region The STACKIT Region of the resources.
		@param networkId The identifier (ID) of a STACKIT Network.
		@return ApiPartialUpdateNetworkRequest
	*/
	PartialUpdateNetwork(ctx context.Context, projectId string, region string, networkId string) ApiPartialUpdateNetworkRequest
	/*
		PartialUpdateNetworkExecute executes the request

	*/
	PartialUpdateNetworkExecute(ctx context.Context, projectId string, region string, networkId string) error
	/*
		UpdateRouteOfRoutingTable Update a route of a routing table.
		Update a route defined in a routing table.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@param routeId The identifier (ID) of a STACKIT Route.
		@return ApiUpdateRouteOfRoutingTableRequest
	*/
	UpdateRouteOfRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) ApiUpdateRouteOfRoutingTableRequest
	/*
		UpdateRouteOfRoutingTableExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@param routeId The identifier (ID) of a STACKIT Route.
		@return Route

	*/
	UpdateRouteOfRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) (*Route, error)
	/*
		UpdateRoutingTableOfArea Update a routing table.
		Update a routing table defined in a network area.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return ApiUpdateRoutingTableOfAreaRequest
	*/
	UpdateRoutingTableOfArea(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiUpdateRoutingTableOfAreaRequest
	/*
		UpdateRoutingTableOfAreaExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId The identifier (ID) of a STACKIT Organization.
		@param areaId The identifier (ID) of a STACKIT Network Area.
		@param region The STACKIT Region of the resources.
		@param routingTableId The identifier (ID) of a STACKIT Routing Table.
		@return RoutingTable

	*/
	UpdateRoutingTableOfAreaExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RoutingTable, error)
}

type ApiAddRoutesToRoutingTableRequest interface {
	// Request an addition of routes to a routing table.
	AddRoutesToRoutingTablePayload(addRoutesToRoutingTablePayload AddRoutesToRoutingTablePayload) ApiAddRoutesToRoutingTableRequest
	Execute() (*RouteListResponse, error)
}

type ApiAddRoutingTableToAreaRequest interface {
	// Request an addition of a routing table to an area.
	AddRoutingTableToAreaPayload(addRoutingTableToAreaPayload AddRoutingTableToAreaPayload) ApiAddRoutingTableToAreaRequest
	Execute() (*RoutingTable, error)
}

type ApiCreateNetworkRequest interface {
	// Request a network creation.
	CreateNetworkPayload(createNetworkPayload CreateNetworkPayload) ApiCreateNetworkRequest
	Execute() (*Network, error)
}

type ApiDeleteNetworkRequest interface {
	Execute() error
}

type ApiDeleteRouteFromRoutingTableRequest interface {
	Execute() error
}

type ApiDeleteRoutingTableFromAreaRequest interface {
	Execute() error
}

type ApiGetNetworkRequest interface {
	Execute() (*Network, error)
}

type ApiGetRouteOfRoutingTableRequest interface {
	Execute() (*Route, error)
}

type ApiGetRoutingTableOfAreaRequest interface {
	Execute() (*RoutingTable, error)
}

type ApiListNetworksRequest interface {
	// Filter resources by labels.
	LabelSelector(labelSelector string) ApiListNetworksRequest
	Execute() (*NetworkListResponse, error)
}

type ApiListRoutesOfRoutingTableRequest interface {
	// Filter resources by labels.
	LabelSelector(labelSelector string) ApiListRoutesOfRoutingTableRequest
	Execute() (*RouteListResponse, error)
}

type ApiListRoutingTablesOfAreaRequest interface {
	// Filter resources by labels.
	LabelSelector(labelSelector string) ApiListRoutingTablesOfAreaRequest
	Execute() (*RoutingTableListResponse, error)
}

type ApiPartialUpdateNetworkRequest interface {
	// Request an update of a network.
	PartialUpdateNetworkPayload(partialUpdateNetworkPayload PartialUpdateNetworkPayload) ApiPartialUpdateNetworkRequest
	Execute() error
}

type ApiUpdateRouteOfRoutingTableRequest interface {
	// Request an update of a route in a routing table.
	UpdateRouteOfRoutingTablePayload(updateRouteOfRoutingTablePayload UpdateRouteOfRoutingTablePayload) ApiUpdateRouteOfRoutingTableRequest
	Execute() (*Route, error)
}

type ApiUpdateRoutingTableOfAreaRequest interface {
	// Request an update of a routing table.
	UpdateRoutingTableOfAreaPayload(updateRoutingTableOfAreaPayload UpdateRoutingTableOfAreaPayload) ApiUpdateRoutingTableOfAreaRequest
	Execute() (*RoutingTable, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type AddRoutesToRoutingTableRequest struct {
	ctx                            context.Context
	apiService                     *DefaultApiService
	organizationId                 string
	areaId                         string
	region                         string
	routingTableId                 string
	addRoutesToRoutingTablePayload *AddRoutesToRoutingTablePayload
}

// Request an addition of routes to a routing table.

func (r AddRoutesToRoutingTableRequest) AddRoutesToRoutingTablePayload(addRoutesToRoutingTablePayload AddRoutesToRoutingTablePayload) ApiAddRoutesToRoutingTableRequest {
	r.addRoutesToRoutingTablePayload = &addRoutesToRoutingTablePayload
	return r
}

func (r AddRoutesToRoutingTableRequest) Execute() (*RouteListResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RouteListResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddRoutesToRoutingTable")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have less than 36 elements")
	}
	if r.addRoutesToRoutingTablePayload == nil {
		return localVarReturnValue, fmt.Errorf("addRoutesToRoutingTablePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addRoutesToRoutingTablePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
AddRoutesToRoutingTable: Create new routes in a routing table.

Create new routes in an existing routing table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@return ApiAddRoutesToRoutingTableRequest
*/
func (a *APIClient) AddRoutesToRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiAddRoutesToRoutingTableRequest {
	return AddRoutesToRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
}

func (a *APIClient) AddRoutesToRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RouteListResponse, error) {
	r := AddRoutesToRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
	return r.Execute()
}

type AddRoutingTableToAreaRequest struct {
	ctx                          context.Context
	apiService                   *DefaultApiService
	organizationId               string
	areaId                       string
	region                       string
	addRoutingTableToAreaPayload *AddRoutingTableToAreaPayload
}

// Request an addition of a routing table to an area.

func (r AddRoutingTableToAreaRequest) AddRoutingTableToAreaPayload(addRoutingTableToAreaPayload AddRoutingTableToAreaPayload) ApiAddRoutingTableToAreaRequest {
	r.addRoutingTableToAreaPayload = &addRoutingTableToAreaPayload
	return r
}

func (r AddRoutingTableToAreaRequest) Execute() (*RoutingTable, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoutingTable
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddRoutingTableToArea")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if r.addRoutingTableToAreaPayload == nil {
		return localVarReturnValue, fmt.Errorf("addRoutingTableToAreaPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addRoutingTableToAreaPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
AddRoutingTableToArea: Create new routing table in a network area.

Create a new routing table in an existing network area.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@return ApiAddRoutingTableToAreaRequest
*/
func (a *APIClient) AddRoutingTableToArea(ctx context.Context, organizationId string, areaId string, region string) ApiAddRoutingTableToAreaRequest {
	return AddRoutingTableToAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
	}
}

func (a *APIClient) AddRoutingTableToAreaExecute(ctx context.Context, organizationId string, areaId string, region string) (*RoutingTable, error) {
	r := AddRoutingTableToAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
	}
	return r.Execute()
}

type CreateNetworkRequest struct {
	ctx                  context.Context
	apiService           *DefaultApiService
	projectId            string
	region               string
	createNetworkPayload *CreateNetworkPayload
}

// Request a network creation.

func (r CreateNetworkRequest) CreateNetworkPayload(createNetworkPayload CreateNetworkPayload) ApiCreateNetworkRequest {
	r.createNetworkPayload = &createNetworkPayload
	return r
}

func (r CreateNetworkRequest) Execute() (*Network, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Network
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateNetwork")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/projects/{projectId}/regions/{region}/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have less than 36 elements")
	}
	if r.createNetworkPayload == nil {
		return localVarReturnValue, fmt.Errorf("createNetworkPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateNetwork: Create new network.

Create a new network in a project. `nameservers` will be filled from `defaultNameservers` of the respective area if not specified. If the project has `internetAccess` enabled and this is the first network in the project this might incur cost.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The identifier (ID) of a STACKIT Project.
	@param region The STACKIT Region of the resources.
	@return ApiCreateNetworkRequest
*/
func (a *APIClient) CreateNetwork(ctx context.Context, projectId string, region string) ApiCreateNetworkRequest {
	return CreateNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) CreateNetworkExecute(ctx context.Context, projectId string, region string) (*Network, error) {
	r := CreateNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type DeleteNetworkRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	region     string
	networkId  string
}

func (r DeleteNetworkRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteNetwork")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/projects/{projectId}/regions/{region}/networks/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(ParameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return fmt.Errorf("projectId must have less than 36 elements")
	}
	if strlen(r.networkId) < 36 {
		return fmt.Errorf("networkId must have at least 36 elements")
	}
	if strlen(r.networkId) > 36 {
		return fmt.Errorf("networkId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteNetwork: Delete network.

Delete a network. If the network is still in use, the deletion will fail.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The identifier (ID) of a STACKIT Project.
	@param region The STACKIT Region of the resources.
	@param networkId The identifier (ID) of a STACKIT Network.
	@return ApiDeleteNetworkRequest
*/
func (a *APIClient) DeleteNetwork(ctx context.Context, projectId string, region string, networkId string) ApiDeleteNetworkRequest {
	return DeleteNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
		networkId:  networkId,
	}
}

func (a *APIClient) DeleteNetworkExecute(ctx context.Context, projectId string, region string, networkId string) error {
	r := DeleteNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
		networkId:  networkId,
	}
	return r.Execute()
}

type DeleteRouteFromRoutingTableRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	areaId         string
	region         string
	routingTableId string
	routeId        string
}

func (r DeleteRouteFromRoutingTableRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRouteFromRoutingTable")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}/routes/{routeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(ParameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return fmt.Errorf("routingTableId must have less than 36 elements")
	}
	if strlen(r.routeId) < 36 {
		return fmt.Errorf("routeId must have at least 36 elements")
	}
	if strlen(r.routeId) > 36 {
		return fmt.Errorf("routeId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteRouteFromRoutingTable: Delete a route in a routing table.

Delete a route in an existing routing table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@param routeId The identifier (ID) of a STACKIT Route.
	@return ApiDeleteRouteFromRoutingTableRequest
*/
func (a *APIClient) DeleteRouteFromRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) ApiDeleteRouteFromRoutingTableRequest {
	return DeleteRouteFromRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
		routeId:        routeId,
	}
}

func (a *APIClient) DeleteRouteFromRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) error {
	r := DeleteRouteFromRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
		routeId:        routeId,
	}
	return r.Execute()
}

type DeleteRoutingTableFromAreaRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	areaId         string
	region         string
	routingTableId string
}

func (r DeleteRoutingTableFromAreaRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRoutingTableFromArea")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return fmt.Errorf("routingTableId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteRoutingTableFromArea: Delete a routing table.

Delete a routing table of a network area.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@return ApiDeleteRoutingTableFromAreaRequest
*/
func (a *APIClient) DeleteRoutingTableFromArea(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiDeleteRoutingTableFromAreaRequest {
	return DeleteRoutingTableFromAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
}

func (a *APIClient) DeleteRoutingTableFromAreaExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) error {
	r := DeleteRoutingTableFromAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
	return r.Execute()
}

type GetNetworkRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	region     string
	networkId  string
}

func (r GetNetworkRequest) Execute() (*Network, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Network
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNetwork")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/projects/{projectId}/regions/{region}/networks/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(ParameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have less than 36 elements")
	}
	if strlen(r.networkId) < 36 {
		return localVarReturnValue, fmt.Errorf("networkId must have at least 36 elements")
	}
	if strlen(r.networkId) > 36 {
		return localVarReturnValue, fmt.Errorf("networkId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetNetwork: Get network details.

Get details about a network of a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The identifier (ID) of a STACKIT Project.
	@param region The STACKIT Region of the resources.
	@param networkId The identifier (ID) of a STACKIT Network.
	@return ApiGetNetworkRequest
*/
func (a *APIClient) GetNetwork(ctx context.Context, projectId string, region string, networkId string) ApiGetNetworkRequest {
	return GetNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
		networkId:  networkId,
	}
}

func (a *APIClient) GetNetworkExecute(ctx context.Context, projectId string, region string, networkId string) (*Network, error) {
	r := GetNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
		networkId:  networkId,
	}
	return r.Execute()
}

type GetRouteOfRoutingTableRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	areaId         string
	region         string
	routingTableId string
	routeId        string
}

func (r GetRouteOfRoutingTableRequest) Execute() (*Route, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Route
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRouteOfRoutingTable")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}/routes/{routeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(ParameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have less than 36 elements")
	}
	if strlen(r.routeId) < 36 {
		return localVarReturnValue, fmt.Errorf("routeId must have at least 36 elements")
	}
	if strlen(r.routeId) > 36 {
		return localVarReturnValue, fmt.Errorf("routeId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRouteOfRoutingTable: Get details about a route of a routing table.

Get details about a route defined in a routing table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@param routeId The identifier (ID) of a STACKIT Route.
	@return ApiGetRouteOfRoutingTableRequest
*/
func (a *APIClient) GetRouteOfRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) ApiGetRouteOfRoutingTableRequest {
	return GetRouteOfRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
		routeId:        routeId,
	}
}

func (a *APIClient) GetRouteOfRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) (*Route, error) {
	r := GetRouteOfRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
		routeId:        routeId,
	}
	return r.Execute()
}

type GetRoutingTableOfAreaRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	areaId         string
	region         string
	routingTableId string
}

func (r GetRoutingTableOfAreaRequest) Execute() (*RoutingTable, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoutingTable
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRoutingTableOfArea")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRoutingTableOfArea: Get details about a routing table.

Get details about a routing table defined in a network area.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@return ApiGetRoutingTableOfAreaRequest
*/
func (a *APIClient) GetRoutingTableOfArea(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiGetRoutingTableOfAreaRequest {
	return GetRoutingTableOfAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
}

func (a *APIClient) GetRoutingTableOfAreaExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RoutingTable, error) {
	r := GetRoutingTableOfAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
	return r.Execute()
}

type ListNetworksRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	region        string
	labelSelector *string
}

// Filter resources by labels.

func (r ListNetworksRequest) LabelSelector(labelSelector string) ApiListNetworksRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ListNetworksRequest) Execute() (*NetworkListResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NetworkListResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListNetworks")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/projects/{projectId}/regions/{region}/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have less than 36 elements")
	}

	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListNetworks: List all networks inside a project.

Get a list of all networks inside a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The identifier (ID) of a STACKIT Project.
	@param region The STACKIT Region of the resources.
	@return ApiListNetworksRequest
*/
func (a *APIClient) ListNetworks(ctx context.Context, projectId string, region string) ApiListNetworksRequest {
	return ListNetworksRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) ListNetworksExecute(ctx context.Context, projectId string, region string) (*NetworkListResponse, error) {
	r := ListNetworksRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type ListRoutesOfRoutingTableRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	areaId         string
	region         string
	routingTableId string
	labelSelector  *string
}

// Filter resources by labels.

func (r ListRoutesOfRoutingTableRequest) LabelSelector(labelSelector string) ApiListRoutesOfRoutingTableRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ListRoutesOfRoutingTableRequest) Execute() (*RouteListResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RouteListResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoutesOfRoutingTable")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have less than 36 elements")
	}

	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRoutesOfRoutingTable: List all routes in a routing table.

Get a list of all routes in a routing table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@return ApiListRoutesOfRoutingTableRequest
*/
func (a *APIClient) ListRoutesOfRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiListRoutesOfRoutingTableRequest {
	return ListRoutesOfRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
}

func (a *APIClient) ListRoutesOfRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RouteListResponse, error) {
	r := ListRoutesOfRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
	return r.Execute()
}

type ListRoutingTablesOfAreaRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	areaId         string
	region         string
	labelSelector  *string
}

// Filter resources by labels.

func (r ListRoutingTablesOfAreaRequest) LabelSelector(labelSelector string) ApiListRoutingTablesOfAreaRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ListRoutingTablesOfAreaRequest) Execute() (*RoutingTableListResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoutingTableListResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoutingTablesOfArea")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}

	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRoutingTablesOfArea: List all routing tables in a network area.

Get a list of all routing tables in a network area.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@return ApiListRoutingTablesOfAreaRequest
*/
func (a *APIClient) ListRoutingTablesOfArea(ctx context.Context, organizationId string, areaId string, region string) ApiListRoutingTablesOfAreaRequest {
	return ListRoutingTablesOfAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
	}
}

func (a *APIClient) ListRoutingTablesOfAreaExecute(ctx context.Context, organizationId string, areaId string, region string) (*RoutingTableListResponse, error) {
	r := ListRoutingTablesOfAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
	}
	return r.Execute()
}

type PartialUpdateNetworkRequest struct {
	ctx                         context.Context
	apiService                  *DefaultApiService
	projectId                   string
	region                      string
	networkId                   string
	partialUpdateNetworkPayload *PartialUpdateNetworkPayload
}

// Request an update of a network.

func (r PartialUpdateNetworkRequest) PartialUpdateNetworkPayload(partialUpdateNetworkPayload PartialUpdateNetworkPayload) ApiPartialUpdateNetworkRequest {
	r.partialUpdateNetworkPayload = &partialUpdateNetworkPayload
	return r
}

func (r PartialUpdateNetworkRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateNetwork")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/projects/{projectId}/regions/{region}/networks/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(ParameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return fmt.Errorf("projectId must have less than 36 elements")
	}
	if strlen(r.networkId) < 36 {
		return fmt.Errorf("networkId must have at least 36 elements")
	}
	if strlen(r.networkId) > 36 {
		return fmt.Errorf("networkId must have less than 36 elements")
	}
	if r.partialUpdateNetworkPayload == nil {
		return fmt.Errorf("partialUpdateNetworkPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateNetworkPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
PartialUpdateNetwork: Update network settings.

Update the settings of a network inside a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The identifier (ID) of a STACKIT Project.
	@param region The STACKIT Region of the resources.
	@param networkId The identifier (ID) of a STACKIT Network.
	@return ApiPartialUpdateNetworkRequest
*/
func (a *APIClient) PartialUpdateNetwork(ctx context.Context, projectId string, region string, networkId string) ApiPartialUpdateNetworkRequest {
	return PartialUpdateNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
		networkId:  networkId,
	}
}

func (a *APIClient) PartialUpdateNetworkExecute(ctx context.Context, projectId string, region string, networkId string) error {
	r := PartialUpdateNetworkRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
		networkId:  networkId,
	}
	return r.Execute()
}

type UpdateRouteOfRoutingTableRequest struct {
	ctx                              context.Context
	apiService                       *DefaultApiService
	organizationId                   string
	areaId                           string
	region                           string
	routingTableId                   string
	routeId                          string
	updateRouteOfRoutingTablePayload *UpdateRouteOfRoutingTablePayload
}

// Request an update of a route in a routing table.

func (r UpdateRouteOfRoutingTableRequest) UpdateRouteOfRoutingTablePayload(updateRouteOfRoutingTablePayload UpdateRouteOfRoutingTablePayload) ApiUpdateRouteOfRoutingTableRequest {
	r.updateRouteOfRoutingTablePayload = &updateRouteOfRoutingTablePayload
	return r
}

func (r UpdateRouteOfRoutingTableRequest) Execute() (*Route, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Route
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateRouteOfRoutingTable")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}/routes/{routeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(ParameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have less than 36 elements")
	}
	if strlen(r.routeId) < 36 {
		return localVarReturnValue, fmt.Errorf("routeId must have at least 36 elements")
	}
	if strlen(r.routeId) > 36 {
		return localVarReturnValue, fmt.Errorf("routeId must have less than 36 elements")
	}
	if r.updateRouteOfRoutingTablePayload == nil {
		return localVarReturnValue, fmt.Errorf("updateRouteOfRoutingTablePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRouteOfRoutingTablePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateRouteOfRoutingTable: Update a route of a routing table.

Update a route defined in a routing table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@param routeId The identifier (ID) of a STACKIT Route.
	@return ApiUpdateRouteOfRoutingTableRequest
*/
func (a *APIClient) UpdateRouteOfRoutingTable(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) ApiUpdateRouteOfRoutingTableRequest {
	return UpdateRouteOfRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
		routeId:        routeId,
	}
}

func (a *APIClient) UpdateRouteOfRoutingTableExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string, routeId string) (*Route, error) {
	r := UpdateRouteOfRoutingTableRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
		routeId:        routeId,
	}
	return r.Execute()
}

type UpdateRoutingTableOfAreaRequest struct {
	ctx                             context.Context
	apiService                      *DefaultApiService
	organizationId                  string
	areaId                          string
	region                          string
	routingTableId                  string
	updateRoutingTableOfAreaPayload *UpdateRoutingTableOfAreaPayload
}

// Request an update of a routing table.

func (r UpdateRoutingTableOfAreaRequest) UpdateRoutingTableOfAreaPayload(updateRoutingTableOfAreaPayload UpdateRoutingTableOfAreaPayload) ApiUpdateRoutingTableOfAreaRequest {
	r.updateRoutingTableOfAreaPayload = &updateRoutingTableOfAreaPayload
	return r
}

func (r UpdateRoutingTableOfAreaRequest) Execute() (*RoutingTable, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoutingTable
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateRoutingTableOfArea")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2alpha1/organizations/{organizationId}/network-areas/{areaId}/regions/{region}/routing-tables/{routingTableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"areaId"+"}", url.PathEscape(ParameterValueToString(r.areaId, "areaId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"routingTableId"+"}", url.PathEscape(ParameterValueToString(r.routingTableId, "routingTableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.organizationId) < 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have at least 36 elements")
	}
	if strlen(r.organizationId) > 36 {
		return localVarReturnValue, fmt.Errorf("organizationId must have less than 36 elements")
	}
	if strlen(r.areaId) < 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have at least 36 elements")
	}
	if strlen(r.areaId) > 36 {
		return localVarReturnValue, fmt.Errorf("areaId must have less than 36 elements")
	}
	if strlen(r.routingTableId) < 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have at least 36 elements")
	}
	if strlen(r.routingTableId) > 36 {
		return localVarReturnValue, fmt.Errorf("routingTableId must have less than 36 elements")
	}
	if r.updateRoutingTableOfAreaPayload == nil {
		return localVarReturnValue, fmt.Errorf("updateRoutingTableOfAreaPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRoutingTableOfAreaPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateRoutingTableOfArea: Update a routing table.

Update a routing table defined in a network area.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId The identifier (ID) of a STACKIT Organization.
	@param areaId The identifier (ID) of a STACKIT Network Area.
	@param region The STACKIT Region of the resources.
	@param routingTableId The identifier (ID) of a STACKIT Routing Table.
	@return ApiUpdateRoutingTableOfAreaRequest
*/
func (a *APIClient) UpdateRoutingTableOfArea(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) ApiUpdateRoutingTableOfAreaRequest {
	return UpdateRoutingTableOfAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
}

func (a *APIClient) UpdateRoutingTableOfAreaExecute(ctx context.Context, organizationId string, areaId string, region string, routingTableId string) (*RoutingTable, error) {
	r := UpdateRoutingTableOfAreaRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
		areaId:         areaId,
		region:         region,
		routingTableId: routingTableId,
	}
	return r.Execute()
}
