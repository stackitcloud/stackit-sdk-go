/*
Audit Log API

API Endpoints to retrieve recorded actions and resulting changes in the system.  ### Documentation The user documentation with explanations how to use the api can be found  [here](https://docs.stackit.cloud/stackit/en/retrieve-audit-log-per-api-request-134415907.html).  ### Audit Logging Changes on organizations, folders and projects and respective cloud resources are logged and collected in the audit  log.  ### API Constraints The audit log API allows to download messages from the last 90 days. The maximum duration that can be queried at  once is 24 hours. Requests are rate limited - the current maximum is 60 requests per minute.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package auditlog

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		ListFolderAuditLogEntries Folder - Download audit log entries
		Returns all audit log entries of the folder for the specified period. \
		Period must not be longer than 24 hours within the last 90 days.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param folderId ID of the folder for which entries should be returned.
		@return ApiListFolderAuditLogEntriesRequest
	*/
	ListFolderAuditLogEntries(ctx context.Context, folderId string) ApiListFolderAuditLogEntriesRequest
	/*
		ListFolderAuditLogEntriesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param folderId ID of the folder for which entries should be returned.
		@return ListFolderAuditLogEntries200Response

	*/
	ListFolderAuditLogEntriesExecute(ctx context.Context, folderId string) (*ListFolderAuditLogEntries200Response, error)
	/*
		ListOrganizationAuditLogEntries Organization - Download audit log entries
		Returns all audit log entries of the organization for the specified period. \
		Period must not be longer than 24 hours within the last 90 days.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId ID of the organization for which entries should be returned.
		@return ApiListOrganizationAuditLogEntriesRequest
	*/
	ListOrganizationAuditLogEntries(ctx context.Context, organizationId string) ApiListOrganizationAuditLogEntriesRequest
	/*
		ListOrganizationAuditLogEntriesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId ID of the organization for which entries should be returned.
		@return ListFolderAuditLogEntries200Response

	*/
	ListOrganizationAuditLogEntriesExecute(ctx context.Context, organizationId string) (*ListFolderAuditLogEntries200Response, error)
	/*
		ListProjectAuditLogEntries Project - Download audit log entries
		Returns all audit log entries of the project for the specified period. \
		Period must not be longer than 24 hours within the last 90 days.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId ID of the project for which entries should be returned.
		@return ApiListProjectAuditLogEntriesRequest
	*/
	ListProjectAuditLogEntries(ctx context.Context, projectId string) ApiListProjectAuditLogEntriesRequest
	/*
		ListProjectAuditLogEntriesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId ID of the project for which entries should be returned.
		@return ListFolderAuditLogEntries200Response

	*/
	ListProjectAuditLogEntriesExecute(ctx context.Context, projectId string) (*ListFolderAuditLogEntries200Response, error)
}

type ApiListFolderAuditLogEntriesRequest interface {
	// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.
	StartTimeRange(startTimeRange time.Time) ApiListFolderAuditLogEntriesRequest
	// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.
	EndTimeRange(endTimeRange time.Time) ApiListFolderAuditLogEntriesRequest
	// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.
	Limit(limit float32) ApiListFolderAuditLogEntriesRequest
	// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.
	Cursor(cursor string) ApiListFolderAuditLogEntriesRequest
	Execute() (*ListFolderAuditLogEntries200Response, error)
}

type ApiListOrganizationAuditLogEntriesRequest interface {
	// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.
	StartTimeRange(startTimeRange time.Time) ApiListOrganizationAuditLogEntriesRequest
	// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.
	EndTimeRange(endTimeRange time.Time) ApiListOrganizationAuditLogEntriesRequest
	// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.
	Limit(limit float32) ApiListOrganizationAuditLogEntriesRequest
	// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.
	Cursor(cursor string) ApiListOrganizationAuditLogEntriesRequest
	Execute() (*ListFolderAuditLogEntries200Response, error)
}

type ApiListProjectAuditLogEntriesRequest interface {
	// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.
	StartTimeRange(startTimeRange time.Time) ApiListProjectAuditLogEntriesRequest
	// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.
	EndTimeRange(endTimeRange time.Time) ApiListProjectAuditLogEntriesRequest
	// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.
	Limit(limit float32) ApiListProjectAuditLogEntriesRequest
	// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.
	Cursor(cursor string) ApiListProjectAuditLogEntriesRequest
	Execute() (*ListFolderAuditLogEntries200Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ListFolderAuditLogEntriesRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	folderId       string
	startTimeRange *time.Time
	endTimeRange   *time.Time
	limit          *float32
	cursor         *string
}

// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.

func (r ListFolderAuditLogEntriesRequest) StartTimeRange(startTimeRange time.Time) ApiListFolderAuditLogEntriesRequest {
	r.startTimeRange = &startTimeRange
	return r
}

// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.

func (r ListFolderAuditLogEntriesRequest) EndTimeRange(endTimeRange time.Time) ApiListFolderAuditLogEntriesRequest {
	r.endTimeRange = &endTimeRange
	return r
}

// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.

func (r ListFolderAuditLogEntriesRequest) Limit(limit float32) ApiListFolderAuditLogEntriesRequest {
	r.limit = &limit
	return r
}

// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.

func (r ListFolderAuditLogEntriesRequest) Cursor(cursor string) ApiListFolderAuditLogEntriesRequest {
	r.cursor = &cursor
	return r
}

func (r ListFolderAuditLogEntriesRequest) Execute() (*ListFolderAuditLogEntries200Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListFolderAuditLogEntries200Response
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListFolderAuditLogEntries")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(ParameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("startTimeRange is required and must be specified")
	}
	if r.endTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("endTimeRange is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start-time-range", r.startTimeRange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end-time-range", r.endTimeRange, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListFolderAuditLogEntries: Folder - Download audit log entries

Returns all audit log entries of the folder for the specified period. \
Period must not be longer than 24 hours within the last 90 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param folderId ID of the folder for which entries should be returned.
	@return ApiListFolderAuditLogEntriesRequest
*/
func (a *APIClient) ListFolderAuditLogEntries(ctx context.Context, folderId string) ApiListFolderAuditLogEntriesRequest {
	return ListFolderAuditLogEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		folderId:   folderId,
	}
}

func (a *APIClient) ListFolderAuditLogEntriesExecute(ctx context.Context, folderId string) (*ListFolderAuditLogEntries200Response, error) {
	r := ListFolderAuditLogEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		folderId:   folderId,
	}
	return r.Execute()
}

type ListOrganizationAuditLogEntriesRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	startTimeRange *time.Time
	endTimeRange   *time.Time
	limit          *float32
	cursor         *string
}

// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.

func (r ListOrganizationAuditLogEntriesRequest) StartTimeRange(startTimeRange time.Time) ApiListOrganizationAuditLogEntriesRequest {
	r.startTimeRange = &startTimeRange
	return r
}

// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.

func (r ListOrganizationAuditLogEntriesRequest) EndTimeRange(endTimeRange time.Time) ApiListOrganizationAuditLogEntriesRequest {
	r.endTimeRange = &endTimeRange
	return r
}

// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.

func (r ListOrganizationAuditLogEntriesRequest) Limit(limit float32) ApiListOrganizationAuditLogEntriesRequest {
	r.limit = &limit
	return r
}

// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.

func (r ListOrganizationAuditLogEntriesRequest) Cursor(cursor string) ApiListOrganizationAuditLogEntriesRequest {
	r.cursor = &cursor
	return r
}

func (r ListOrganizationAuditLogEntriesRequest) Execute() (*ListFolderAuditLogEntries200Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListFolderAuditLogEntries200Response
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListOrganizationAuditLogEntries")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("startTimeRange is required and must be specified")
	}
	if r.endTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("endTimeRange is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start-time-range", r.startTimeRange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end-time-range", r.endTimeRange, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListOrganizationAuditLogEntries: Organization - Download audit log entries

Returns all audit log entries of the organization for the specified period. \
Period must not be longer than 24 hours within the last 90 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId ID of the organization for which entries should be returned.
	@return ApiListOrganizationAuditLogEntriesRequest
*/
func (a *APIClient) ListOrganizationAuditLogEntries(ctx context.Context, organizationId string) ApiListOrganizationAuditLogEntriesRequest {
	return ListOrganizationAuditLogEntriesRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
	}
}

func (a *APIClient) ListOrganizationAuditLogEntriesExecute(ctx context.Context, organizationId string) (*ListFolderAuditLogEntries200Response, error) {
	r := ListOrganizationAuditLogEntriesRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
	}
	return r.Execute()
}

type ListProjectAuditLogEntriesRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	startTimeRange *time.Time
	endTimeRange   *time.Time
	limit          *float32
	cursor         *string
}

// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.

func (r ListProjectAuditLogEntriesRequest) StartTimeRange(startTimeRange time.Time) ApiListProjectAuditLogEntriesRequest {
	r.startTimeRange = &startTimeRange
	return r
}

// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.

func (r ListProjectAuditLogEntriesRequest) EndTimeRange(endTimeRange time.Time) ApiListProjectAuditLogEntriesRequest {
	r.endTimeRange = &endTimeRange
	return r
}

// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.

func (r ListProjectAuditLogEntriesRequest) Limit(limit float32) ApiListProjectAuditLogEntriesRequest {
	r.limit = &limit
	return r
}

// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.

func (r ListProjectAuditLogEntriesRequest) Cursor(cursor string) ApiListProjectAuditLogEntriesRequest {
	r.cursor = &cursor
	return r
}

func (r ListProjectAuditLogEntriesRequest) Execute() (*ListFolderAuditLogEntries200Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListFolderAuditLogEntries200Response
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListProjectAuditLogEntries")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("startTimeRange is required and must be specified")
	}
	if r.endTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("endTimeRange is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start-time-range", r.startTimeRange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end-time-range", r.endTimeRange, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListProjectAuditLogEntries: Project - Download audit log entries

Returns all audit log entries of the project for the specified period. \
Period must not be longer than 24 hours within the last 90 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId ID of the project for which entries should be returned.
	@return ApiListProjectAuditLogEntriesRequest
*/
func (a *APIClient) ListProjectAuditLogEntries(ctx context.Context, projectId string) ApiListProjectAuditLogEntriesRequest {
	return ListProjectAuditLogEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListProjectAuditLogEntriesExecute(ctx context.Context, projectId string) (*ListFolderAuditLogEntries200Response, error) {
	r := ListProjectAuditLogEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}
