/*
Audit Log API

API Endpoints to retrieve recorded actions and resulting changes in the system.  ### Documentation The user documentation with explanations how to use the api can be found  [here](https://docs.stackit.cloud/stackit/en/retrieve-audit-log-per-api-request-134415907.html).  ### Audit Logging Changes on organizations, folders and projects and respective cloud resources are logged and collected in the audit  log.  ### API Constraints The audit log API allows to download messages from the last 90 days. The maximum duration that can be queried at  once is 24 hours. Requests are rate limited - the current maximum is 60 requests per minute.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package auditlog

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		DownloadFolderAuditEntries Folder - Download audit log entries
		Returns all audit log entries of the folder for the specified period. \
		Period must not be longer than 24 hours within the last 90 days.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param folderId ID of the folder for which entries should be returned.
		@return ApiDownloadFolderAuditEntriesRequest
	*/
	DownloadFolderAuditEntries(ctx context.Context, folderId string) ApiDownloadFolderAuditEntriesRequest
	/*
		DownloadFolderAuditEntriesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param folderId ID of the folder for which entries should be returned.
		@return DownloadFolderAuditEntries200Response

	*/
	DownloadFolderAuditEntriesExecute(ctx context.Context, folderId string) (*DownloadFolderAuditEntries200Response, error)
	/*
		DownloadOrganizationAuditEntries Organization - Download audit log entries
		Returns all audit log entries of the organization for the specified period. \
		Period must not be longer than 24 hours within the last 90 days.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId ID of the organization for which entries should be returned.
		@return ApiDownloadOrganizationAuditEntriesRequest
	*/
	DownloadOrganizationAuditEntries(ctx context.Context, organizationId string) ApiDownloadOrganizationAuditEntriesRequest
	/*
		DownloadOrganizationAuditEntriesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param organizationId ID of the organization for which entries should be returned.
		@return DownloadFolderAuditEntries200Response

	*/
	DownloadOrganizationAuditEntriesExecute(ctx context.Context, organizationId string) (*DownloadFolderAuditEntries200Response, error)
	/*
		DownloadProjectAuditEntries Project - Download audit log entries
		Returns all audit log entries of the project for the specified period. \
		Period must not be longer than 24 hours within the last 90 days.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId ID of the project for which entries should be returned.
		@return ApiDownloadProjectAuditEntriesRequest
	*/
	DownloadProjectAuditEntries(ctx context.Context, projectId string) ApiDownloadProjectAuditEntriesRequest
	/*
		DownloadProjectAuditEntriesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId ID of the project for which entries should be returned.
		@return DownloadFolderAuditEntries200Response

	*/
	DownloadProjectAuditEntriesExecute(ctx context.Context, projectId string) (*DownloadFolderAuditEntries200Response, error)
}

type ApiDownloadFolderAuditEntriesRequest interface {
	// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.
	StartTimeRange(startTimeRange time.Time) ApiDownloadFolderAuditEntriesRequest
	// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.
	EndTimeRange(endTimeRange time.Time) ApiDownloadFolderAuditEntriesRequest
	// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.
	Limit(limit float32) ApiDownloadFolderAuditEntriesRequest
	// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.
	Cursor(cursor string) ApiDownloadFolderAuditEntriesRequest
	Execute() (*DownloadFolderAuditEntries200Response, error)
}

type ApiDownloadOrganizationAuditEntriesRequest interface {
	// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.
	StartTimeRange(startTimeRange time.Time) ApiDownloadOrganizationAuditEntriesRequest
	// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.
	EndTimeRange(endTimeRange time.Time) ApiDownloadOrganizationAuditEntriesRequest
	// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.
	Limit(limit float32) ApiDownloadOrganizationAuditEntriesRequest
	// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.
	Cursor(cursor string) ApiDownloadOrganizationAuditEntriesRequest
	Execute() (*DownloadFolderAuditEntries200Response, error)
}

type ApiDownloadProjectAuditEntriesRequest interface {
	// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.
	StartTimeRange(startTimeRange time.Time) ApiDownloadProjectAuditEntriesRequest
	// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.
	EndTimeRange(endTimeRange time.Time) ApiDownloadProjectAuditEntriesRequest
	// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.
	Limit(limit float32) ApiDownloadProjectAuditEntriesRequest
	// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.
	Cursor(cursor string) ApiDownloadProjectAuditEntriesRequest
	Execute() (*DownloadFolderAuditEntries200Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type DownloadFolderAuditEntriesRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	folderId       string
	startTimeRange *time.Time
	endTimeRange   *time.Time
	limit          *float32
	cursor         *string
}

// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.

func (r DownloadFolderAuditEntriesRequest) StartTimeRange(startTimeRange time.Time) ApiDownloadFolderAuditEntriesRequest {
	r.startTimeRange = &startTimeRange
	return r
}

// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.

func (r DownloadFolderAuditEntriesRequest) EndTimeRange(endTimeRange time.Time) ApiDownloadFolderAuditEntriesRequest {
	r.endTimeRange = &endTimeRange
	return r
}

// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.

func (r DownloadFolderAuditEntriesRequest) Limit(limit float32) ApiDownloadFolderAuditEntriesRequest {
	r.limit = &limit
	return r
}

// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.

func (r DownloadFolderAuditEntriesRequest) Cursor(cursor string) ApiDownloadFolderAuditEntriesRequest {
	r.cursor = &cursor
	return r
}

func (r DownloadFolderAuditEntriesRequest) Execute() (*DownloadFolderAuditEntries200Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DownloadFolderAuditEntries200Response
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DownloadFolderAuditEntries")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(ParameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("startTimeRange is required and must be specified")
	}
	if r.endTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("endTimeRange is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start-time-range", r.startTimeRange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end-time-range", r.endTimeRange, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DownloadFolderAuditEntries: Folder - Download audit log entries

Returns all audit log entries of the folder for the specified period. \
Period must not be longer than 24 hours within the last 90 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param folderId ID of the folder for which entries should be returned.
	@return ApiDownloadFolderAuditEntriesRequest
*/
func (a *APIClient) DownloadFolderAuditEntries(ctx context.Context, folderId string) ApiDownloadFolderAuditEntriesRequest {
	return DownloadFolderAuditEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		folderId:   folderId,
	}
}

func (a *APIClient) DownloadFolderAuditEntriesExecute(ctx context.Context, folderId string) (*DownloadFolderAuditEntries200Response, error) {
	r := DownloadFolderAuditEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		folderId:   folderId,
	}
	return r.Execute()
}

type DownloadOrganizationAuditEntriesRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	organizationId string
	startTimeRange *time.Time
	endTimeRange   *time.Time
	limit          *float32
	cursor         *string
}

// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.

func (r DownloadOrganizationAuditEntriesRequest) StartTimeRange(startTimeRange time.Time) ApiDownloadOrganizationAuditEntriesRequest {
	r.startTimeRange = &startTimeRange
	return r
}

// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.

func (r DownloadOrganizationAuditEntriesRequest) EndTimeRange(endTimeRange time.Time) ApiDownloadOrganizationAuditEntriesRequest {
	r.endTimeRange = &endTimeRange
	return r
}

// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.

func (r DownloadOrganizationAuditEntriesRequest) Limit(limit float32) ApiDownloadOrganizationAuditEntriesRequest {
	r.limit = &limit
	return r
}

// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.

func (r DownloadOrganizationAuditEntriesRequest) Cursor(cursor string) ApiDownloadOrganizationAuditEntriesRequest {
	r.cursor = &cursor
	return r
}

func (r DownloadOrganizationAuditEntriesRequest) Execute() (*DownloadFolderAuditEntries200Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DownloadFolderAuditEntries200Response
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DownloadOrganizationAuditEntries")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(ParameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("startTimeRange is required and must be specified")
	}
	if r.endTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("endTimeRange is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start-time-range", r.startTimeRange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end-time-range", r.endTimeRange, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DownloadOrganizationAuditEntries: Organization - Download audit log entries

Returns all audit log entries of the organization for the specified period. \
Period must not be longer than 24 hours within the last 90 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param organizationId ID of the organization for which entries should be returned.
	@return ApiDownloadOrganizationAuditEntriesRequest
*/
func (a *APIClient) DownloadOrganizationAuditEntries(ctx context.Context, organizationId string) ApiDownloadOrganizationAuditEntriesRequest {
	return DownloadOrganizationAuditEntriesRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
	}
}

func (a *APIClient) DownloadOrganizationAuditEntriesExecute(ctx context.Context, organizationId string) (*DownloadFolderAuditEntries200Response, error) {
	r := DownloadOrganizationAuditEntriesRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		organizationId: organizationId,
	}
	return r.Execute()
}

type DownloadProjectAuditEntriesRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	startTimeRange *time.Time
	endTimeRange   *time.Time
	limit          *float32
	cursor         *string
}

// An ISO timestamp to specify the beginning of the time range from which entries should be returned, based on the eventTimeStamp. If not given, defaults to the beginning of time.

func (r DownloadProjectAuditEntriesRequest) StartTimeRange(startTimeRange time.Time) ApiDownloadProjectAuditEntriesRequest {
	r.startTimeRange = &startTimeRange
	return r
}

// An ISO timestamp to specify the end of the time range up until which entries should be returned, based on the eventTimeStamp. If not given, defaults to the time this request was received.

func (r DownloadProjectAuditEntriesRequest) EndTimeRange(endTimeRange time.Time) ApiDownloadProjectAuditEntriesRequest {
	r.endTimeRange = &endTimeRange
	return r
}

// The maximum number of entries to return. If the value exceeds the allowed maximum, the maximum value will be used instead.

func (r DownloadProjectAuditEntriesRequest) Limit(limit float32) ApiDownloadProjectAuditEntriesRequest {
	r.limit = &limit
	return r
}

// A pagination cursor to load further audit log entries for. May be included in the response of previous calls of the API.

func (r DownloadProjectAuditEntriesRequest) Cursor(cursor string) ApiDownloadProjectAuditEntriesRequest {
	r.cursor = &cursor
	return r
}

func (r DownloadProjectAuditEntriesRequest) Execute() (*DownloadFolderAuditEntries200Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DownloadFolderAuditEntries200Response
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DownloadProjectAuditEntries")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("startTimeRange is required and must be specified")
	}
	if r.endTimeRange == nil {
		return localVarReturnValue, fmt.Errorf("endTimeRange is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start-time-range", r.startTimeRange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end-time-range", r.endTimeRange, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DownloadProjectAuditEntries: Project - Download audit log entries

Returns all audit log entries of the project for the specified period. \
Period must not be longer than 24 hours within the last 90 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId ID of the project for which entries should be returned.
	@return ApiDownloadProjectAuditEntriesRequest
*/
func (a *APIClient) DownloadProjectAuditEntries(ctx context.Context, projectId string) ApiDownloadProjectAuditEntriesRequest {
	return DownloadProjectAuditEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) DownloadProjectAuditEntriesExecute(ctx context.Context, projectId string) (*DownloadFolderAuditEntries200Response, error) {
	r := DownloadProjectAuditEntriesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}
