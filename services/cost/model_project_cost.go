/*
STACKIT Cost API

The cost API provides detailed reports on the costs for a customer or project over a certain amount of time

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cost

import (
	"encoding/json"
	"fmt"
)

// ProjectCost struct for ProjectCost
type ProjectCost struct {
	ProjectCostWithDetailedServices   *ProjectCostWithDetailedServices
	ProjectCostWithReports            *ProjectCostWithReports
	ProjectCostWithSummarizedServices *ProjectCostWithSummarizedServices
	SummarizedProjectCost             *SummarizedProjectCost
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *ProjectCost) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal JSON data into ProjectCostWithDetailedServices
	err = json.Unmarshal(data, &dst.ProjectCostWithDetailedServices)
	if err == nil {
		jsonProjectCostWithDetailedServices, _ := json.Marshal(dst.ProjectCostWithDetailedServices)
		if string(jsonProjectCostWithDetailedServices) == "{}" { // empty struct
			dst.ProjectCostWithDetailedServices = nil
		} else {
			return nil // data stored in dst.ProjectCostWithDetailedServices, return on the first match
		}
	} else {
		dst.ProjectCostWithDetailedServices = nil
	}

	// try to unmarshal JSON data into ProjectCostWithReports
	err = json.Unmarshal(data, &dst.ProjectCostWithReports)
	if err == nil {
		jsonProjectCostWithReports, _ := json.Marshal(dst.ProjectCostWithReports)
		if string(jsonProjectCostWithReports) == "{}" { // empty struct
			dst.ProjectCostWithReports = nil
		} else {
			return nil // data stored in dst.ProjectCostWithReports, return on the first match
		}
	} else {
		dst.ProjectCostWithReports = nil
	}

	// try to unmarshal JSON data into ProjectCostWithSummarizedServices
	err = json.Unmarshal(data, &dst.ProjectCostWithSummarizedServices)
	if err == nil {
		jsonProjectCostWithSummarizedServices, _ := json.Marshal(dst.ProjectCostWithSummarizedServices)
		if string(jsonProjectCostWithSummarizedServices) == "{}" { // empty struct
			dst.ProjectCostWithSummarizedServices = nil
		} else {
			return nil // data stored in dst.ProjectCostWithSummarizedServices, return on the first match
		}
	} else {
		dst.ProjectCostWithSummarizedServices = nil
	}

	// try to unmarshal JSON data into SummarizedProjectCost
	err = json.Unmarshal(data, &dst.SummarizedProjectCost)
	if err == nil {
		jsonSummarizedProjectCost, _ := json.Marshal(dst.SummarizedProjectCost)
		if string(jsonSummarizedProjectCost) == "{}" { // empty struct
			dst.SummarizedProjectCost = nil
		} else {
			return nil // data stored in dst.SummarizedProjectCost, return on the first match
		}
	} else {
		dst.SummarizedProjectCost = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(ProjectCost)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *ProjectCost) MarshalJSON() ([]byte, error) {
	if src.ProjectCostWithDetailedServices != nil {
		return json.Marshal(&src.ProjectCostWithDetailedServices)
	}

	if src.ProjectCostWithReports != nil {
		return json.Marshal(&src.ProjectCostWithReports)
	}

	if src.ProjectCostWithSummarizedServices != nil {
		return json.Marshal(&src.ProjectCostWithSummarizedServices)
	}

	if src.SummarizedProjectCost != nil {
		return json.Marshal(&src.SummarizedProjectCost)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableProjectCost struct {
	value *ProjectCost
	isSet bool
}

func (v NullableProjectCost) Get() *ProjectCost {
	return v.value
}

func (v *NullableProjectCost) Set(val *ProjectCost) {
	v.value = val
	v.isSet = true
}

func (v NullableProjectCost) IsSet() bool {
	return v.isSet
}

func (v *NullableProjectCost) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableProjectCost(val *ProjectCost) *NullableProjectCost {
	return &NullableProjectCost{value: val, isSet: true}
}

func (v NullableProjectCost) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableProjectCost) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
