/*
Application Load Balancer API

### DEPRECATED! This service, lb-application, is no longer maintained. Please use the alb service, version v2beta2 instead  This API offers an interface to provision and manage load balancing servers in your STACKIT project. It also has the possibility of pooling target servers for load balancing purposes.  For each application load balancer provided, two VMs are deployed in your OpenStack project subject to a fee.

API version: 1beta.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lbapplication

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateCredentials Create credentials for observability of the application load balancer
		Deprecated: Creates and stores credentials for use with Application Load Balancer Observability.
		 For example, when using ARGUS, credentials must first be created via the ARGUS API
		 and then stored with this endpoint to be used by the Application Load Balancer.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiCreateCredentialsRequest
	*/
	CreateCredentials(ctx context.Context, projectId string) ApiCreateCredentialsRequest
	/*
		CreateCredentialsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return CreateCredentialsResponse

		Deprecated: Creates and stores credentials for use with Application Load Balancer Observability.
		 For example, when using ARGUS, credentials must first be created via the ARGUS API
		 and then stored with this endpoint to be used by the Application Load Balancer.
	*/
	CreateCredentialsExecute(ctx context.Context, projectId string) (*CreateCredentialsResponse, error)
	/*
		CreateLoadBalancer Create an application load balancer in a project
		Deprecated: Creates an Application Load Balancer.
		 The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiCreateLoadBalancerRequest
	*/
	CreateLoadBalancer(ctx context.Context, projectId string) ApiCreateLoadBalancerRequest
	/*
		CreateLoadBalancerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return LoadBalancer

		Deprecated: Creates an Application Load Balancer.
		 The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.
	*/
	CreateLoadBalancerExecute(ctx context.Context, projectId string) (*LoadBalancer, error)
	/*
		DeleteCredentials Delete a single credential in a project.
		Deprecated: Deletes the stored Observability credentials.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param credentialsRef
		@return ApiDeleteCredentialsRequest
	*/
	DeleteCredentials(ctx context.Context, projectId string, credentialsRef string) ApiDeleteCredentialsRequest
	/*
		DeleteCredentialsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param credentialsRef
		@return map[string]interface{}

		Deprecated: Deletes the stored Observability credentials.
	*/
	DeleteCredentialsExecute(ctx context.Context, projectId string, credentialsRef string) (map[string]interface{}, error)
	/*
		DeleteLoadBalancer Delete a given load balancer in a project.
		Deprecated: Deletes the specified Application Load Balancer.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@return ApiDeleteLoadBalancerRequest
	*/
	DeleteLoadBalancer(ctx context.Context, projectId string, name string) ApiDeleteLoadBalancerRequest
	/*
		DeleteLoadBalancerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@return map[string]interface{}

		Deprecated: Deletes the specified Application Load Balancer.
	*/
	DeleteLoadBalancerExecute(ctx context.Context, projectId string, name string) (map[string]interface{}, error)
	/*
		DisableService Disables the functionality of load balancers for the project specified.
		Deprecated: DEPRECATED! Disabling the Application Load Balancer functionality is now automatic.
		 This endpoint is kept for compatibility.
		 Disables the Application Load Balancer functionality for the specified project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiDisableServiceRequest
	*/
	DisableService(ctx context.Context, projectId string) ApiDisableServiceRequest
	/*
		DisableServiceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return map[string]interface{}

		Deprecated: DEPRECATED! Disabling the Application Load Balancer functionality is now automatic.
		 This endpoint is kept for compatibility.
		 Disables the Application Load Balancer functionality for the specified project.
	*/
	DisableServiceExecute(ctx context.Context, projectId string) (map[string]interface{}, error)
	/*
		EnableService Enables the functionality of application load balancers for the project specified.
		Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.
		 Enables the Application Load Balancer service for the specified project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiEnableServiceRequest
	*/
	EnableService(ctx context.Context, projectId string) ApiEnableServiceRequest
	/*
		EnableServiceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return map[string]interface{}

		Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.
		 Enables the Application Load Balancer service for the specified project.
	*/
	EnableServiceExecute(ctx context.Context, projectId string) (map[string]interface{}, error)
	/*
		GetCredentials Get a single credential reference in a project.
		Deprecated: Gets the stored Observability credentials.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param credentialsRef
		@return ApiGetCredentialsRequest
	*/
	GetCredentials(ctx context.Context, projectId string, credentialsRef string) ApiGetCredentialsRequest
	/*
		GetCredentialsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param credentialsRef
		@return GetCredentialsResponse

		Deprecated: Gets the stored Observability credentials.
	*/
	GetCredentialsExecute(ctx context.Context, projectId string, credentialsRef string) (*GetCredentialsResponse, error)
	/*
		GetLoadBalancer Get a single application load balancer in a project.
		Deprecated: Retrieves details of a specific Application Load Balancer in a project.
		 Includes creation and update information, current status, and any error descriptions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@return ApiGetLoadBalancerRequest
	*/
	GetLoadBalancer(ctx context.Context, projectId string, name string) ApiGetLoadBalancerRequest
	/*
		GetLoadBalancerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@return LoadBalancer

		Deprecated: Retrieves details of a specific Application Load Balancer in a project.
		 Includes creation and update information, current status, and any error descriptions.
	*/
	GetLoadBalancerExecute(ctx context.Context, projectId string, name string) (*LoadBalancer, error)
	/*
		GetQuota Get the quota of application load balancers and target pools in a project.
		Deprecated: Retrieves the configured Application Load Balancer quota for the project.
		 The default quota is 3.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiGetQuotaRequest
	*/
	GetQuota(ctx context.Context, projectId string) ApiGetQuotaRequest
	/*
		GetQuotaExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return GetQuotaResponse

		Deprecated: Retrieves the configured Application Load Balancer quota for the project.
		 The default quota is 3.
	*/
	GetQuotaExecute(ctx context.Context, projectId string) (*GetQuotaResponse, error)
	/*
		GetServiceStatus Return the status of application load balancer functionality for the project specified.
		Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.
		 Status will return the Application Load Balancer functionality status for the specified project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiGetServiceStatusRequest
	*/
	GetServiceStatus(ctx context.Context, projectId string) ApiGetServiceStatusRequest
	/*
		GetServiceStatusExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return GetServiceStatusResponse

		Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.
		 Status will return the Application Load Balancer functionality status for the specified project.
	*/
	GetServiceStatusExecute(ctx context.Context, projectId string) (*GetServiceStatusResponse, error)
	/*
		ListCredentials List all credentials in a project.
		Deprecated: Lists the stored Observability credentials.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiListCredentialsRequest
	*/
	ListCredentials(ctx context.Context, projectId string) ApiListCredentialsRequest
	/*
		ListCredentialsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ListCredentialsResponse

		Deprecated: Lists the stored Observability credentials.
	*/
	ListCredentialsExecute(ctx context.Context, projectId string) (*ListCredentialsResponse, error)
	/*
		ListLoadBalancers List load balancers in a project.
		Deprecated: Lists all Application Load Balancers in a project.
		 Includes details from creation or updates, along with their status and any error descriptions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ApiListLoadBalancersRequest
	*/
	ListLoadBalancers(ctx context.Context, projectId string) ApiListLoadBalancersRequest
	/*
		ListLoadBalancersExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@return ListLoadBalancersResponse

		Deprecated: Lists all Application Load Balancers in a project.
		 Includes details from creation or updates, along with their status and any error descriptions.
	*/
	ListLoadBalancersExecute(ctx context.Context, projectId string) (*ListLoadBalancersResponse, error)
	/*
		ListPlans List available service plans.
		Deprecated: Lists the configured service plans for a project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListPlansRequest
	*/
	ListPlans(ctx context.Context) ApiListPlansRequest
	/*
		ListPlansExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ListPlansResponse

		Deprecated: Lists the configured service plans for a project.
	*/
	ListPlansExecute(ctx context.Context) (*ListPlansResponse, error)
	/*
		UpdateCredentials Update credentials for observability in a project.
		Deprecated: Updates the stored Observability credentials.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param credentialsRef
		@return ApiUpdateCredentialsRequest
	*/
	UpdateCredentials(ctx context.Context, projectId string, credentialsRef string) ApiUpdateCredentialsRequest
	/*
		UpdateCredentialsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param credentialsRef
		@return UpdateCredentialsResponse

		Deprecated: Updates the stored Observability credentials.
	*/
	UpdateCredentialsExecute(ctx context.Context, projectId string, credentialsRef string) (*UpdateCredentialsResponse, error)
	/*
		UpdateLoadBalancer Update a load balancer in a project.
		Deprecated: Updates an existing Application Load Balancer by modifying its listeners and target pools.
		 Ensure the resource version is current to maintain concurrency safety.
		 The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@return ApiUpdateLoadBalancerRequest
	*/
	UpdateLoadBalancer(ctx context.Context, projectId string, name string) ApiUpdateLoadBalancerRequest
	/*
		UpdateLoadBalancerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@return LoadBalancer

		Deprecated: Updates an existing Application Load Balancer by modifying its listeners and target pools.
		 Ensure the resource version is current to maintain concurrency safety.
		 The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.
	*/
	UpdateLoadBalancerExecute(ctx context.Context, projectId string, name string) (*LoadBalancer, error)
	/*
		UpdateTargetPool Update a single target pool of a load balancer in a project.
		Deprecated: Replaces the content of a specific target pool in the Application Load Balancer (useful for adding or removing target servers).
		 Only updates the specified target pool, leaving others unchanged.
		 Cannot be used to create or rename target pools.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@param targetPoolName
		@return ApiUpdateTargetPoolRequest
	*/
	UpdateTargetPool(ctx context.Context, projectId string, name string, targetPoolName string) ApiUpdateTargetPoolRequest
	/*
		UpdateTargetPoolExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId
		@param name
		@param targetPoolName
		@return TargetPool

		Deprecated: Replaces the content of a specific target pool in the Application Load Balancer (useful for adding or removing target servers).
		 Only updates the specified target pool, leaving others unchanged.
		 Cannot be used to create or rename target pools.
	*/
	UpdateTargetPoolExecute(ctx context.Context, projectId string, name string, targetPoolName string) (*TargetPool, error)
}

type ApiCreateCredentialsRequest interface {
	CreateCredentialsPayload(createCredentialsPayload CreateCredentialsPayload) ApiCreateCredentialsRequest
	XRequestID(xRequestID string) ApiCreateCredentialsRequest
	Execute() (*CreateCredentialsResponse, error)
}

type ApiCreateLoadBalancerRequest interface {
	CreateLoadBalancerPayload(createLoadBalancerPayload CreateLoadBalancerPayload) ApiCreateLoadBalancerRequest
	XRequestID(xRequestID string) ApiCreateLoadBalancerRequest
	Execute() (*LoadBalancer, error)
}

type ApiDeleteCredentialsRequest interface {
	Execute() (map[string]interface{}, error)
}

type ApiDeleteLoadBalancerRequest interface {
	Execute() (map[string]interface{}, error)
}

type ApiDisableServiceRequest interface {
	Execute() (map[string]interface{}, error)
}

type ApiEnableServiceRequest interface {
	XRequestID(xRequestID string) ApiEnableServiceRequest
	Execute() (map[string]interface{}, error)
}

type ApiGetCredentialsRequest interface {
	Execute() (*GetCredentialsResponse, error)
}

type ApiGetLoadBalancerRequest interface {
	Execute() (*LoadBalancer, error)
}

type ApiGetQuotaRequest interface {
	Execute() (*GetQuotaResponse, error)
}

type ApiGetServiceStatusRequest interface {
	Execute() (*GetServiceStatusResponse, error)
}

type ApiListCredentialsRequest interface {
	Execute() (*ListCredentialsResponse, error)
}

type ApiListLoadBalancersRequest interface {
	// page_size specifies how many load balancers should be returned on this page. Must be a positive number &lt;&#x3D; 1000
	PageSize(pageSize string) ApiListLoadBalancersRequest
	// page_id is a page identifier returned by the previous response and is used to request the next page
	PageId(pageId string) ApiListLoadBalancersRequest
	Execute() (*ListLoadBalancersResponse, error)
}

type ApiListPlansRequest interface {
	Execute() (*ListPlansResponse, error)
}

type ApiUpdateCredentialsRequest interface {
	UpdateCredentialsPayload(updateCredentialsPayload UpdateCredentialsPayload) ApiUpdateCredentialsRequest
	Execute() (*UpdateCredentialsResponse, error)
}

type ApiUpdateLoadBalancerRequest interface {
	UpdateLoadBalancerPayload(updateLoadBalancerPayload UpdateLoadBalancerPayload) ApiUpdateLoadBalancerRequest
	Execute() (*LoadBalancer, error)
}

type ApiUpdateTargetPoolRequest interface {
	UpdateTargetPoolPayload(updateTargetPoolPayload UpdateTargetPoolPayload) ApiUpdateTargetPoolRequest
	Execute() (*TargetPool, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateCredentialsRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	createCredentialsPayload *CreateCredentialsPayload
	xRequestID               *string
}

func (r CreateCredentialsRequest) CreateCredentialsPayload(createCredentialsPayload CreateCredentialsPayload) ApiCreateCredentialsRequest {
	r.createCredentialsPayload = &createCredentialsPayload
	return r
}

func (r CreateCredentialsRequest) XRequestID(xRequestID string) ApiCreateCredentialsRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r CreateCredentialsRequest) Execute() (*CreateCredentialsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateCredentialsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateCredentials")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCredentialsPayload == nil {
		return localVarReturnValue, fmt.Errorf("createCredentialsPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Request-ID", r.xRequestID, "")
	}
	// body params
	localVarPostBody = r.createCredentialsPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateCredentials: Create credentials for observability of the application load balancer

Deprecated: Creates and stores credentials for use with Application Load Balancer Observability.

	For example, when using ARGUS, credentials must first be created via the ARGUS API
	and then stored with this endpoint to be used by the Application Load Balancer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiCreateCredentialsRequest
*/
func (a *APIClient) CreateCredentials(ctx context.Context, projectId string) ApiCreateCredentialsRequest {
	return CreateCredentialsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: Creates and stores credentials for use with Application Load Balancer Observability.

	For example, when using ARGUS, credentials must first be created via the ARGUS API
	and then stored with this endpoint to be used by the Application Load Balancer.
*/
func (a *APIClient) CreateCredentialsExecute(ctx context.Context, projectId string) (*CreateCredentialsResponse, error) {
	r := CreateCredentialsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type CreateLoadBalancerRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	createLoadBalancerPayload *CreateLoadBalancerPayload
	xRequestID                *string
}

func (r CreateLoadBalancerRequest) CreateLoadBalancerPayload(createLoadBalancerPayload CreateLoadBalancerPayload) ApiCreateLoadBalancerRequest {
	r.createLoadBalancerPayload = &createLoadBalancerPayload
	return r
}

func (r CreateLoadBalancerRequest) XRequestID(xRequestID string) ApiCreateLoadBalancerRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r CreateLoadBalancerRequest) Execute() (*LoadBalancer, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadBalancer
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateLoadBalancer")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/load-balancers"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLoadBalancerPayload == nil {
		return localVarReturnValue, fmt.Errorf("createLoadBalancerPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Request-ID", r.xRequestID, "")
	}
	// body params
	localVarPostBody = r.createLoadBalancerPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateLoadBalancer: Create an application load balancer in a project

Deprecated: Creates an Application Load Balancer.

	The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiCreateLoadBalancerRequest
*/
func (a *APIClient) CreateLoadBalancer(ctx context.Context, projectId string) ApiCreateLoadBalancerRequest {
	return CreateLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: Creates an Application Load Balancer.

	The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.
*/
func (a *APIClient) CreateLoadBalancerExecute(ctx context.Context, projectId string) (*LoadBalancer, error) {
	r := CreateLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type DeleteCredentialsRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	credentialsRef string
}

func (r DeleteCredentialsRequest) Execute() (map[string]interface{}, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCredentials")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/credentials/{credentialsRef}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialsRef"+"}", url.PathEscape(ParameterValueToString(r.credentialsRef, "credentialsRef")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteCredentials: Delete a single credential in a project.

Deprecated: Deletes the stored Observability credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param credentialsRef
	@return ApiDeleteCredentialsRequest
*/
func (a *APIClient) DeleteCredentials(ctx context.Context, projectId string, credentialsRef string) ApiDeleteCredentialsRequest {
	return DeleteCredentialsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		credentialsRef: credentialsRef,
	}
}

/*
Deprecated: Deletes the stored Observability credentials.
*/
func (a *APIClient) DeleteCredentialsExecute(ctx context.Context, projectId string, credentialsRef string) (map[string]interface{}, error) {
	r := DeleteCredentialsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		credentialsRef: credentialsRef,
	}
	return r.Execute()
}

type DeleteLoadBalancerRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	name       string
}

func (r DeleteLoadBalancerRequest) Execute() (map[string]interface{}, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteLoadBalancer")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/load-balancers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(ParameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteLoadBalancer: Delete a given load balancer in a project.

Deprecated: Deletes the specified Application Load Balancer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param name
	@return ApiDeleteLoadBalancerRequest
*/
func (a *APIClient) DeleteLoadBalancer(ctx context.Context, projectId string, name string) ApiDeleteLoadBalancerRequest {
	return DeleteLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		name:       name,
	}
}

/*
Deprecated: Deletes the specified Application Load Balancer.
*/
func (a *APIClient) DeleteLoadBalancerExecute(ctx context.Context, projectId string, name string) (map[string]interface{}, error) {
	r := DeleteLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		name:       name,
	}
	return r.Execute()
}

type DisableServiceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r DisableServiceRequest) Execute() (map[string]interface{}, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DisableService")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DisableService: Disables the functionality of load balancers for the project specified.

Deprecated: DEPRECATED! Disabling the Application Load Balancer functionality is now automatic.

	This endpoint is kept for compatibility.
	Disables the Application Load Balancer functionality for the specified project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiDisableServiceRequest
*/
func (a *APIClient) DisableService(ctx context.Context, projectId string) ApiDisableServiceRequest {
	return DisableServiceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: DEPRECATED! Disabling the Application Load Balancer functionality is now automatic.

	This endpoint is kept for compatibility.
	Disables the Application Load Balancer functionality for the specified project.
*/
func (a *APIClient) DisableServiceExecute(ctx context.Context, projectId string) (map[string]interface{}, error) {
	r := DisableServiceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type EnableServiceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	xRequestID *string
}

func (r EnableServiceRequest) XRequestID(xRequestID string) ApiEnableServiceRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r EnableServiceRequest) Execute() (map[string]interface{}, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EnableService")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Request-ID", r.xRequestID, "")
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
EnableService: Enables the functionality of application load balancers for the project specified.

Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.

	Enables the Application Load Balancer service for the specified project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiEnableServiceRequest
*/
func (a *APIClient) EnableService(ctx context.Context, projectId string) ApiEnableServiceRequest {
	return EnableServiceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.

	Enables the Application Load Balancer service for the specified project.
*/
func (a *APIClient) EnableServiceExecute(ctx context.Context, projectId string) (map[string]interface{}, error) {
	r := EnableServiceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type GetCredentialsRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	credentialsRef string
}

func (r GetCredentialsRequest) Execute() (*GetCredentialsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCredentialsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCredentials")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/credentials/{credentialsRef}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialsRef"+"}", url.PathEscape(ParameterValueToString(r.credentialsRef, "credentialsRef")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetCredentials: Get a single credential reference in a project.

Deprecated: Gets the stored Observability credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param credentialsRef
	@return ApiGetCredentialsRequest
*/
func (a *APIClient) GetCredentials(ctx context.Context, projectId string, credentialsRef string) ApiGetCredentialsRequest {
	return GetCredentialsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		credentialsRef: credentialsRef,
	}
}

/*
Deprecated: Gets the stored Observability credentials.
*/
func (a *APIClient) GetCredentialsExecute(ctx context.Context, projectId string, credentialsRef string) (*GetCredentialsResponse, error) {
	r := GetCredentialsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		credentialsRef: credentialsRef,
	}
	return r.Execute()
}

type GetLoadBalancerRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	name       string
}

func (r GetLoadBalancerRequest) Execute() (*LoadBalancer, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadBalancer
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLoadBalancer")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/load-balancers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(ParameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetLoadBalancer: Get a single application load balancer in a project.

Deprecated: Retrieves details of a specific Application Load Balancer in a project.

	Includes creation and update information, current status, and any error descriptions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param name
	@return ApiGetLoadBalancerRequest
*/
func (a *APIClient) GetLoadBalancer(ctx context.Context, projectId string, name string) ApiGetLoadBalancerRequest {
	return GetLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		name:       name,
	}
}

/*
Deprecated: Retrieves details of a specific Application Load Balancer in a project.

	Includes creation and update information, current status, and any error descriptions.
*/
func (a *APIClient) GetLoadBalancerExecute(ctx context.Context, projectId string, name string) (*LoadBalancer, error) {
	r := GetLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		name:       name,
	}
	return r.Execute()
}

type GetQuotaRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r GetQuotaRequest) Execute() (*GetQuotaResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQuotaResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetQuota")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/quota"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetQuota: Get the quota of application load balancers and target pools in a project.

Deprecated: Retrieves the configured Application Load Balancer quota for the project.

	The default quota is 3.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiGetQuotaRequest
*/
func (a *APIClient) GetQuota(ctx context.Context, projectId string) ApiGetQuotaRequest {
	return GetQuotaRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: Retrieves the configured Application Load Balancer quota for the project.

	The default quota is 3.
*/
func (a *APIClient) GetQuotaExecute(ctx context.Context, projectId string) (*GetQuotaResponse, error) {
	r := GetQuotaRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type GetServiceStatusRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r GetServiceStatusRequest) Execute() (*GetServiceStatusResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetServiceStatusResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetServiceStatus")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetServiceStatus: Return the status of application load balancer functionality for the project specified.

Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.

	Status will return the Application Load Balancer functionality status for the specified project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiGetServiceStatusRequest
*/
func (a *APIClient) GetServiceStatus(ctx context.Context, projectId string) ApiGetServiceStatusRequest {
	return GetServiceStatusRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: DEPRECATED! Checking the status is now obsolete. The endpoint is kept for compatibility.

	Status will return the Application Load Balancer functionality status for the specified project.
*/
func (a *APIClient) GetServiceStatusExecute(ctx context.Context, projectId string) (*GetServiceStatusResponse, error) {
	r := GetServiceStatusRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ListCredentialsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r ListCredentialsRequest) Execute() (*ListCredentialsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCredentialsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCredentials")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListCredentials: List all credentials in a project.

Deprecated: Lists the stored Observability credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiListCredentialsRequest
*/
func (a *APIClient) ListCredentials(ctx context.Context, projectId string) ApiListCredentialsRequest {
	return ListCredentialsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: Lists the stored Observability credentials.
*/
func (a *APIClient) ListCredentialsExecute(ctx context.Context, projectId string) (*ListCredentialsResponse, error) {
	r := ListCredentialsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ListLoadBalancersRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	pageSize   *string
	pageId     *string
}

// page_size specifies how many load balancers should be returned on this page. Must be a positive number &lt;&#x3D; 1000

func (r ListLoadBalancersRequest) PageSize(pageSize string) ApiListLoadBalancersRequest {
	r.pageSize = &pageSize
	return r
}

// page_id is a page identifier returned by the previous response and is used to request the next page

func (r ListLoadBalancersRequest) PageId(pageId string) ApiListLoadBalancersRequest {
	r.pageId = &pageId
	return r
}

func (r ListLoadBalancersRequest) Execute() (*ListLoadBalancersResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListLoadBalancersResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListLoadBalancers")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/load-balancers"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.pageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageId", r.pageId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListLoadBalancers: List load balancers in a project.

Deprecated: Lists all Application Load Balancers in a project.

	Includes details from creation or updates, along with their status and any error descriptions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiListLoadBalancersRequest
*/
func (a *APIClient) ListLoadBalancers(ctx context.Context, projectId string) ApiListLoadBalancersRequest {
	return ListLoadBalancersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

/*
Deprecated: Lists all Application Load Balancers in a project.

	Includes details from creation or updates, along with their status and any error descriptions.
*/
func (a *APIClient) ListLoadBalancersExecute(ctx context.Context, projectId string) (*ListLoadBalancersResponse, error) {
	r := ListLoadBalancersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ListPlansRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
}

func (r ListPlansRequest) Execute() (*ListPlansResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPlansResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListPlans")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListPlans: List available service plans.

Deprecated: Lists the configured service plans for a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPlansRequest
*/
func (a *APIClient) ListPlans(ctx context.Context) ApiListPlansRequest {
	return ListPlansRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

/*
Deprecated: Lists the configured service plans for a project.
*/
func (a *APIClient) ListPlansExecute(ctx context.Context) (*ListPlansResponse, error) {
	r := ListPlansRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type UpdateCredentialsRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	credentialsRef           string
	updateCredentialsPayload *UpdateCredentialsPayload
}

func (r UpdateCredentialsRequest) UpdateCredentialsPayload(updateCredentialsPayload UpdateCredentialsPayload) ApiUpdateCredentialsRequest {
	r.updateCredentialsPayload = &updateCredentialsPayload
	return r
}

func (r UpdateCredentialsRequest) Execute() (*UpdateCredentialsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateCredentialsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCredentials")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/credentials/{credentialsRef}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialsRef"+"}", url.PathEscape(ParameterValueToString(r.credentialsRef, "credentialsRef")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCredentialsPayload == nil {
		return localVarReturnValue, fmt.Errorf("updateCredentialsPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCredentialsPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateCredentials: Update credentials for observability in a project.

Deprecated: Updates the stored Observability credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param credentialsRef
	@return ApiUpdateCredentialsRequest
*/
func (a *APIClient) UpdateCredentials(ctx context.Context, projectId string, credentialsRef string) ApiUpdateCredentialsRequest {
	return UpdateCredentialsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		credentialsRef: credentialsRef,
	}
}

/*
Deprecated: Updates the stored Observability credentials.
*/
func (a *APIClient) UpdateCredentialsExecute(ctx context.Context, projectId string, credentialsRef string) (*UpdateCredentialsResponse, error) {
	r := UpdateCredentialsRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		credentialsRef: credentialsRef,
	}
	return r.Execute()
}

type UpdateLoadBalancerRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	name                      string
	updateLoadBalancerPayload *UpdateLoadBalancerPayload
}

func (r UpdateLoadBalancerRequest) UpdateLoadBalancerPayload(updateLoadBalancerPayload UpdateLoadBalancerPayload) ApiUpdateLoadBalancerRequest {
	r.updateLoadBalancerPayload = &updateLoadBalancerPayload
	return r
}

func (r UpdateLoadBalancerRequest) Execute() (*LoadBalancer, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadBalancer
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateLoadBalancer")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/load-balancers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(ParameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLoadBalancerPayload == nil {
		return localVarReturnValue, fmt.Errorf("updateLoadBalancerPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLoadBalancerPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateLoadBalancer: Update a load balancer in a project.

Deprecated: Updates an existing Application Load Balancer by modifying its listeners and target pools.

	Ensure the resource version is current to maintain concurrency safety.
	The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param name
	@return ApiUpdateLoadBalancerRequest
*/
func (a *APIClient) UpdateLoadBalancer(ctx context.Context, projectId string, name string) ApiUpdateLoadBalancerRequest {
	return UpdateLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		name:       name,
	}
}

/*
Deprecated: Updates an existing Application Load Balancer by modifying its listeners and target pools.

	Ensure the resource version is current to maintain concurrency safety.
	The default load balancing algorithm is Maglev, and selecting a different algorithm is currently not supported.
*/
func (a *APIClient) UpdateLoadBalancerExecute(ctx context.Context, projectId string, name string) (*LoadBalancer, error) {
	r := UpdateLoadBalancerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		name:       name,
	}
	return r.Execute()
}

type UpdateTargetPoolRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	name                    string
	targetPoolName          string
	updateTargetPoolPayload *UpdateTargetPoolPayload
}

func (r UpdateTargetPoolRequest) UpdateTargetPoolPayload(updateTargetPoolPayload UpdateTargetPoolPayload) ApiUpdateTargetPoolRequest {
	r.updateTargetPoolPayload = &updateTargetPoolPayload
	return r
}

func (r UpdateTargetPoolRequest) Execute() (*TargetPool, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetPool
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTargetPool")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/load-balancers/{name}/target-pools/{targetPoolName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(ParameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetPoolName"+"}", url.PathEscape(ParameterValueToString(r.targetPoolName, "targetPoolName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTargetPoolPayload == nil {
		return localVarReturnValue, fmt.Errorf("updateTargetPoolPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateTargetPoolPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Status
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		var v Status
		err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.ErrorMessage = err.Error()
			return localVarReturnValue, newErr
		}
		newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.Model = v
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateTargetPool: Update a single target pool of a load balancer in a project.

Deprecated: Replaces the content of a specific target pool in the Application Load Balancer (useful for adding or removing target servers).

	Only updates the specified target pool, leaving others unchanged.
	Cannot be used to create or rename target pools.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@param name
	@param targetPoolName
	@return ApiUpdateTargetPoolRequest
*/
func (a *APIClient) UpdateTargetPool(ctx context.Context, projectId string, name string, targetPoolName string) ApiUpdateTargetPoolRequest {
	return UpdateTargetPoolRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		name:           name,
		targetPoolName: targetPoolName,
	}
}

/*
Deprecated: Replaces the content of a specific target pool in the Application Load Balancer (useful for adding or removing target servers).

	Only updates the specified target pool, leaving others unchanged.
	Cannot be used to create or rename target pools.
*/
func (a *APIClient) UpdateTargetPoolExecute(ctx context.Context, projectId string, name string, targetPoolName string) (*TargetPool, error) {
	r := UpdateTargetPoolRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		name:           name,
		targetPoolName: targetPoolName,
	}
	return r.Execute()
}
