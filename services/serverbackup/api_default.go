/*
STACKIT Server Backup Management API

API endpoints for Server Backup Operations on STACKIT Servers.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package serverbackup

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateBackup create backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiCreateBackupRequest
	*/
	CreateBackup(ctx context.Context, projectId string, serverId string, region string) ApiCreateBackupRequest
	/*
		CreateBackupExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return BackupJob

	*/
	CreateBackupExecute(ctx context.Context, projectId string, serverId string, region string) (*BackupJob, error)
	/*
		CreateBackupSchedule create backup schedule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiCreateBackupScheduleRequest
	*/
	CreateBackupSchedule(ctx context.Context, projectId string, serverId string, region string) ApiCreateBackupScheduleRequest
	/*
		CreateBackupScheduleExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return BackupSchedule

	*/
	CreateBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string) (*BackupSchedule, error)
	/*
		DeleteBackup delete backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupId id of the backup
		@return ApiDeleteBackupRequest
	*/
	DeleteBackup(ctx context.Context, projectId string, serverId string, region string, backupId string) ApiDeleteBackupRequest
	/*
		DeleteBackupExecute executes the request

	*/
	DeleteBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string) error
	/*
		DeleteBackupSchedule delete backup schedule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupScheduleId backup schedule id
		@return ApiDeleteBackupScheduleRequest
	*/
	DeleteBackupSchedule(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) ApiDeleteBackupScheduleRequest
	/*
		DeleteBackupScheduleExecute executes the request

	*/
	DeleteBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) error
	/*
		DeleteVolumeBackup delete volume backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupId id of the backup
		@param volumeBackupId id of the volume backup
		@return ApiDeleteVolumeBackupRequest
	*/
	DeleteVolumeBackup(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) ApiDeleteVolumeBackupRequest
	/*
		DeleteVolumeBackupExecute executes the request

	*/
	DeleteVolumeBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) error
	/*
		DisableServiceResource disable backup service

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiDisableServiceResourceRequest
	*/
	DisableServiceResource(ctx context.Context, projectId string, serverId string, region string) ApiDisableServiceResourceRequest
	/*
		DisableServiceResourceExecute executes the request

	*/
	DisableServiceResourceExecute(ctx context.Context, projectId string, serverId string, region string) error
	/*
		EnableServiceResource enable backup service

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiEnableServiceResourceRequest
	*/
	EnableServiceResource(ctx context.Context, projectId string, serverId string, region string) ApiEnableServiceResourceRequest
	/*
		EnableServiceResourceExecute executes the request

	*/
	EnableServiceResourceExecute(ctx context.Context, projectId string, serverId string, region string) error
	/*
		GetBackup get backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupId id of the backup
		@return ApiGetBackupRequest
	*/
	GetBackup(ctx context.Context, projectId string, serverId string, region string, backupId string) ApiGetBackupRequest
	/*
		GetBackupExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupId id of the backup
		@return Backup

	*/
	GetBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string) (*Backup, error)
	/*
		GetBackupSchedule get single backup schedule details

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupScheduleId backup schedule id
		@return ApiGetBackupScheduleRequest
	*/
	GetBackupSchedule(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) ApiGetBackupScheduleRequest
	/*
		GetBackupScheduleExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupScheduleId backup schedule id
		@return BackupSchedule

	*/
	GetBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) (*BackupSchedule, error)
	/*
		GetServiceResource get backup service details

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiGetServiceResourceRequest
	*/
	GetServiceResource(ctx context.Context, projectId string, serverId string, region string) ApiGetServiceResourceRequest
	/*
		GetServiceResourceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return GetBackupServiceResponse

	*/
	GetServiceResourceExecute(ctx context.Context, projectId string, serverId string, region string) (*GetBackupServiceResponse, error)
	/*
		ListBackupPolicies get list of backup policies

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return ApiListBackupPoliciesRequest
	*/
	ListBackupPolicies(ctx context.Context, projectId string) ApiListBackupPoliciesRequest
	/*
		ListBackupPoliciesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return GetBackupPoliciesResponse

	*/
	ListBackupPoliciesExecute(ctx context.Context, projectId string) (*GetBackupPoliciesResponse, error)
	/*
		ListBackupSchedules get list of backup schedules

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiListBackupSchedulesRequest
	*/
	ListBackupSchedules(ctx context.Context, projectId string, serverId string, region string) ApiListBackupSchedulesRequest
	/*
		ListBackupSchedulesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return GetBackupSchedulesResponse

	*/
	ListBackupSchedulesExecute(ctx context.Context, projectId string, serverId string, region string) (*GetBackupSchedulesResponse, error)
	/*
		ListBackups get list of backups

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return ApiListBackupsRequest
	*/
	ListBackups(ctx context.Context, projectId string, serverId string, region string) ApiListBackupsRequest
	/*
		ListBackupsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@return GetBackupsListResponse

	*/
	ListBackupsExecute(ctx context.Context, projectId string, serverId string, region string) (*GetBackupsListResponse, error)
	/*
		RestoreBackup trigger restore of the requested backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupId id of the backup
		@return ApiRestoreBackupRequest
	*/
	RestoreBackup(ctx context.Context, projectId string, serverId string, region string, backupId string) ApiRestoreBackupRequest
	/*
		RestoreBackupExecute executes the request

	*/
	RestoreBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string) error
	/*
		RestoreVolumeBackup trigger restore of the requested volume backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupId id of the backup
		@param volumeBackupId id of the volume backup
		@return ApiRestoreVolumeBackupRequest
	*/
	RestoreVolumeBackup(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) ApiRestoreVolumeBackupRequest
	/*
		RestoreVolumeBackupExecute executes the request

	*/
	RestoreVolumeBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) error
	/*
		UpdateBackupSchedule update backup schedule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupScheduleId backup schedule id
		@return ApiUpdateBackupScheduleRequest
	*/
	UpdateBackupSchedule(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) ApiUpdateBackupScheduleRequest
	/*
		UpdateBackupScheduleExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param serverId server id
		@param region region
		@param backupScheduleId backup schedule id
		@return BackupSchedule

	*/
	UpdateBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) (*BackupSchedule, error)
}

type ApiCreateBackupRequest interface {
	CreateBackupPayload(createBackupPayload CreateBackupPayload) ApiCreateBackupRequest
	Execute() (*BackupJob, error)
}

type ApiCreateBackupScheduleRequest interface {
	CreateBackupSchedulePayload(createBackupSchedulePayload CreateBackupSchedulePayload) ApiCreateBackupScheduleRequest
	Execute() (*BackupSchedule, error)
}

type ApiDeleteBackupRequest interface {
	Execute() error
}

type ApiDeleteBackupScheduleRequest interface {
	Execute() error
}

type ApiDeleteVolumeBackupRequest interface {
	Execute() error
}

type ApiDisableServiceResourceRequest interface {
	Execute() error
}

type ApiEnableServiceResourceRequest interface {
	EnableServiceResourcePayload(enableServiceResourcePayload EnableServiceResourcePayload) ApiEnableServiceResourceRequest
	Execute() error
}

type ApiGetBackupRequest interface {
	Execute() (*Backup, error)
}

type ApiGetBackupScheduleRequest interface {
	Execute() (*BackupSchedule, error)
}

type ApiGetServiceResourceRequest interface {
	Execute() (*GetBackupServiceResponse, error)
}

type ApiListBackupPoliciesRequest interface {
	Execute() (*GetBackupPoliciesResponse, error)
}

type ApiListBackupSchedulesRequest interface {
	Execute() (*GetBackupSchedulesResponse, error)
}

type ApiListBackupsRequest interface {
	Execute() (*GetBackupsListResponse, error)
}

type ApiRestoreBackupRequest interface {
	RestoreBackupPayload(restoreBackupPayload RestoreBackupPayload) ApiRestoreBackupRequest
	Execute() error
}

type ApiRestoreVolumeBackupRequest interface {
	RestoreVolumeBackupPayload(restoreVolumeBackupPayload RestoreVolumeBackupPayload) ApiRestoreVolumeBackupRequest
	Execute() error
}

type ApiUpdateBackupScheduleRequest interface {
	UpdateBackupSchedulePayload(updateBackupSchedulePayload UpdateBackupSchedulePayload) ApiUpdateBackupScheduleRequest
	Execute() (*BackupSchedule, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateBackupRequest struct {
	ctx                 context.Context
	apiService          *DefaultApiService
	projectId           string
	serverId            string
	region              string
	createBackupPayload *CreateBackupPayload
}

func (r CreateBackupRequest) CreateBackupPayload(createBackupPayload CreateBackupPayload) ApiCreateBackupRequest {
	r.createBackupPayload = &createBackupPayload
	return r
}

func (r CreateBackupRequest) Execute() (*BackupJob, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupJob
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateBackup")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBackupPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateBackup: create backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiCreateBackupRequest
*/
func (a *APIClient) CreateBackup(ctx context.Context, projectId string, serverId string, region string) ApiCreateBackupRequest {
	return CreateBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) CreateBackupExecute(ctx context.Context, projectId string, serverId string, region string) (*BackupJob, error) {
	r := CreateBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type CreateBackupScheduleRequest struct {
	ctx                         context.Context
	apiService                  *DefaultApiService
	projectId                   string
	serverId                    string
	region                      string
	createBackupSchedulePayload *CreateBackupSchedulePayload
}

func (r CreateBackupScheduleRequest) CreateBackupSchedulePayload(createBackupSchedulePayload CreateBackupSchedulePayload) ApiCreateBackupScheduleRequest {
	r.createBackupSchedulePayload = &createBackupSchedulePayload
	return r
}

func (r CreateBackupScheduleRequest) Execute() (*BackupSchedule, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupSchedule
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateBackupSchedule")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backup-schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBackupSchedulePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateBackupSchedule: create backup schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiCreateBackupScheduleRequest
*/
func (a *APIClient) CreateBackupSchedule(ctx context.Context, projectId string, serverId string, region string) ApiCreateBackupScheduleRequest {
	return CreateBackupScheduleRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) CreateBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string) (*BackupSchedule, error) {
	r := CreateBackupScheduleRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type DeleteBackupRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	serverId   string
	region     string
	backupId   string
}

func (r DeleteBackupRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteBackup")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(ParameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteBackup: delete backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupId id of the backup
	@return ApiDeleteBackupRequest
*/
func (a *APIClient) DeleteBackup(ctx context.Context, projectId string, serverId string, region string, backupId string) ApiDeleteBackupRequest {
	return DeleteBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
		backupId:   backupId,
	}
}

func (a *APIClient) DeleteBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string) error {
	r := DeleteBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
		backupId:   backupId,
	}
	return r.Execute()
}

type DeleteBackupScheduleRequest struct {
	ctx              context.Context
	apiService       *DefaultApiService
	projectId        string
	serverId         string
	region           string
	backupScheduleId string
}

func (r DeleteBackupScheduleRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteBackupSchedule")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backup-schedules/{backupScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupScheduleId"+"}", url.PathEscape(ParameterValueToString(r.backupScheduleId, "backupScheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteBackupSchedule: delete backup schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupScheduleId backup schedule id
	@return ApiDeleteBackupScheduleRequest
*/
func (a *APIClient) DeleteBackupSchedule(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) ApiDeleteBackupScheduleRequest {
	return DeleteBackupScheduleRequest{
		apiService:       a.defaultApi,
		ctx:              ctx,
		projectId:        projectId,
		serverId:         serverId,
		region:           region,
		backupScheduleId: backupScheduleId,
	}
}

func (a *APIClient) DeleteBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) error {
	r := DeleteBackupScheduleRequest{
		apiService:       a.defaultApi,
		ctx:              ctx,
		projectId:        projectId,
		serverId:         serverId,
		region:           region,
		backupScheduleId: backupScheduleId,
	}
	return r.Execute()
}

type DeleteVolumeBackupRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	serverId       string
	region         string
	backupId       string
	volumeBackupId string
}

func (r DeleteVolumeBackupRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteVolumeBackup")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups/{backupId}/volume-backups/{volumeBackupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(ParameterValueToString(r.backupId, "backupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"volumeBackupId"+"}", url.PathEscape(ParameterValueToString(r.volumeBackupId, "volumeBackupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteVolumeBackup: delete volume backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupId id of the backup
	@param volumeBackupId id of the volume backup
	@return ApiDeleteVolumeBackupRequest
*/
func (a *APIClient) DeleteVolumeBackup(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) ApiDeleteVolumeBackupRequest {
	return DeleteVolumeBackupRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		serverId:       serverId,
		region:         region,
		backupId:       backupId,
		volumeBackupId: volumeBackupId,
	}
}

func (a *APIClient) DeleteVolumeBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) error {
	r := DeleteVolumeBackupRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		serverId:       serverId,
		region:         region,
		backupId:       backupId,
		volumeBackupId: volumeBackupId,
	}
	return r.Execute()
}

type DisableServiceResourceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	serverId   string
	region     string
}

func (r DisableServiceResourceRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DisableServiceResource")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DisableServiceResource: disable backup service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiDisableServiceResourceRequest
*/
func (a *APIClient) DisableServiceResource(ctx context.Context, projectId string, serverId string, region string) ApiDisableServiceResourceRequest {
	return DisableServiceResourceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) DisableServiceResourceExecute(ctx context.Context, projectId string, serverId string, region string) error {
	r := DisableServiceResourceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type EnableServiceResourceRequest struct {
	ctx                          context.Context
	apiService                   *DefaultApiService
	projectId                    string
	serverId                     string
	region                       string
	enableServiceResourcePayload *EnableServiceResourcePayload
}

func (r EnableServiceResourceRequest) EnableServiceResourcePayload(enableServiceResourcePayload EnableServiceResourcePayload) ApiEnableServiceResourceRequest {
	r.enableServiceResourcePayload = &enableServiceResourcePayload
	return r
}

func (r EnableServiceResourceRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EnableServiceResource")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enableServiceResourcePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
EnableServiceResource: enable backup service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiEnableServiceResourceRequest
*/
func (a *APIClient) EnableServiceResource(ctx context.Context, projectId string, serverId string, region string) ApiEnableServiceResourceRequest {
	return EnableServiceResourceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) EnableServiceResourceExecute(ctx context.Context, projectId string, serverId string, region string) error {
	r := EnableServiceResourceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type GetBackupRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	serverId   string
	region     string
	backupId   string
}

func (r GetBackupRequest) Execute() (*Backup, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Backup
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBackup")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(ParameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetBackup: get backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupId id of the backup
	@return ApiGetBackupRequest
*/
func (a *APIClient) GetBackup(ctx context.Context, projectId string, serverId string, region string, backupId string) ApiGetBackupRequest {
	return GetBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
		backupId:   backupId,
	}
}

func (a *APIClient) GetBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string) (*Backup, error) {
	r := GetBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
		backupId:   backupId,
	}
	return r.Execute()
}

type GetBackupScheduleRequest struct {
	ctx              context.Context
	apiService       *DefaultApiService
	projectId        string
	serverId         string
	region           string
	backupScheduleId string
}

func (r GetBackupScheduleRequest) Execute() (*BackupSchedule, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupSchedule
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBackupSchedule")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backup-schedules/{backupScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupScheduleId"+"}", url.PathEscape(ParameterValueToString(r.backupScheduleId, "backupScheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetBackupSchedule: get single backup schedule details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupScheduleId backup schedule id
	@return ApiGetBackupScheduleRequest
*/
func (a *APIClient) GetBackupSchedule(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) ApiGetBackupScheduleRequest {
	return GetBackupScheduleRequest{
		apiService:       a.defaultApi,
		ctx:              ctx,
		projectId:        projectId,
		serverId:         serverId,
		region:           region,
		backupScheduleId: backupScheduleId,
	}
}

func (a *APIClient) GetBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) (*BackupSchedule, error) {
	r := GetBackupScheduleRequest{
		apiService:       a.defaultApi,
		ctx:              ctx,
		projectId:        projectId,
		serverId:         serverId,
		region:           region,
		backupScheduleId: backupScheduleId,
	}
	return r.Execute()
}

type GetServiceResourceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	serverId   string
	region     string
}

func (r GetServiceResourceRequest) Execute() (*GetBackupServiceResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetBackupServiceResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetServiceResource")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetServiceResource: get backup service details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiGetServiceResourceRequest
*/
func (a *APIClient) GetServiceResource(ctx context.Context, projectId string, serverId string, region string) ApiGetServiceResourceRequest {
	return GetServiceResourceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) GetServiceResourceExecute(ctx context.Context, projectId string, serverId string, region string) (*GetBackupServiceResponse, error) {
	r := GetServiceResourceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type ListBackupPoliciesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
}

func (r ListBackupPoliciesRequest) Execute() (*GetBackupPoliciesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetBackupPoliciesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListBackupPolicies")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/backup-policies"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListBackupPolicies: get list of backup policies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiListBackupPoliciesRequest
*/
func (a *APIClient) ListBackupPolicies(ctx context.Context, projectId string) ApiListBackupPoliciesRequest {
	return ListBackupPoliciesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListBackupPoliciesExecute(ctx context.Context, projectId string) (*GetBackupPoliciesResponse, error) {
	r := ListBackupPoliciesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ListBackupSchedulesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	serverId   string
	region     string
}

func (r ListBackupSchedulesRequest) Execute() (*GetBackupSchedulesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetBackupSchedulesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListBackupSchedules")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backup-schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListBackupSchedules: get list of backup schedules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiListBackupSchedulesRequest
*/
func (a *APIClient) ListBackupSchedules(ctx context.Context, projectId string, serverId string, region string) ApiListBackupSchedulesRequest {
	return ListBackupSchedulesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) ListBackupSchedulesExecute(ctx context.Context, projectId string, serverId string, region string) (*GetBackupSchedulesResponse, error) {
	r := ListBackupSchedulesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type ListBackupsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	serverId   string
	region     string
}

func (r ListBackupsRequest) Execute() (*GetBackupsListResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetBackupsListResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListBackups")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListBackups: get list of backups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@return ApiListBackupsRequest
*/
func (a *APIClient) ListBackups(ctx context.Context, projectId string, serverId string, region string) ApiListBackupsRequest {
	return ListBackupsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
}

func (a *APIClient) ListBackupsExecute(ctx context.Context, projectId string, serverId string, region string) (*GetBackupsListResponse, error) {
	r := ListBackupsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
	}
	return r.Execute()
}

type RestoreBackupRequest struct {
	ctx                  context.Context
	apiService           *DefaultApiService
	projectId            string
	serverId             string
	region               string
	backupId             string
	restoreBackupPayload *RestoreBackupPayload
}

func (r RestoreBackupRequest) RestoreBackupPayload(restoreBackupPayload RestoreBackupPayload) ApiRestoreBackupRequest {
	r.restoreBackupPayload = &restoreBackupPayload
	return r
}

func (r RestoreBackupRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreBackup")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups/{backupId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(ParameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreBackupPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
RestoreBackup: trigger restore of the requested backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupId id of the backup
	@return ApiRestoreBackupRequest
*/
func (a *APIClient) RestoreBackup(ctx context.Context, projectId string, serverId string, region string, backupId string) ApiRestoreBackupRequest {
	return RestoreBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
		backupId:   backupId,
	}
}

func (a *APIClient) RestoreBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string) error {
	r := RestoreBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		serverId:   serverId,
		region:     region,
		backupId:   backupId,
	}
	return r.Execute()
}

type RestoreVolumeBackupRequest struct {
	ctx                        context.Context
	apiService                 *DefaultApiService
	projectId                  string
	serverId                   string
	region                     string
	backupId                   string
	volumeBackupId             string
	restoreVolumeBackupPayload *RestoreVolumeBackupPayload
}

func (r RestoreVolumeBackupRequest) RestoreVolumeBackupPayload(restoreVolumeBackupPayload RestoreVolumeBackupPayload) ApiRestoreVolumeBackupRequest {
	r.restoreVolumeBackupPayload = &restoreVolumeBackupPayload
	return r
}

func (r RestoreVolumeBackupRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreVolumeBackup")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backups/{backupId}/volume-backups/{volumeBackupId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(ParameterValueToString(r.backupId, "backupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"volumeBackupId"+"}", url.PathEscape(ParameterValueToString(r.volumeBackupId, "volumeBackupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreVolumeBackupPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
RestoreVolumeBackup: trigger restore of the requested volume backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupId id of the backup
	@param volumeBackupId id of the volume backup
	@return ApiRestoreVolumeBackupRequest
*/
func (a *APIClient) RestoreVolumeBackup(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) ApiRestoreVolumeBackupRequest {
	return RestoreVolumeBackupRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		serverId:       serverId,
		region:         region,
		backupId:       backupId,
		volumeBackupId: volumeBackupId,
	}
}

func (a *APIClient) RestoreVolumeBackupExecute(ctx context.Context, projectId string, serverId string, region string, backupId string, volumeBackupId string) error {
	r := RestoreVolumeBackupRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		serverId:       serverId,
		region:         region,
		backupId:       backupId,
		volumeBackupId: volumeBackupId,
	}
	return r.Execute()
}

type UpdateBackupScheduleRequest struct {
	ctx                         context.Context
	apiService                  *DefaultApiService
	projectId                   string
	serverId                    string
	region                      string
	backupScheduleId            string
	updateBackupSchedulePayload *UpdateBackupSchedulePayload
}

func (r UpdateBackupScheduleRequest) UpdateBackupSchedulePayload(updateBackupSchedulePayload UpdateBackupSchedulePayload) ApiUpdateBackupScheduleRequest {
	r.updateBackupSchedulePayload = &updateBackupSchedulePayload
	return r
}

func (r UpdateBackupScheduleRequest) Execute() (*BackupSchedule, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupSchedule
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return nil, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateBackupSchedule")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/servers/{serverId}/backup-schedules/{backupScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(ParameterValueToString(r.serverId, "serverId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupScheduleId"+"}", url.PathEscape(ParameterValueToString(r.backupScheduleId, "backupScheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBackupSchedulePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateBackupSchedule: update backup schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param serverId server id
	@param region region
	@param backupScheduleId backup schedule id
	@return ApiUpdateBackupScheduleRequest
*/
func (a *APIClient) UpdateBackupSchedule(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) ApiUpdateBackupScheduleRequest {
	return UpdateBackupScheduleRequest{
		apiService:       a.defaultApi,
		ctx:              ctx,
		projectId:        projectId,
		serverId:         serverId,
		region:           region,
		backupScheduleId: backupScheduleId,
	}
}

func (a *APIClient) UpdateBackupScheduleExecute(ctx context.Context, projectId string, serverId string, region string, backupScheduleId string) (*BackupSchedule, error) {
	r := UpdateBackupScheduleRequest{
		apiService:       a.defaultApi,
		ctx:              ctx,
		projectId:        projectId,
		serverId:         serverId,
		region:           region,
		backupScheduleId: backupScheduleId,
	}
	return r.Execute()
}
