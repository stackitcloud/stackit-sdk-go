/*
STACKIT Marketplace API

API to manage STACKIT Marketplace.

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackitmarketplace

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		ApproveSubscription Approve a subscription
		Approve a pending subscription.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@param subscriptionId The subscription ID.
		@return ApiApproveSubscriptionRequest
	*/
	ApproveSubscription(ctx context.Context, projectId string, subscriptionId string) ApiApproveSubscriptionRequest
	/*
		ApproveSubscriptionExecute executes the request

	*/
	ApproveSubscriptionExecute(ctx context.Context, projectId string, subscriptionId string) error
	/*
		GetCatalogProduct Get a product
		Get a product.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param productId The product ID.
		@return ApiGetCatalogProductRequest
	*/
	GetCatalogProduct(ctx context.Context, productId string) ApiGetCatalogProductRequest
	/*
		GetCatalogProductExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param productId The product ID.
		@return CatalogProductDetail

	*/
	GetCatalogProductExecute(ctx context.Context, productId string) (*CatalogProductDetail, error)
	/*
		GetVendorSubscription Get a subscription
		Get a subscription.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@param subscriptionId The subscription ID.
		@return ApiGetVendorSubscriptionRequest
	*/
	GetVendorSubscription(ctx context.Context, projectId string, subscriptionId string) ApiGetVendorSubscriptionRequest
	/*
		GetVendorSubscriptionExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@param subscriptionId The subscription ID.
		@return VendorSubscription

	*/
	GetVendorSubscriptionExecute(ctx context.Context, projectId string, subscriptionId string) (*VendorSubscription, error)
	/*
		InquiriesCreateInquiry Create inquiry
		Create an inquiry to contact sales, become a vendor, or suggest a product. Requests are limited to 10 per 5 minutes.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiInquiriesCreateInquiryRequest
	*/
	InquiriesCreateInquiry(ctx context.Context) ApiInquiriesCreateInquiryRequest
	/*
		InquiriesCreateInquiryExecute executes the request

	*/
	InquiriesCreateInquiryExecute(ctx context.Context) error
	/*
		ListCatalogProducts List all products
		List all products.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListCatalogProductsRequest
	*/
	ListCatalogProducts(ctx context.Context) ApiListCatalogProductsRequest
	/*
		ListCatalogProductsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ListCatalogProductsResponse

	*/
	ListCatalogProductsExecute(ctx context.Context) (*ListCatalogProductsResponse, error)
	/*
		ListVendorSubscriptions List all subscriptions of a project.
		List all subscriptions of a project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@return ApiListVendorSubscriptionsRequest
	*/
	ListVendorSubscriptions(ctx context.Context, projectId string) ApiListVendorSubscriptionsRequest
	/*
		ListVendorSubscriptionsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@return ListVendorSubscriptionsResponse

	*/
	ListVendorSubscriptionsExecute(ctx context.Context, projectId string) (*ListVendorSubscriptionsResponse, error)
	/*
		ResolveCustomer Resolve customer
		Get details about the requested subscription.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@return ApiResolveCustomerRequest
	*/
	ResolveCustomer(ctx context.Context, projectId string) ApiResolveCustomerRequest
	/*
		ResolveCustomerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@return VendorSubscription

	*/
	ResolveCustomerExecute(ctx context.Context, projectId string) (*VendorSubscription, error)
	/*
		VendorsSubscriptionsReject Reject a subscription
		Reject a subscription (in any lifecycle state). Only available for subscriptions to products with lifecycle state `PRODUCT_PREVIEW`.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The project ID.
		@param subscriptionId The subscription ID.
		@return ApiVendorsSubscriptionsRejectRequest
	*/
	VendorsSubscriptionsReject(ctx context.Context, projectId string, subscriptionId string) ApiVendorsSubscriptionsRejectRequest
	/*
		VendorsSubscriptionsRejectExecute executes the request

	*/
	VendorsSubscriptionsRejectExecute(ctx context.Context, projectId string, subscriptionId string) error
}

type ApiApproveSubscriptionRequest interface {
	ApproveSubscriptionPayload(approveSubscriptionPayload ApproveSubscriptionPayload) ApiApproveSubscriptionRequest
	Execute() error
}

type ApiGetCatalogProductRequest interface {
	// The language of the response.
	Locale(locale string) ApiGetCatalogProductRequest
	Execute() (*CatalogProductDetail, error)
}

type ApiGetVendorSubscriptionRequest interface {
	Execute() (*VendorSubscription, error)
}

type ApiInquiriesCreateInquiryRequest interface {
	InquiriesCreateInquiryPayload(inquiriesCreateInquiryPayload InquiriesCreateInquiryPayload) ApiInquiriesCreateInquiryRequest
	Execute() error
}

type ApiListCatalogProductsRequest interface {
	// A pagination cursor that represents a position in the dataset. If given, results will be returned from the item after the cursor. If not given, results will be returned from the beginning.
	Cursor(cursor string) ApiListCatalogProductsRequest
	// The maximum number of items to return in the response. If maximum is exceeded, maximum is used.
	Limit(limit float32) ApiListCatalogProductsRequest
	// The language of the response.
	Locale(locale string) ApiListCatalogProductsRequest
	// Filter the products based on attributes, e.g., &#x60;deliveryMethod eq \&quot;SAAS\&quot;&#x60;. The supported operators are: - &#x60;PR&#x60; (present; &#x60;name pr&#x60;) - &#x60;EQ&#x60; (equal) - &#x60;NE&#x60; (not equal) - &#x60;CO&#x60; (contains; &#x60;text co \&quot;searching\&quot;&#x60;) - &#x60;SW&#x60; (starts with) - &#x60;EW&#x60; (ends with) - &#x60;GT&#x60; (greater than) - &#x60;LT&#x60; (less than) - &#x60;GE&#x60; (greater than or equal) - &#x60;LE&#x60; (less than or equal).   These expressions can be logically linked with &#x60;AND&#x60; and &#x60;OR&#x60;. All attributes (and the special &#x60;text&#x60; attribute) can be used as filters, if the attribute type allows the operator.
	Filter(filter string) ApiListCatalogProductsRequest
	// Sort the products based on attributes and order e.g. &#x60;name:asc&#x60;. Attributes with scalar types (&#x60;createdAt&#x60;, &#x60;isProductListing&#x60;) or keywords (&#x60;name&#x60;, &#x60;deliveryMethod&#x60;, &#x60;lifecycleState&#x60;, &#x60;vendor.name&#x60;) can be used as sort criteria. To set the sort order, append &#x60;asc&#x60; (ascending) or &#x60;desc&#x60; (descending) to the attribute, e.g. &#x60;name:asc&#x60;. To sort by multiple attributes, separate them with a comma. E.g &#x60;name:asc,price:desc&#x60;.
	Sort(sort string) ApiListCatalogProductsRequest
	Execute() (*ListCatalogProductsResponse, error)
}

type ApiListVendorSubscriptionsRequest interface {
	// A pagination cursor that represents a position in the dataset. If given, results will be returned from the item after the cursor. If not given, results will be returned from the beginning.
	Cursor(cursor string) ApiListVendorSubscriptionsRequest
	// The maximum number of items to return in the response. If maximum is exceeded, maximum is used.
	Limit(limit float32) ApiListVendorSubscriptionsRequest
	// The product ID.
	ProductId(productId string) ApiListVendorSubscriptionsRequest
	Execute() (*ListVendorSubscriptionsResponse, error)
}

type ApiResolveCustomerRequest interface {
	ResolveCustomerPayload(resolveCustomerPayload ResolveCustomerPayload) ApiResolveCustomerRequest
	Execute() (*VendorSubscription, error)
}

type ApiVendorsSubscriptionsRejectRequest interface {
	Execute() error
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApproveSubscriptionRequest struct {
	ctx                        context.Context
	apiService                 *DefaultApiService
	projectId                  string
	subscriptionId             string
	approveSubscriptionPayload *ApproveSubscriptionPayload
}

func (r ApproveSubscriptionRequest) ApproveSubscriptionPayload(approveSubscriptionPayload ApproveSubscriptionPayload) ApiApproveSubscriptionRequest {
	r.approveSubscriptionPayload = &approveSubscriptionPayload
	return r
}

func (r ApproveSubscriptionRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApproveSubscription")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vendors/projects/{projectId}/subscriptions/{subscriptionId}/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(ParameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return fmt.Errorf("projectId must have less than 36 elements")
	}
	if strlen(r.subscriptionId) < 36 {
		return fmt.Errorf("subscriptionId must have at least 36 elements")
	}
	if strlen(r.subscriptionId) > 36 {
		return fmt.Errorf("subscriptionId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.approveSubscriptionPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
ApproveSubscription: Approve a subscription

Approve a pending subscription.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The project ID.
	@param subscriptionId The subscription ID.
	@return ApiApproveSubscriptionRequest
*/
func (a *APIClient) ApproveSubscription(ctx context.Context, projectId string, subscriptionId string) ApiApproveSubscriptionRequest {
	return ApproveSubscriptionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		subscriptionId: subscriptionId,
	}
}

func (a *APIClient) ApproveSubscriptionExecute(ctx context.Context, projectId string, subscriptionId string) error {
	r := ApproveSubscriptionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		subscriptionId: subscriptionId,
	}
	return r.Execute()
}

type GetCatalogProductRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	productId  string
	locale     *string
}

// The language of the response.

func (r GetCatalogProductRequest) Locale(locale string) ApiGetCatalogProductRequest {
	r.locale = &locale
	return r
}

func (r GetCatalogProductRequest) Execute() (*CatalogProductDetail, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CatalogProductDetail
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCatalogProduct")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/products/{productId}"
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(ParameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.productId) < 10 {
		return localVarReturnValue, fmt.Errorf("productId must have at least 10 elements")
	}
	if strlen(r.productId) > 29 {
		return localVarReturnValue, fmt.Errorf("productId must have less than 29 elements")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetCatalogProduct: Get a product

Get a product.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param productId The product ID.
	@return ApiGetCatalogProductRequest
*/
func (a *APIClient) GetCatalogProduct(ctx context.Context, productId string) ApiGetCatalogProductRequest {
	return GetCatalogProductRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		productId:  productId,
	}
}

func (a *APIClient) GetCatalogProductExecute(ctx context.Context, productId string) (*CatalogProductDetail, error) {
	r := GetCatalogProductRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		productId:  productId,
	}
	return r.Execute()
}

type GetVendorSubscriptionRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	subscriptionId string
}

func (r GetVendorSubscriptionRequest) Execute() (*VendorSubscription, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VendorSubscription
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVendorSubscription")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vendors/projects/{projectId}/subscriptions/{subscriptionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(ParameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have less than 36 elements")
	}
	if strlen(r.subscriptionId) < 36 {
		return localVarReturnValue, fmt.Errorf("subscriptionId must have at least 36 elements")
	}
	if strlen(r.subscriptionId) > 36 {
		return localVarReturnValue, fmt.Errorf("subscriptionId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetVendorSubscription: Get a subscription

Get a subscription.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The project ID.
	@param subscriptionId The subscription ID.
	@return ApiGetVendorSubscriptionRequest
*/
func (a *APIClient) GetVendorSubscription(ctx context.Context, projectId string, subscriptionId string) ApiGetVendorSubscriptionRequest {
	return GetVendorSubscriptionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		subscriptionId: subscriptionId,
	}
}

func (a *APIClient) GetVendorSubscriptionExecute(ctx context.Context, projectId string, subscriptionId string) (*VendorSubscription, error) {
	r := GetVendorSubscriptionRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		subscriptionId: subscriptionId,
	}
	return r.Execute()
}

type InquiriesCreateInquiryRequest struct {
	ctx                           context.Context
	apiService                    *DefaultApiService
	inquiriesCreateInquiryPayload *InquiriesCreateInquiryPayload
}

func (r InquiriesCreateInquiryRequest) InquiriesCreateInquiryPayload(inquiriesCreateInquiryPayload InquiriesCreateInquiryPayload) ApiInquiriesCreateInquiryRequest {
	r.inquiriesCreateInquiryPayload = &inquiriesCreateInquiryPayload
	return r
}

func (r InquiriesCreateInquiryRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InquiriesCreateInquiry")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inquiries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inquiriesCreateInquiryPayload == nil {
		return fmt.Errorf("inquiriesCreateInquiryPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inquiriesCreateInquiryPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
InquiriesCreateInquiry: Create inquiry

Create an inquiry to contact sales, become a vendor, or suggest a product. Requests are limited to 10 per 5 minutes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInquiriesCreateInquiryRequest
*/
func (a *APIClient) InquiriesCreateInquiry(ctx context.Context) ApiInquiriesCreateInquiryRequest {
	return InquiriesCreateInquiryRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) InquiriesCreateInquiryExecute(ctx context.Context) error {
	r := InquiriesCreateInquiryRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type ListCatalogProductsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	cursor     *string
	limit      *float32
	locale     *string
	filter     *string
	sort       *string
}

// A pagination cursor that represents a position in the dataset. If given, results will be returned from the item after the cursor. If not given, results will be returned from the beginning.

func (r ListCatalogProductsRequest) Cursor(cursor string) ApiListCatalogProductsRequest {
	r.cursor = &cursor
	return r
}

// The maximum number of items to return in the response. If maximum is exceeded, maximum is used.

func (r ListCatalogProductsRequest) Limit(limit float32) ApiListCatalogProductsRequest {
	r.limit = &limit
	return r
}

// The language of the response.

func (r ListCatalogProductsRequest) Locale(locale string) ApiListCatalogProductsRequest {
	r.locale = &locale
	return r
}

// Filter the products based on attributes, e.g., &#x60;deliveryMethod eq \&quot;SAAS\&quot;&#x60;. The supported operators are: - &#x60;PR&#x60; (present; &#x60;name pr&#x60;) - &#x60;EQ&#x60; (equal) - &#x60;NE&#x60; (not equal) - &#x60;CO&#x60; (contains; &#x60;text co \&quot;searching\&quot;&#x60;) - &#x60;SW&#x60; (starts with) - &#x60;EW&#x60; (ends with) - &#x60;GT&#x60; (greater than) - &#x60;LT&#x60; (less than) - &#x60;GE&#x60; (greater than or equal) - &#x60;LE&#x60; (less than or equal).   These expressions can be logically linked with &#x60;AND&#x60; and &#x60;OR&#x60;. All attributes (and the special &#x60;text&#x60; attribute) can be used as filters, if the attribute type allows the operator.

func (r ListCatalogProductsRequest) Filter(filter string) ApiListCatalogProductsRequest {
	r.filter = &filter
	return r
}

// Sort the products based on attributes and order e.g. &#x60;name:asc&#x60;. Attributes with scalar types (&#x60;createdAt&#x60;, &#x60;isProductListing&#x60;) or keywords (&#x60;name&#x60;, &#x60;deliveryMethod&#x60;, &#x60;lifecycleState&#x60;, &#x60;vendor.name&#x60;) can be used as sort criteria. To set the sort order, append &#x60;asc&#x60; (ascending) or &#x60;desc&#x60; (descending) to the attribute, e.g. &#x60;name:asc&#x60;. To sort by multiple attributes, separate them with a comma. E.g &#x60;name:asc,price:desc&#x60;.

func (r ListCatalogProductsRequest) Sort(sort string) ApiListCatalogProductsRequest {
	r.sort = &sort
	return r
}

func (r ListCatalogProductsRequest) Execute() (*ListCatalogProductsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCatalogProductsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCatalogProducts")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListCatalogProducts: List all products

List all products.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCatalogProductsRequest
*/
func (a *APIClient) ListCatalogProducts(ctx context.Context) ApiListCatalogProductsRequest {
	return ListCatalogProductsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) ListCatalogProductsExecute(ctx context.Context) (*ListCatalogProductsResponse, error) {
	r := ListCatalogProductsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type ListVendorSubscriptionsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	cursor     *string
	limit      *float32
	productId  *string
}

// A pagination cursor that represents a position in the dataset. If given, results will be returned from the item after the cursor. If not given, results will be returned from the beginning.

func (r ListVendorSubscriptionsRequest) Cursor(cursor string) ApiListVendorSubscriptionsRequest {
	r.cursor = &cursor
	return r
}

// The maximum number of items to return in the response. If maximum is exceeded, maximum is used.

func (r ListVendorSubscriptionsRequest) Limit(limit float32) ApiListVendorSubscriptionsRequest {
	r.limit = &limit
	return r
}

// The product ID.

func (r ListVendorSubscriptionsRequest) ProductId(productId string) ApiListVendorSubscriptionsRequest {
	r.productId = &productId
	return r
}

func (r ListVendorSubscriptionsRequest) Execute() (*ListVendorSubscriptionsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListVendorSubscriptionsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListVendorSubscriptions")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vendors/projects/{projectId}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have less than 36 elements")
	}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListVendorSubscriptions: List all subscriptions of a project.

List all subscriptions of a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The project ID.
	@return ApiListVendorSubscriptionsRequest
*/
func (a *APIClient) ListVendorSubscriptions(ctx context.Context, projectId string) ApiListVendorSubscriptionsRequest {
	return ListVendorSubscriptionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListVendorSubscriptionsExecute(ctx context.Context, projectId string) (*ListVendorSubscriptionsResponse, error) {
	r := ListVendorSubscriptionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ResolveCustomerRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	resolveCustomerPayload *ResolveCustomerPayload
}

func (r ResolveCustomerRequest) ResolveCustomerPayload(resolveCustomerPayload ResolveCustomerPayload) ApiResolveCustomerRequest {
	r.resolveCustomerPayload = &resolveCustomerPayload
	return r
}

func (r ResolveCustomerRequest) Execute() (*VendorSubscription, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VendorSubscription
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ResolveCustomer")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vendors/projects/{projectId}/resolve-customer"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return localVarReturnValue, fmt.Errorf("projectId must have less than 36 elements")
	}
	if r.resolveCustomerPayload == nil {
		return localVarReturnValue, fmt.Errorf("resolveCustomerPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resolveCustomerPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ResolveCustomer: Resolve customer

Get details about the requested subscription.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The project ID.
	@return ApiResolveCustomerRequest
*/
func (a *APIClient) ResolveCustomer(ctx context.Context, projectId string) ApiResolveCustomerRequest {
	return ResolveCustomerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ResolveCustomerExecute(ctx context.Context, projectId string) (*VendorSubscription, error) {
	r := ResolveCustomerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type VendorsSubscriptionsRejectRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	subscriptionId string
}

func (r VendorsSubscriptionsRejectRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VendorsSubscriptionsReject")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vendors/projects/{projectId}/subscriptions/{subscriptionId}/reject"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(ParameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.projectId) < 36 {
		return fmt.Errorf("projectId must have at least 36 elements")
	}
	if strlen(r.projectId) > 36 {
		return fmt.Errorf("projectId must have less than 36 elements")
	}
	if strlen(r.subscriptionId) < 36 {
		return fmt.Errorf("subscriptionId must have at least 36 elements")
	}
	if strlen(r.subscriptionId) > 36 {
		return fmt.Errorf("subscriptionId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
VendorsSubscriptionsReject: Reject a subscription

Reject a subscription (in any lifecycle state). Only available for subscriptions to products with lifecycle state `PRODUCT_PREVIEW`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The project ID.
	@param subscriptionId The subscription ID.
	@return ApiVendorsSubscriptionsRejectRequest
*/
func (a *APIClient) VendorsSubscriptionsReject(ctx context.Context, projectId string, subscriptionId string) ApiVendorsSubscriptionsRejectRequest {
	return VendorsSubscriptionsRejectRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		subscriptionId: subscriptionId,
	}
}

func (a *APIClient) VendorsSubscriptionsRejectExecute(ctx context.Context, projectId string, subscriptionId string) error {
	r := VendorsSubscriptionsRejectRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		subscriptionId: subscriptionId,
	}
	return r.Execute()
}
