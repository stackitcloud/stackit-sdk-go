/*
STACKIT Intake API

This API provides endpoints for managing Intakes.

API version: 1beta.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package intake

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateIntake Method for CreateIntake
		Creates a new intake within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ApiCreateIntakeRequest
	*/
	CreateIntake(ctx context.Context, projectId string, regionId string) ApiCreateIntakeRequest
	/*
		CreateIntakeExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return IntakeResponse

	*/
	CreateIntakeExecute(ctx context.Context, projectId string, regionId string) (*IntakeResponse, error)
	/*
		CreateIntakeRunner Method for CreateIntakeRunner
		Creates a new intake runner within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ApiCreateIntakeRunnerRequest
	*/
	CreateIntakeRunner(ctx context.Context, projectId string, regionId string) ApiCreateIntakeRunnerRequest
	/*
		CreateIntakeRunnerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return IntakeRunnerResponse

	*/
	CreateIntakeRunnerExecute(ctx context.Context, projectId string, regionId string) (*IntakeRunnerResponse, error)
	/*
		CreateIntakeUser Method for CreateIntakeUser
		Creates a new user for this intake.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return ApiCreateIntakeUserRequest
	*/
	CreateIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string) ApiCreateIntakeUserRequest
	/*
		CreateIntakeUserExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return IntakeUserResponse

	*/
	CreateIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*IntakeUserResponse, error)
	/*
		DeleteIntake Method for DeleteIntake
		Deletes the given intake.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return ApiDeleteIntakeRequest
	*/
	DeleteIntake(ctx context.Context, projectId string, regionId string, intakeId string) ApiDeleteIntakeRequest
	/*
		DeleteIntakeExecute executes the request

	*/
	DeleteIntakeExecute(ctx context.Context, projectId string, regionId string, intakeId string) error
	/*
		DeleteIntakeRunner Method for DeleteIntakeRunner
		Deletes the given intake runner.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeRunnerId The intake runner UUID.
		@return ApiDeleteIntakeRunnerRequest
	*/
	DeleteIntakeRunner(ctx context.Context, projectId string, regionId string, intakeRunnerId string) ApiDeleteIntakeRunnerRequest
	/*
		DeleteIntakeRunnerExecute executes the request

	*/
	DeleteIntakeRunnerExecute(ctx context.Context, projectId string, regionId string, intakeRunnerId string) error
	/*
		DeleteIntakeUser Method for DeleteIntakeUser
		Deletes the given intake user.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@param intakeUserId The intake user UUID.
		@return ApiDeleteIntakeUserRequest
	*/
	DeleteIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) ApiDeleteIntakeUserRequest
	/*
		DeleteIntakeUserExecute executes the request

	*/
	DeleteIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) error
	/*
		GetIntake Method for GetIntake
		Returns the details for the given intake.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return ApiGetIntakeRequest
	*/
	GetIntake(ctx context.Context, projectId string, regionId string, intakeId string) ApiGetIntakeRequest
	/*
		GetIntakeExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return IntakeResponse

	*/
	GetIntakeExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*IntakeResponse, error)
	/*
		GetIntakeRunner Method for GetIntakeRunner
		Returns the details for the given intake runner.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeRunnerId The intake runner UUID.
		@return ApiGetIntakeRunnerRequest
	*/
	GetIntakeRunner(ctx context.Context, projectId string, regionId string, intakeRunnerId string) ApiGetIntakeRunnerRequest
	/*
		GetIntakeRunnerExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeRunnerId The intake runner UUID.
		@return IntakeRunnerResponse

	*/
	GetIntakeRunnerExecute(ctx context.Context, projectId string, regionId string, intakeRunnerId string) (*IntakeRunnerResponse, error)
	/*
		GetIntakeUser Method for GetIntakeUser
		Returns the details for the given user.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@param intakeUserId The intake user UUID.
		@return ApiGetIntakeUserRequest
	*/
	GetIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) ApiGetIntakeUserRequest
	/*
		GetIntakeUserExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@param intakeUserId The intake user UUID.
		@return IntakeUserResponse

	*/
	GetIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) (*IntakeUserResponse, error)
	/*
		ListIntakeRunners Method for ListIntakeRunners
		Returns a list of all intake runners within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ApiListIntakeRunnersRequest
	*/
	ListIntakeRunners(ctx context.Context, projectId string, regionId string) ApiListIntakeRunnersRequest
	/*
		ListIntakeRunnersExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ListIntakeRunnersResponse

	*/
	ListIntakeRunnersExecute(ctx context.Context, projectId string, regionId string) (*ListIntakeRunnersResponse, error)
	/*
		ListIntakeUsers Method for ListIntakeUsers
		Returns a list of all intake users within the project and intake.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return ApiListIntakeUsersRequest
	*/
	ListIntakeUsers(ctx context.Context, projectId string, regionId string, intakeId string) ApiListIntakeUsersRequest
	/*
		ListIntakeUsersExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return ListIntakeUsersResponse

	*/
	ListIntakeUsersExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*ListIntakeUsersResponse, error)
	/*
		ListIntakes Method for ListIntakes
		Returns a list of all intakes within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ApiListIntakesRequest
	*/
	ListIntakes(ctx context.Context, projectId string, regionId string) ApiListIntakesRequest
	/*
		ListIntakesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@return ListIntakesResponse

	*/
	ListIntakesExecute(ctx context.Context, projectId string, regionId string) (*ListIntakesResponse, error)
	/*
		UpdateIntake Method for UpdateIntake
		Updates the given intake.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return ApiUpdateIntakeRequest
	*/
	UpdateIntake(ctx context.Context, projectId string, regionId string, intakeId string) ApiUpdateIntakeRequest
	/*
		UpdateIntakeExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@return IntakeResponse

	*/
	UpdateIntakeExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*IntakeResponse, error)
	/*
		UpdateIntakeRunner Method for UpdateIntakeRunner
		Updates a intake runner within the project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeRunnerId The intake runner UUID.
		@return ApiUpdateIntakeRunnerRequest
	*/
	UpdateIntakeRunner(ctx context.Context, projectId string, regionId string, intakeRunnerId string) ApiUpdateIntakeRunnerRequest
	/*
		UpdateIntakeRunnerExecute executes the request

	*/
	UpdateIntakeRunnerExecute(ctx context.Context, projectId string, regionId string, intakeRunnerId string) error
	/*
		UpdateIntakeUser Method for UpdateIntakeUser
		Updates the given intake user.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The STACKIT portal project UUID the resource is located in.
		@param regionId The STACKIT region name the resource is located in.
		@param intakeId The intake UUID.
		@param intakeUserId The intake user UUID.
		@return ApiUpdateIntakeUserRequest
	*/
	UpdateIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) ApiUpdateIntakeUserRequest
	/*
		UpdateIntakeUserExecute executes the request

	*/
	UpdateIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) error
}

type ApiCreateIntakeRequest interface {
	CreateIntakePayload(createIntakePayload CreateIntakePayload) ApiCreateIntakeRequest
	Execute() (*IntakeResponse, error)
}

type ApiCreateIntakeRunnerRequest interface {
	CreateIntakeRunnerPayload(createIntakeRunnerPayload CreateIntakeRunnerPayload) ApiCreateIntakeRunnerRequest
	Execute() (*IntakeRunnerResponse, error)
}

type ApiCreateIntakeUserRequest interface {
	CreateIntakeUserPayload(createIntakeUserPayload CreateIntakeUserPayload) ApiCreateIntakeUserRequest
	Execute() (*IntakeUserResponse, error)
}

type ApiDeleteIntakeRequest interface {
	// If true, deletes all child resources. If false, the resource remains in a &#39;deletion state&#39; while child resources exist.
	Force(force bool) ApiDeleteIntakeRequest
	Execute() error
}

type ApiDeleteIntakeRunnerRequest interface {
	// If true, deletes all child resources. If false, the resource remains in a &#39;deletion state&#39; while child resources exist.
	Force(force bool) ApiDeleteIntakeRunnerRequest
	Execute() error
}

type ApiDeleteIntakeUserRequest interface {
	Execute() error
}

type ApiGetIntakeRequest interface {
	Execute() (*IntakeResponse, error)
}

type ApiGetIntakeRunnerRequest interface {
	Execute() (*IntakeRunnerResponse, error)
}

type ApiGetIntakeUserRequest interface {
	Execute() (*IntakeUserResponse, error)
}

type ApiListIntakeRunnersRequest interface {
	// A token to retrieve the next page of results.
	PageToken(pageToken string) ApiListIntakeRunnersRequest
	// Maximum number of items to return
	PageSize(pageSize int32) ApiListIntakeRunnersRequest
	Execute() (*ListIntakeRunnersResponse, error)
}

type ApiListIntakeUsersRequest interface {
	// A token to retrieve the next page of results.
	PageToken(pageToken string) ApiListIntakeUsersRequest
	// Maximum number of items to return
	PageSize(pageSize int32) ApiListIntakeUsersRequest
	Execute() (*ListIntakeUsersResponse, error)
}

type ApiListIntakesRequest interface {
	// A token to retrieve the next page of results.
	PageToken(pageToken string) ApiListIntakesRequest
	// Maximum number of items to return
	PageSize(pageSize int32) ApiListIntakesRequest
	Execute() (*ListIntakesResponse, error)
}

type ApiUpdateIntakeRequest interface {
	UpdateIntakePayload(updateIntakePayload UpdateIntakePayload) ApiUpdateIntakeRequest
	Execute() (*IntakeResponse, error)
}

type ApiUpdateIntakeRunnerRequest interface {
	UpdateIntakeRunnerPayload(updateIntakeRunnerPayload UpdateIntakeRunnerPayload) ApiUpdateIntakeRunnerRequest
	Execute() error
}

type ApiUpdateIntakeUserRequest interface {
	UpdateIntakeUserPayload(updateIntakeUserPayload UpdateIntakeUserPayload) ApiUpdateIntakeUserRequest
	Execute() error
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateIntakeRequest struct {
	ctx                 context.Context
	apiService          *DefaultApiService
	projectId           string
	regionId            string
	createIntakePayload *CreateIntakePayload
}

func (r CreateIntakeRequest) CreateIntakePayload(createIntakePayload CreateIntakePayload) ApiCreateIntakeRequest {
	r.createIntakePayload = &createIntakePayload
	return r
}

func (r CreateIntakeRequest) Execute() (*IntakeResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIntake")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntakePayload == nil {
		return localVarReturnValue, fmt.Errorf("createIntakePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntakePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateIntake: Method for CreateIntake

Creates a new intake within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@return ApiCreateIntakeRequest
*/
func (a *APIClient) CreateIntake(ctx context.Context, projectId string, regionId string) ApiCreateIntakeRequest {
	return CreateIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) CreateIntakeExecute(ctx context.Context, projectId string, regionId string) (*IntakeResponse, error) {
	r := CreateIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type CreateIntakeRunnerRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	regionId                  string
	createIntakeRunnerPayload *CreateIntakeRunnerPayload
}

func (r CreateIntakeRunnerRequest) CreateIntakeRunnerPayload(createIntakeRunnerPayload CreateIntakeRunnerPayload) ApiCreateIntakeRunnerRequest {
	r.createIntakeRunnerPayload = &createIntakeRunnerPayload
	return r
}

func (r CreateIntakeRunnerRequest) Execute() (*IntakeRunnerResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeRunnerResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIntakeRunner")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intake-runners"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntakeRunnerPayload == nil {
		return localVarReturnValue, fmt.Errorf("createIntakeRunnerPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntakeRunnerPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateIntakeRunner: Method for CreateIntakeRunner

Creates a new intake runner within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@return ApiCreateIntakeRunnerRequest
*/
func (a *APIClient) CreateIntakeRunner(ctx context.Context, projectId string, regionId string) ApiCreateIntakeRunnerRequest {
	return CreateIntakeRunnerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) CreateIntakeRunnerExecute(ctx context.Context, projectId string, regionId string) (*IntakeRunnerResponse, error) {
	r := CreateIntakeRunnerRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type CreateIntakeUserRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	regionId                string
	intakeId                string
	createIntakeUserPayload *CreateIntakeUserPayload
}

func (r CreateIntakeUserRequest) CreateIntakeUserPayload(createIntakeUserPayload CreateIntakeUserPayload) ApiCreateIntakeUserRequest {
	r.createIntakeUserPayload = &createIntakeUserPayload
	return r
}

func (r CreateIntakeUserRequest) Execute() (*IntakeUserResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeUserResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIntakeUser")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntakeUserPayload == nil {
		return localVarReturnValue, fmt.Errorf("createIntakeUserPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntakeUserPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateIntakeUser: Method for CreateIntakeUser

Creates a new user for this intake.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@return ApiCreateIntakeUserRequest
*/
func (a *APIClient) CreateIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string) ApiCreateIntakeUserRequest {
	return CreateIntakeUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
}

func (a *APIClient) CreateIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*IntakeUserResponse, error) {
	r := CreateIntakeUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
	return r.Execute()
}

type DeleteIntakeRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	intakeId   string
	force      *bool
}

// If true, deletes all child resources. If false, the resource remains in a &#39;deletion state&#39; while child resources exist.

func (r DeleteIntakeRequest) Force(force bool) ApiDeleteIntakeRequest {
	r.force = &force
	return r
}

func (r DeleteIntakeRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIntake")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return newErr
	}

	return nil
}

/*
DeleteIntake: Method for DeleteIntake

Deletes the given intake.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@return ApiDeleteIntakeRequest
*/
func (a *APIClient) DeleteIntake(ctx context.Context, projectId string, regionId string, intakeId string) ApiDeleteIntakeRequest {
	return DeleteIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
}

func (a *APIClient) DeleteIntakeExecute(ctx context.Context, projectId string, regionId string, intakeId string) error {
	r := DeleteIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
	return r.Execute()
}

type DeleteIntakeRunnerRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	regionId       string
	intakeRunnerId string
	force          *bool
}

// If true, deletes all child resources. If false, the resource remains in a &#39;deletion state&#39; while child resources exist.

func (r DeleteIntakeRunnerRequest) Force(force bool) ApiDeleteIntakeRunnerRequest {
	r.force = &force
	return r
}

func (r DeleteIntakeRunnerRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIntakeRunner")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intake-runners/{intakeRunnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeRunnerId"+"}", url.PathEscape(ParameterValueToString(r.intakeRunnerId, "intakeRunnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return newErr
	}

	return nil
}

/*
DeleteIntakeRunner: Method for DeleteIntakeRunner

Deletes the given intake runner.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeRunnerId The intake runner UUID.
	@return ApiDeleteIntakeRunnerRequest
*/
func (a *APIClient) DeleteIntakeRunner(ctx context.Context, projectId string, regionId string, intakeRunnerId string) ApiDeleteIntakeRunnerRequest {
	return DeleteIntakeRunnerRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		regionId:       regionId,
		intakeRunnerId: intakeRunnerId,
	}
}

func (a *APIClient) DeleteIntakeRunnerExecute(ctx context.Context, projectId string, regionId string, intakeRunnerId string) error {
	r := DeleteIntakeRunnerRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		regionId:       regionId,
		intakeRunnerId: intakeRunnerId,
	}
	return r.Execute()
}

type DeleteIntakeUserRequest struct {
	ctx          context.Context
	apiService   *DefaultApiService
	projectId    string
	regionId     string
	intakeId     string
	intakeUserId string
}

func (r DeleteIntakeUserRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIntakeUser")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}/users/{intakeUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeUserId"+"}", url.PathEscape(ParameterValueToString(r.intakeUserId, "intakeUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return newErr
	}

	return nil
}

/*
DeleteIntakeUser: Method for DeleteIntakeUser

Deletes the given intake user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@param intakeUserId The intake user UUID.
	@return ApiDeleteIntakeUserRequest
*/
func (a *APIClient) DeleteIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) ApiDeleteIntakeUserRequest {
	return DeleteIntakeUserRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		regionId:     regionId,
		intakeId:     intakeId,
		intakeUserId: intakeUserId,
	}
}

func (a *APIClient) DeleteIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) error {
	r := DeleteIntakeUserRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		regionId:     regionId,
		intakeId:     intakeId,
		intakeUserId: intakeUserId,
	}
	return r.Execute()
}

type GetIntakeRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	intakeId   string
}

func (r GetIntakeRequest) Execute() (*IntakeResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIntake")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetIntake: Method for GetIntake

Returns the details for the given intake.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@return ApiGetIntakeRequest
*/
func (a *APIClient) GetIntake(ctx context.Context, projectId string, regionId string, intakeId string) ApiGetIntakeRequest {
	return GetIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
}

func (a *APIClient) GetIntakeExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*IntakeResponse, error) {
	r := GetIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
	return r.Execute()
}

type GetIntakeRunnerRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	regionId       string
	intakeRunnerId string
}

func (r GetIntakeRunnerRequest) Execute() (*IntakeRunnerResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeRunnerResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIntakeRunner")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intake-runners/{intakeRunnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeRunnerId"+"}", url.PathEscape(ParameterValueToString(r.intakeRunnerId, "intakeRunnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetIntakeRunner: Method for GetIntakeRunner

Returns the details for the given intake runner.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeRunnerId The intake runner UUID.
	@return ApiGetIntakeRunnerRequest
*/
func (a *APIClient) GetIntakeRunner(ctx context.Context, projectId string, regionId string, intakeRunnerId string) ApiGetIntakeRunnerRequest {
	return GetIntakeRunnerRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		regionId:       regionId,
		intakeRunnerId: intakeRunnerId,
	}
}

func (a *APIClient) GetIntakeRunnerExecute(ctx context.Context, projectId string, regionId string, intakeRunnerId string) (*IntakeRunnerResponse, error) {
	r := GetIntakeRunnerRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		regionId:       regionId,
		intakeRunnerId: intakeRunnerId,
	}
	return r.Execute()
}

type GetIntakeUserRequest struct {
	ctx          context.Context
	apiService   *DefaultApiService
	projectId    string
	regionId     string
	intakeId     string
	intakeUserId string
}

func (r GetIntakeUserRequest) Execute() (*IntakeUserResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeUserResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIntakeUser")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}/users/{intakeUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeUserId"+"}", url.PathEscape(ParameterValueToString(r.intakeUserId, "intakeUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetIntakeUser: Method for GetIntakeUser

Returns the details for the given user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@param intakeUserId The intake user UUID.
	@return ApiGetIntakeUserRequest
*/
func (a *APIClient) GetIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) ApiGetIntakeUserRequest {
	return GetIntakeUserRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		regionId:     regionId,
		intakeId:     intakeId,
		intakeUserId: intakeUserId,
	}
}

func (a *APIClient) GetIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) (*IntakeUserResponse, error) {
	r := GetIntakeUserRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		regionId:     regionId,
		intakeId:     intakeId,
		intakeUserId: intakeUserId,
	}
	return r.Execute()
}

type ListIntakeRunnersRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	pageToken  *string
	pageSize   *int32
}

// A token to retrieve the next page of results.

func (r ListIntakeRunnersRequest) PageToken(pageToken string) ApiListIntakeRunnersRequest {
	r.pageToken = &pageToken
	return r
}

// Maximum number of items to return

func (r ListIntakeRunnersRequest) PageSize(pageSize int32) ApiListIntakeRunnersRequest {
	r.pageSize = &pageSize
	return r
}

func (r ListIntakeRunnersRequest) Execute() (*ListIntakeRunnersResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntakeRunnersResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIntakeRunners")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intake-runners"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListIntakeRunners: Method for ListIntakeRunners

Returns a list of all intake runners within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@return ApiListIntakeRunnersRequest
*/
func (a *APIClient) ListIntakeRunners(ctx context.Context, projectId string, regionId string) ApiListIntakeRunnersRequest {
	return ListIntakeRunnersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) ListIntakeRunnersExecute(ctx context.Context, projectId string, regionId string) (*ListIntakeRunnersResponse, error) {
	r := ListIntakeRunnersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type ListIntakeUsersRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	intakeId   string
	pageToken  *string
	pageSize   *int32
}

// A token to retrieve the next page of results.

func (r ListIntakeUsersRequest) PageToken(pageToken string) ApiListIntakeUsersRequest {
	r.pageToken = &pageToken
	return r
}

// Maximum number of items to return

func (r ListIntakeUsersRequest) PageSize(pageSize int32) ApiListIntakeUsersRequest {
	r.pageSize = &pageSize
	return r
}

func (r ListIntakeUsersRequest) Execute() (*ListIntakeUsersResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntakeUsersResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIntakeUsers")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListIntakeUsers: Method for ListIntakeUsers

Returns a list of all intake users within the project and intake.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@return ApiListIntakeUsersRequest
*/
func (a *APIClient) ListIntakeUsers(ctx context.Context, projectId string, regionId string, intakeId string) ApiListIntakeUsersRequest {
	return ListIntakeUsersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
}

func (a *APIClient) ListIntakeUsersExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*ListIntakeUsersResponse, error) {
	r := ListIntakeUsersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
	return r.Execute()
}

type ListIntakesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	pageToken  *string
	pageSize   *int32
}

// A token to retrieve the next page of results.

func (r ListIntakesRequest) PageToken(pageToken string) ApiListIntakesRequest {
	r.pageToken = &pageToken
	return r
}

// Maximum number of items to return

func (r ListIntakesRequest) PageSize(pageSize int32) ApiListIntakesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ListIntakesRequest) Execute() (*ListIntakesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListIntakesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIntakes")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListIntakes: Method for ListIntakes

Returns a list of all intakes within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@return ApiListIntakesRequest
*/
func (a *APIClient) ListIntakes(ctx context.Context, projectId string, regionId string) ApiListIntakesRequest {
	return ListIntakesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) ListIntakesExecute(ctx context.Context, projectId string, regionId string) (*ListIntakesResponse, error) {
	r := ListIntakesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type UpdateIntakeRequest struct {
	ctx                 context.Context
	apiService          *DefaultApiService
	projectId           string
	regionId            string
	intakeId            string
	updateIntakePayload *UpdateIntakePayload
}

func (r UpdateIntakeRequest) UpdateIntakePayload(updateIntakePayload UpdateIntakePayload) ApiUpdateIntakeRequest {
	r.updateIntakePayload = &updateIntakePayload
	return r
}

func (r UpdateIntakeRequest) Execute() (*IntakeResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IntakeResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateIntake")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIntakePayload == nil {
		return localVarReturnValue, fmt.Errorf("updateIntakePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIntakePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateIntake: Method for UpdateIntake

Updates the given intake.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@return ApiUpdateIntakeRequest
*/
func (a *APIClient) UpdateIntake(ctx context.Context, projectId string, regionId string, intakeId string) ApiUpdateIntakeRequest {
	return UpdateIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
}

func (a *APIClient) UpdateIntakeExecute(ctx context.Context, projectId string, regionId string, intakeId string) (*IntakeResponse, error) {
	r := UpdateIntakeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		intakeId:   intakeId,
	}
	return r.Execute()
}

type UpdateIntakeRunnerRequest struct {
	ctx                       context.Context
	apiService                *DefaultApiService
	projectId                 string
	regionId                  string
	intakeRunnerId            string
	updateIntakeRunnerPayload *UpdateIntakeRunnerPayload
}

func (r UpdateIntakeRunnerRequest) UpdateIntakeRunnerPayload(updateIntakeRunnerPayload UpdateIntakeRunnerPayload) ApiUpdateIntakeRunnerRequest {
	r.updateIntakeRunnerPayload = &updateIntakeRunnerPayload
	return r
}

func (r UpdateIntakeRunnerRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateIntakeRunner")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intake-runners/{intakeRunnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeRunnerId"+"}", url.PathEscape(ParameterValueToString(r.intakeRunnerId, "intakeRunnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIntakeRunnerPayload == nil {
		return fmt.Errorf("updateIntakeRunnerPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIntakeRunnerPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return newErr
	}

	return nil
}

/*
UpdateIntakeRunner: Method for UpdateIntakeRunner

Updates a intake runner within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeRunnerId The intake runner UUID.
	@return ApiUpdateIntakeRunnerRequest
*/
func (a *APIClient) UpdateIntakeRunner(ctx context.Context, projectId string, regionId string, intakeRunnerId string) ApiUpdateIntakeRunnerRequest {
	return UpdateIntakeRunnerRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		regionId:       regionId,
		intakeRunnerId: intakeRunnerId,
	}
}

func (a *APIClient) UpdateIntakeRunnerExecute(ctx context.Context, projectId string, regionId string, intakeRunnerId string) error {
	r := UpdateIntakeRunnerRequest{
		apiService:     a.defaultApi,
		ctx:            ctx,
		projectId:      projectId,
		regionId:       regionId,
		intakeRunnerId: intakeRunnerId,
	}
	return r.Execute()
}

type UpdateIntakeUserRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	regionId                string
	intakeId                string
	intakeUserId            string
	updateIntakeUserPayload *UpdateIntakeUserPayload
}

func (r UpdateIntakeUserRequest) UpdateIntakeUserPayload(updateIntakeUserPayload UpdateIntakeUserPayload) ApiUpdateIntakeUserRequest {
	r.updateIntakeUserPayload = &updateIntakeUserPayload
	return r
}

func (r UpdateIntakeUserRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateIntakeUser")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/intakes/{intakeId}/users/{intakeUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeId"+"}", url.PathEscape(ParameterValueToString(r.intakeId, "intakeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"intakeUserId"+"}", url.PathEscape(ParameterValueToString(r.intakeUserId, "intakeUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIntakeUserPayload == nil {
		return fmt.Errorf("updateIntakeUserPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIntakeUserPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return newErr
	}

	return nil
}

/*
UpdateIntakeUser: Method for UpdateIntakeUser

Updates the given intake user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the resource is located in.
	@param regionId The STACKIT region name the resource is located in.
	@param intakeId The intake UUID.
	@param intakeUserId The intake user UUID.
	@return ApiUpdateIntakeUserRequest
*/
func (a *APIClient) UpdateIntakeUser(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) ApiUpdateIntakeUserRequest {
	return UpdateIntakeUserRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		regionId:     regionId,
		intakeId:     intakeId,
		intakeUserId: intakeUserId,
	}
}

func (a *APIClient) UpdateIntakeUserExecute(ctx context.Context, projectId string, regionId string, intakeId string, intakeUserId string) error {
	r := UpdateIntakeUserRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		regionId:     regionId,
		intakeId:     intakeId,
		intakeUserId: intakeUserId,
	}
	return r.Execute()
}
