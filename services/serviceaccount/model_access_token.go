/*
Service Account API

API to manage Service Accounts and their Access Tokens.  ### System for Cross-domain Identity Management (SCIM) Service Account Service offers SCIM APIs to query state. The SCIM protocol was created as standard for  automating the exchange of user identity information between identity domains, or IT systems. Service accounts  are be handled as indentites similar to SCIM users. A custom SCIM schema has been created: `/ServiceAccounts`  #### Syntax ##### Attribute operators | OPERATOR | DESCRIPTION              | |----------|--------------------------| | eq       | equal                    | | ne       | not equal                | | co       | contains                 | | sw       | starts with              | | ew       | ends with                |  ##### Logical operators | OPERATOR | DESCRIPTION              | |----------|--------------------------| | and      | logical \"and\"            | | or       | logical \"or\"             |  ##### Grouping operators | OPERATOR | DESCRIPTION              | |----------|--------------------------| | ()       | precending grouping      |  ##### Example ``` filter=email eq \"my-service-account-aBc2defg@sa.stackit.cloud\" filter=email ne \"my-service-account-aBc2defg@sa.stackit.cloud\" filter=email co \"my-service-account\" filter=name sw \"my\" filter=name ew \"account\" filter=email co \"my-service-account\" and name sw \"my\" filter=email co \"my-service-account\" and (name sw \"my\" or name ew \"account\") ```  #### Sorting  > Sorting is optional  | PARAMETER | DESCRIPTION                          | |-----------|--------------------------------------| | sortBy    | attribute response is ordered by     | | sortOrder | 'ASCENDING' (default) or 'DESCENDING'|  #### Pagination  | PARAMETER    | DESCRIPTION                                  | |--------------|----------------------------------------------| | startIndex   | index of first query result, default: 1      | | count        | maximum number of query results, default: 100|

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package serviceaccount

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"
)

// checks if the AccessToken type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &AccessToken{}

/*
	types and functions for active
*/

// isBoolean
type AccessTokengetActiveAttributeType = *bool
type AccessTokengetActiveArgType = bool
type AccessTokengetActiveRetType = bool

func getAccessTokengetActiveAttributeTypeOk(arg AccessTokengetActiveAttributeType) (ret AccessTokengetActiveRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setAccessTokengetActiveAttributeType(arg *AccessTokengetActiveAttributeType, val AccessTokengetActiveRetType) {
	*arg = &val
}

/*
	types and functions for createdAt
*/

// isDateTime
type AccessTokenGetCreatedAtAttributeType = *time.Time
type AccessTokenGetCreatedAtArgType = time.Time
type AccessTokenGetCreatedAtRetType = time.Time

func getAccessTokenGetCreatedAtAttributeTypeOk(arg AccessTokenGetCreatedAtAttributeType) (ret AccessTokenGetCreatedAtRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setAccessTokenGetCreatedAtAttributeType(arg *AccessTokenGetCreatedAtAttributeType, val AccessTokenGetCreatedAtRetType) {
	*arg = &val
}

/*
	types and functions for id
*/

// isNotNullableString
type AccessTokenGetIdAttributeType = *string

func getAccessTokenGetIdAttributeTypeOk(arg AccessTokenGetIdAttributeType) (ret AccessTokenGetIdRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setAccessTokenGetIdAttributeType(arg *AccessTokenGetIdAttributeType, val AccessTokenGetIdRetType) {
	*arg = &val
}

type AccessTokenGetIdArgType = string
type AccessTokenGetIdRetType = string

/*
	types and functions for token
*/

// isNotNullableString
type AccessTokenGetTokenAttributeType = *string

func getAccessTokenGetTokenAttributeTypeOk(arg AccessTokenGetTokenAttributeType) (ret AccessTokenGetTokenRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setAccessTokenGetTokenAttributeType(arg *AccessTokenGetTokenAttributeType, val AccessTokenGetTokenRetType) {
	*arg = &val
}

type AccessTokenGetTokenArgType = string
type AccessTokenGetTokenRetType = string

/*
	types and functions for validUntil
*/

// isDateTime
type AccessTokenGetValidUntilAttributeType = *time.Time
type AccessTokenGetValidUntilArgType = time.Time
type AccessTokenGetValidUntilRetType = time.Time

func getAccessTokenGetValidUntilAttributeTypeOk(arg AccessTokenGetValidUntilAttributeType) (ret AccessTokenGetValidUntilRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setAccessTokenGetValidUntilAttributeType(arg *AccessTokenGetValidUntilAttributeType, val AccessTokenGetValidUntilRetType) {
	*arg = &val
}

// AccessToken Contains token metadata and actual token.
type AccessToken struct {
	// Newly created access tokens are valid, and can be revoked if needed.
	// REQUIRED
	Active AccessTokengetActiveAttributeType `json:"active"`
	// Creation time of the access token.
	// REQUIRED
	CreatedAt AccessTokenGetCreatedAtAttributeType `json:"createdAt"`
	// Unique ID of the access token. Also used as JTI field.
	// REQUIRED
	Id AccessTokenGetIdAttributeType `json:"id"`
	// The access token in JWT format. Use this with `Bearer` prefix for API calls. Store it, as it is not recoverable later.
	// REQUIRED
	Token AccessTokenGetTokenAttributeType `json:"token"`
	// Approximate expiration time of the access token. Check the JWT for actual validity date.
	// REQUIRED
	ValidUntil AccessTokenGetValidUntilAttributeType `json:"validUntil"`
}

type _AccessToken AccessToken

// NewAccessToken instantiates a new AccessToken object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewAccessToken(active AccessTokengetActiveArgType, createdAt AccessTokenGetCreatedAtArgType, id AccessTokenGetIdArgType, token AccessTokenGetTokenArgType, validUntil AccessTokenGetValidUntilArgType) *AccessToken {
	this := AccessToken{}
	setAccessTokengetActiveAttributeType(&this.Active, active)
	setAccessTokenGetCreatedAtAttributeType(&this.CreatedAt, createdAt)
	setAccessTokenGetIdAttributeType(&this.Id, id)
	setAccessTokenGetTokenAttributeType(&this.Token, token)
	setAccessTokenGetValidUntilAttributeType(&this.ValidUntil, validUntil)
	return &this
}

// NewAccessTokenWithDefaults instantiates a new AccessToken object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewAccessTokenWithDefaults() *AccessToken {
	this := AccessToken{}
	return &this
}

// GetActive returns the Active field value
func (o *AccessToken) GetActive() (ret AccessTokengetActiveRetType) {
	ret, _ = o.GetActiveOk()
	return ret
}

// GetActiveOk returns a tuple with the Active field value
// and a boolean to check if the value has been set.
func (o *AccessToken) GetActiveOk() (ret AccessTokengetActiveRetType, ok bool) {
	return getAccessTokengetActiveAttributeTypeOk(o.Active)
}

// SetActive sets field value
func (o *AccessToken) SetActive(v AccessTokengetActiveRetType) {
	setAccessTokengetActiveAttributeType(&o.Active, v)
}

// GetCreatedAt returns the CreatedAt field value
func (o *AccessToken) GetCreatedAt() (ret AccessTokenGetCreatedAtRetType) {
	ret, _ = o.GetCreatedAtOk()
	return ret
}

// GetCreatedAtOk returns a tuple with the CreatedAt field value
// and a boolean to check if the value has been set.
func (o *AccessToken) GetCreatedAtOk() (ret AccessTokenGetCreatedAtRetType, ok bool) {
	return getAccessTokenGetCreatedAtAttributeTypeOk(o.CreatedAt)
}

// SetCreatedAt sets field value
func (o *AccessToken) SetCreatedAt(v AccessTokenGetCreatedAtRetType) {
	setAccessTokenGetCreatedAtAttributeType(&o.CreatedAt, v)
}

// GetId returns the Id field value
func (o *AccessToken) GetId() (ret AccessTokenGetIdRetType) {
	ret, _ = o.GetIdOk()
	return ret
}

// GetIdOk returns a tuple with the Id field value
// and a boolean to check if the value has been set.
func (o *AccessToken) GetIdOk() (ret AccessTokenGetIdRetType, ok bool) {
	return getAccessTokenGetIdAttributeTypeOk(o.Id)
}

// SetId sets field value
func (o *AccessToken) SetId(v AccessTokenGetIdRetType) {
	setAccessTokenGetIdAttributeType(&o.Id, v)
}

// GetToken returns the Token field value
func (o *AccessToken) GetToken() (ret AccessTokenGetTokenRetType) {
	ret, _ = o.GetTokenOk()
	return ret
}

// GetTokenOk returns a tuple with the Token field value
// and a boolean to check if the value has been set.
func (o *AccessToken) GetTokenOk() (ret AccessTokenGetTokenRetType, ok bool) {
	return getAccessTokenGetTokenAttributeTypeOk(o.Token)
}

// SetToken sets field value
func (o *AccessToken) SetToken(v AccessTokenGetTokenRetType) {
	setAccessTokenGetTokenAttributeType(&o.Token, v)
}

// GetValidUntil returns the ValidUntil field value
func (o *AccessToken) GetValidUntil() (ret AccessTokenGetValidUntilRetType) {
	ret, _ = o.GetValidUntilOk()
	return ret
}

// GetValidUntilOk returns a tuple with the ValidUntil field value
// and a boolean to check if the value has been set.
func (o *AccessToken) GetValidUntilOk() (ret AccessTokenGetValidUntilRetType, ok bool) {
	return getAccessTokenGetValidUntilAttributeTypeOk(o.ValidUntil)
}

// SetValidUntil sets field value
func (o *AccessToken) SetValidUntil(v AccessTokenGetValidUntilRetType) {
	setAccessTokenGetValidUntilAttributeType(&o.ValidUntil, v)
}

func (o AccessToken) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o AccessToken) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if val, ok := getAccessTokengetActiveAttributeTypeOk(o.Active); ok {
		toSerialize["Active"] = val
	}
	if val, ok := getAccessTokenGetCreatedAtAttributeTypeOk(o.CreatedAt); ok {
		toSerialize["CreatedAt"] = val
	}
	if val, ok := getAccessTokenGetIdAttributeTypeOk(o.Id); ok {
		toSerialize["Id"] = val
	}
	if val, ok := getAccessTokenGetTokenAttributeTypeOk(o.Token); ok {
		toSerialize["Token"] = val
	}
	if val, ok := getAccessTokenGetValidUntilAttributeTypeOk(o.ValidUntil); ok {
		toSerialize["ValidUntil"] = val
	}
	return toSerialize, nil
}

func (o *AccessToken) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"active",
		"createdAt",
		"id",
		"token",
		"validUntil",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varAccessToken := _AccessToken{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varAccessToken)

	if err != nil {
		return err
	}

	*o = AccessToken(varAccessToken)

	return err
}

type NullableAccessToken struct {
	value *AccessToken
	isSet bool
}

func (v NullableAccessToken) Get() *AccessToken {
	return v.value
}

func (v *NullableAccessToken) Set(val *AccessToken) {
	v.value = val
	v.isSet = true
}

func (v NullableAccessToken) IsSet() bool {
	return v.isSet
}

func (v *NullableAccessToken) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAccessToken(val *AccessToken) *NullableAccessToken {
	return &NullableAccessToken{value: val, isSet: true}
}

func (v NullableAccessToken) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAccessToken) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
