/*
STACKIT DNS API

This api provides dns

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CloneZone Clone an existing zone with all record sets to a new zone with a different name
		Clone an existing zone with all record sets to a new zone with a different name

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiCloneZoneRequest
	*/
	CloneZone(ctx context.Context, projectId string, zoneId string) ApiCloneZoneRequest
	/*
		CloneZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ZoneResponse

	*/
	CloneZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error)
	/*
		CreateLabel Create or update label
		Create or update label

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiCreateLabelRequest
	*/
	CreateLabel(ctx context.Context, projectId string, zoneId string) ApiCreateLabelRequest
	/*
		CreateLabelExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return CreateLabelResponse

	*/
	CreateLabelExecute(ctx context.Context, projectId string, zoneId string) (*CreateLabelResponse, error)
	/*
		CreateMoveCode request a move code to move zone to another project
		move zone from one project to another

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiCreateMoveCodeRequest
	*/
	CreateMoveCode(ctx context.Context, projectId string, zoneId string) ApiCreateMoveCodeRequest
	/*
		CreateMoveCodeExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return MoveCodeResponse

	*/
	CreateMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*MoveCodeResponse, error)
	/*
		CreateRecordSet Post record set
		Post record set

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiCreateRecordSetRequest
	*/
	CreateRecordSet(ctx context.Context, projectId string, zoneId string) ApiCreateRecordSetRequest
	/*
		CreateRecordSetExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return RecordSetResponse

	*/
	CreateRecordSetExecute(ctx context.Context, projectId string, zoneId string) (*RecordSetResponse, error)
	/*
		CreateZone Post create a new zone
		Post zone create a new zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return ApiCreateZoneRequest
	*/
	CreateZone(ctx context.Context, projectId string) ApiCreateZoneRequest
	/*
		CreateZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return ZoneResponse

	*/
	CreateZoneExecute(ctx context.Context, projectId string) (*ZoneResponse, error)
	/*
		DeleteLabel Delete a label
		Delete a label

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param key key of the label
		@return ApiDeleteLabelRequest
	*/
	DeleteLabel(ctx context.Context, projectId string, zoneId string, key string) ApiDeleteLabelRequest
	/*
		DeleteLabelExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param key key of the label
		@return DeleteLabelResponse

	*/
	DeleteLabelExecute(ctx context.Context, projectId string, zoneId string, key string) (*DeleteLabelResponse, error)
	/*
		DeleteMoveCode delete/invalidate a move code
		delete/invalidate a move code

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiDeleteMoveCodeRequest
	*/
	DeleteMoveCode(ctx context.Context, projectId string, zoneId string) ApiDeleteMoveCodeRequest
	/*
		DeleteMoveCodeExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return Message

	*/
	DeleteMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*Message, error)
	/*
		DeleteRecordSet Delete a record set
		Delete a record set

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return ApiDeleteRecordSetRequest
	*/
	DeleteRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiDeleteRecordSetRequest
	/*
		DeleteRecordSetExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return Message

	*/
	DeleteRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error)
	/*
		DeleteZone Delete a zone
		Delete a zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiDeleteZoneRequest
	*/
	DeleteZone(ctx context.Context, projectId string, zoneId string) ApiDeleteZoneRequest
	/*
		DeleteZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return Message

	*/
	DeleteZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error)
	/*
		ExportRecordSets Export all records in a single zone
		Export Zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiExportRecordSetsRequest
	*/
	ExportRecordSets(ctx context.Context, projectId string, zoneId string) ApiExportRecordSetsRequest
	/*
		ExportRecordSetsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ZoneDataExchange

	*/
	ExportRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ZoneDataExchange, error)
	/*
		GetRecordSet Get a single rrset
		Get rrset

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return ApiGetRecordSetRequest
	*/
	GetRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiGetRecordSetRequest
	/*
		GetRecordSetExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return RecordSetResponse

	*/
	GetRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*RecordSetResponse, error)
	/*
		GetZone Get a single zone
		Get zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiGetZoneRequest
	*/
	GetZone(ctx context.Context, projectId string, zoneId string) ApiGetZoneRequest
	/*
		GetZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ZoneResponse

	*/
	GetZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error)
	/*
		ImportRecordSets Imports a zone
		Imports a zone and overwrites/deletes/inserts all desired records

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiImportRecordSetsRequest
	*/
	ImportRecordSets(ctx context.Context, projectId string, zoneId string) ApiImportRecordSetsRequest
	/*
		ImportRecordSetsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ImportRecordSetsResponse

	*/
	ImportRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ImportRecordSetsResponse, error)
	/*
		ListLabels Get all labels
		All Labels

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiListLabelsRequest
	*/
	ListLabels(ctx context.Context, projectId string, zoneId string) ApiListLabelsRequest
	/*
		ListLabelsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ListLabelsResponse

	*/
	ListLabelsExecute(ctx context.Context, projectId string, zoneId string) (*ListLabelsResponse, error)
	/*
		ListRecordSets All get selected RRSets
		All RRSet

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiListRecordSetsRequest
	*/
	ListRecordSets(ctx context.Context, projectId string, zoneId string) ApiListRecordSetsRequest
	/*
		ListRecordSetsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ListRecordSetsResponse

	*/
	ListRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ListRecordSetsResponse, error)
	/*
		ListZones All get selected zones
		All zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return ApiListZonesRequest
	*/
	ListZones(ctx context.Context, projectId string) ApiListZonesRequest
	/*
		ListZonesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return ListZonesResponse

	*/
	ListZonesExecute(ctx context.Context, projectId string) (*ListZonesResponse, error)
	/*
		MoveZone move zone from one project to another
		move zone from one project to another

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return ApiMoveZoneRequest
	*/
	MoveZone(ctx context.Context, projectId string) ApiMoveZoneRequest
	/*
		MoveZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@return Message

	*/
	MoveZoneExecute(ctx context.Context, projectId string) (*Message, error)
	/*
		PartialUpdateRecord PatchRecords updates a record in a rrset
		PatchRecords rrset updates a record in a rrset

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return ApiPartialUpdateRecordRequest
	*/
	PartialUpdateRecord(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordRequest
	/*
		PartialUpdateRecordExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return Message

	*/
	PartialUpdateRecordExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error)
	/*
		PartialUpdateRecordSet Patch updates a record set
		Patch record set

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return ApiPartialUpdateRecordSetRequest
	*/
	PartialUpdateRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordSetRequest
	/*
		PartialUpdateRecordSetExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return Message

	*/
	PartialUpdateRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error)
	/*
		PartialUpdateZone Patch update an existing zone
		Patch update an existing zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiPartialUpdateZoneRequest
	*/
	PartialUpdateZone(ctx context.Context, projectId string, zoneId string) ApiPartialUpdateZoneRequest
	/*
		PartialUpdateZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ZoneResponse

	*/
	PartialUpdateZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error)
	/*
		RestoreRecordSet Restore record set
		Restore record set

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return ApiRestoreRecordSetRequest
	*/
	RestoreRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiRestoreRecordSetRequest
	/*
		RestoreRecordSetExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@param rrSetId record set id
		@return Message

	*/
	RestoreRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error)
	/*
		RestoreZone Restore  an inactive zone
		Restore  an inactive zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiRestoreZoneRequest
	*/
	RestoreZone(ctx context.Context, projectId string, zoneId string) ApiRestoreZoneRequest
	/*
		RestoreZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return Message

	*/
	RestoreZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error)
	/*
		RetrieveZone Queue secondary zone for a zone transfer request.
		The zone transfer will usually be performed within a few seconds, and will be tried only once by randomly choosing one of the configured primary name servers. If that single attempt fails, no further attempt will be performed. The zone will be transferred to our inbound name server regardless of its serial, but the internal zone distribution is only reliable if the zone's serial on the customer's primary name server is higher than on the STACKIT name server. <br>NOTE: As said above, this endpoint is not a reliable way to decrease a zone's serial. To guarantee consistent zones over all STACKIT location, the zone's serial MUST always be increased on zone changes.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiRetrieveZoneRequest
	*/
	RetrieveZone(ctx context.Context, projectId string, zoneId string) ApiRetrieveZoneRequest
	/*
		RetrieveZoneExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return Message

	*/
	RetrieveZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error)
	/*
		ValidateMoveCode validate the move code is still valid for the zone
		validate the move code is still valid for the zone

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return ApiValidateMoveCodeRequest
	*/
	ValidateMoveCode(ctx context.Context, projectId string, zoneId string) ApiValidateMoveCodeRequest
	/*
		ValidateMoveCodeExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId project id
		@param zoneId zone id
		@return Message

	*/
	ValidateMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*Message, error)
}

type ApiCloneZoneRequest interface {
	// zone to clone
	CloneZonePayload(cloneZonePayload CloneZonePayload) ApiCloneZoneRequest
	Execute() (*ZoneResponse, error)
}

type ApiCreateLabelRequest interface {
	// record set to create
	CreateLabelPayload(createLabelPayload CreateLabelPayload) ApiCreateLabelRequest
	Execute() (*CreateLabelResponse, error)
}

type ApiCreateMoveCodeRequest interface {
	Execute() (*MoveCodeResponse, error)
}

type ApiCreateRecordSetRequest interface {
	// record set to create
	CreateRecordSetPayload(createRecordSetPayload CreateRecordSetPayload) ApiCreateRecordSetRequest
	Execute() (*RecordSetResponse, error)
}

type ApiCreateZoneRequest interface {
	// zone to create
	CreateZonePayload(createZonePayload CreateZonePayload) ApiCreateZoneRequest
	Execute() (*ZoneResponse, error)
}

type ApiDeleteLabelRequest interface {
	Execute() (*DeleteLabelResponse, error)
}

type ApiDeleteMoveCodeRequest interface {
	Execute() (*Message, error)
}

type ApiDeleteRecordSetRequest interface {
	Execute() (*Message, error)
}

type ApiDeleteZoneRequest interface {
	Execute() (*Message, error)
}

type ApiExportRecordSetsRequest interface {
	// export configuration
	ExportRecordSetsPayload(exportRecordSetsPayload ExportRecordSetsPayload) ApiExportRecordSetsRequest
	Execute() (*ZoneDataExchange, error)
}

type ApiGetRecordSetRequest interface {
	Execute() (*RecordSetResponse, error)
}

type ApiGetZoneRequest interface {
	Execute() (*ZoneResponse, error)
}

type ApiImportRecordSetsRequest interface {
	// accepts all response bodies for the export endpoint
	ImportRecordSetsPayload(importRecordSetsPayload ImportRecordSetsPayload) ApiImportRecordSetsRequest
	// format of the data to import
	Format(format string) ApiImportRecordSetsRequest
	// type of the zone import
	ImportType(importType string) ApiImportRecordSetsRequest
	Execute() (*ImportRecordSetsResponse, error)
}

type ApiListLabelsRequest interface {
	Execute() (*ListLabelsResponse, error)
}

type ApiListRecordSetsRequest interface {
	// page
	Page(page int32) ApiListRecordSetsRequest
	// page size
	PageSize(pageSize int32) ApiListRecordSetsRequest
	// filter name equal
	NameEq(nameEq string) ApiListRecordSetsRequest
	// filter name like
	NameLike(nameLike string) ApiListRecordSetsRequest
	// filter type
	TypeEq(typeEq string) ApiListRecordSetsRequest
	// filter state
	StateEq(stateEq string) ApiListRecordSetsRequest
	// filter state
	StateNeq(stateNeq string) ApiListRecordSetsRequest
	// filter active equal
	ActiveEq(activeEq bool) ApiListRecordSetsRequest
	// filter creation started greater with utc timestamp
	CreationStartedGt(creationStartedGt string) ApiListRecordSetsRequest
	// filter creation started lesser with utc timestamp
	CreationStartedLt(creationStartedLt string) ApiListRecordSetsRequest
	// filter creation started greater equal with utc timestamp
	CreationStartedGte(creationStartedGte string) ApiListRecordSetsRequest
	// filter creation started lesser equal with utc timestamp
	CreationStartedLte(creationStartedLte string) ApiListRecordSetsRequest
	// filter creation finished greater with utc timestamp
	CreationFinishedGt(creationFinishedGt string) ApiListRecordSetsRequest
	// filter creation finished lesser with utc timestamp
	CreationFinishedLt(creationFinishedLt string) ApiListRecordSetsRequest
	// filter creation finished greater equal with utc timestamp
	CreationFinishedGte(creationFinishedGte string) ApiListRecordSetsRequest
	// filter creation finished lesser equal with utc timestamp
	CreationFinishedLte(creationFinishedLte string) ApiListRecordSetsRequest
	// filter update started greater with utc timestamp
	UpdateStartedGt(updateStartedGt string) ApiListRecordSetsRequest
	// filter update started lesser with utc timestamp
	UpdateStartedLt(updateStartedLt string) ApiListRecordSetsRequest
	// filter update started greater equal with utc timestamp
	UpdateStartedGte(updateStartedGte string) ApiListRecordSetsRequest
	// filter update started lesser equal with utc timestamp
	UpdateStartedLte(updateStartedLte string) ApiListRecordSetsRequest
	// filter update finished greater with utc timestamp
	UpdateFinishedGt(updateFinishedGt string) ApiListRecordSetsRequest
	// filter update finished lesser with utc timestamp
	UpdateFinishedLt(updateFinishedLt string) ApiListRecordSetsRequest
	// filter update finished greater equal with utc timestamp
	UpdateFinishedGte(updateFinishedGte string) ApiListRecordSetsRequest
	// filter update finished lesser equal with utc timestamp
	UpdateFinishedLte(updateFinishedLte string) ApiListRecordSetsRequest
	// order by name
	OrderByName(orderByName string) ApiListRecordSetsRequest
	// order by creationStarted
	OrderByCreationStarted(orderByCreationStarted string) ApiListRecordSetsRequest
	// order by creationFinished
	OrderByCreationFinished(orderByCreationFinished string) ApiListRecordSetsRequest
	// order by updateStarted
	OrderByUpdateStarted(orderByUpdateStarted string) ApiListRecordSetsRequest
	// order by updateFinished
	OrderByUpdateFinished(orderByUpdateFinished string) ApiListRecordSetsRequest
	// order by type
	OrderByType(orderByType string) ApiListRecordSetsRequest
	// order by state
	OrderByState(orderByState string) ApiListRecordSetsRequest
	// order by record count
	OrderByRecordCount(orderByRecordCount string) ApiListRecordSetsRequest
	Execute() (*ListRecordSetsResponse, error)
}

type ApiListZonesRequest interface {
	// page
	Page(page int32) ApiListZonesRequest
	// page size
	PageSize(pageSize int32) ApiListZonesRequest
	// filter dns name equal
	DnsNameEq(dnsNameEq string) ApiListZonesRequest
	// filter dns name like
	DnsNameLike(dnsNameLike string) ApiListZonesRequest
	// filter type
	TypeEq(typeEq string) ApiListZonesRequest
	// filter name equal
	NameEq(nameEq string) ApiListZonesRequest
	// filter name not equal
	NameNeq(nameNeq string) ApiListZonesRequest
	// filter name like
	NameLike(nameLike string) ApiListZonesRequest
	// filter description equal
	DescriptionEq(descriptionEq string) ApiListZonesRequest
	// filter description not equal
	DescriptionNeq(descriptionNeq string) ApiListZonesRequest
	// filter description like
	DescriptionLike(descriptionLike string) ApiListZonesRequest
	// filter state
	StateEq(stateEq string) ApiListZonesRequest
	// filter state
	StateNeq(stateNeq string) ApiListZonesRequest
	// filter primary name server equal
	PrimaryNameServerEq(primaryNameServerEq string) ApiListZonesRequest
	// filter primary name server like
	PrimaryNameServerLike(primaryNameServerLike string) ApiListZonesRequest
	// filter reverse zone equal
	IsReverseZoneEq(isReverseZoneEq bool) ApiListZonesRequest
	// filter active equal
	ActiveEq(activeEq bool) ApiListZonesRequest
	// filter creation started greater with utc timestamp
	CreationStartedGt(creationStartedGt string) ApiListZonesRequest
	// filter creation started lesser with utc timestamp
	CreationStartedLt(creationStartedLt string) ApiListZonesRequest
	// filter creation started greater equal with utc timestamp
	CreationStartedGte(creationStartedGte string) ApiListZonesRequest
	// filter creation started lesser equal with utc timestamp
	CreationStartedLte(creationStartedLte string) ApiListZonesRequest
	// filter creation finished greater with utc timestamp
	CreationFinishedGt(creationFinishedGt string) ApiListZonesRequest
	// filter creation finished lesser with utc timestamp
	CreationFinishedLt(creationFinishedLt string) ApiListZonesRequest
	// filter creation finished greater equal with utc timestamp
	CreationFinishedGte(creationFinishedGte string) ApiListZonesRequest
	// filter creation finished lesser equal with utc timestamp
	CreationFinishedLte(creationFinishedLte string) ApiListZonesRequest
	// filter update started greater with utc timestamp
	UpdateStartedGt(updateStartedGt string) ApiListZonesRequest
	// filter update started lesser with utc timestamp
	UpdateStartedLt(updateStartedLt string) ApiListZonesRequest
	// filter update started greater equal with utc timestamp
	UpdateStartedGte(updateStartedGte string) ApiListZonesRequest
	// filter update started lesser equal with utc timestamp
	UpdateStartedLte(updateStartedLte string) ApiListZonesRequest
	// filter update finished greater with utc timestamp
	UpdateFinishedGt(updateFinishedGt string) ApiListZonesRequest
	// filter update finished lesser with utc timestamp
	UpdateFinishedLt(updateFinishedLt string) ApiListZonesRequest
	// filter update finished greater equal with utc timestamp
	UpdateFinishedGte(updateFinishedGte string) ApiListZonesRequest
	// filter update finished lesser equal with utc timestamp
	UpdateFinishedLte(updateFinishedLte string) ApiListZonesRequest
	// filter zones according to the zone label keys.
	LabelKeyEq(labelKeyEq []string) ApiListZonesRequest
	// filter zones according to the zone label values.
	LabelValueEq(labelValueEq []string) ApiListZonesRequest
	// order by dns name
	OrderByDnsName(orderByDnsName string) ApiListZonesRequest
	// order by name
	OrderByName(orderByName string) ApiListZonesRequest
	// order by record count
	OrderByRecordCount(orderByRecordCount string) ApiListZonesRequest
	// order by type
	OrderByType(orderByType string) ApiListZonesRequest
	// order by description
	OrderByDescription(orderByDescription string) ApiListZonesRequest
	// order by creationStarted
	OrderByCreationStarted(orderByCreationStarted string) ApiListZonesRequest
	// order by creationFinished
	OrderByCreationFinished(orderByCreationFinished string) ApiListZonesRequest
	// order by updateStarted
	OrderByUpdateStarted(orderByUpdateStarted string) ApiListZonesRequest
	// order by updateFinished
	OrderByUpdateFinished(orderByUpdateFinished string) ApiListZonesRequest
	Execute() (*ListZonesResponse, error)
}

type ApiMoveZoneRequest interface {
	// information about the move
	MoveZonePayload(moveZonePayload MoveZonePayload) ApiMoveZoneRequest
	Execute() (*Message, error)
}

type ApiPartialUpdateRecordRequest interface {
	// rrset to update
	PartialUpdateRecordPayload(partialUpdateRecordPayload PartialUpdateRecordPayload) ApiPartialUpdateRecordRequest
	Execute() (*Message, error)
}

type ApiPartialUpdateRecordSetRequest interface {
	// record set to patch
	PartialUpdateRecordSetPayload(partialUpdateRecordSetPayload PartialUpdateRecordSetPayload) ApiPartialUpdateRecordSetRequest
	Execute() (*Message, error)
}

type ApiPartialUpdateZoneRequest interface {
	// zone to update
	PartialUpdateZonePayload(partialUpdateZonePayload PartialUpdateZonePayload) ApiPartialUpdateZoneRequest
	Execute() (*ZoneResponse, error)
}

type ApiRestoreRecordSetRequest interface {
	Execute() (*Message, error)
}

type ApiRestoreZoneRequest interface {
	Execute() (*Message, error)
}

type ApiRetrieveZoneRequest interface {
	Execute() (*Message, error)
}

type ApiValidateMoveCodeRequest interface {
	// information about the move
	ValidateMoveCodePayload(validateMoveCodePayload ValidateMoveCodePayload) ApiValidateMoveCodeRequest
	Execute() (*Message, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CloneZoneRequest struct {
	ctx              context.Context
	apiService       *DefaultApiService
	projectId        string
	zoneId           string
	cloneZonePayload *CloneZonePayload
}

// zone to clone

func (r CloneZoneRequest) CloneZonePayload(cloneZonePayload CloneZonePayload) ApiCloneZoneRequest {
	r.cloneZonePayload = &cloneZonePayload
	return r
}

func (r CloneZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CloneZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloneZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("cloneZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloneZonePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CloneZone: Clone an existing zone with all record sets to a new zone with a different name

Clone an existing zone with all record sets to a new zone with a different name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCloneZoneRequest
*/
func (a *APIClient) CloneZone(ctx context.Context, projectId string, zoneId string) ApiCloneZoneRequest {
	return CloneZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CloneZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := CloneZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type CreateLabelRequest struct {
	ctx                context.Context
	apiService         *DefaultApiService
	projectId          string
	zoneId             string
	createLabelPayload *CreateLabelPayload
}

// record set to create

func (r CreateLabelRequest) CreateLabelPayload(createLabelPayload CreateLabelPayload) ApiCreateLabelRequest {
	r.createLabelPayload = &createLabelPayload
	return r
}

func (r CreateLabelRequest) Execute() (*CreateLabelResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateLabelResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateLabel")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLabelPayload == nil {
		return localVarReturnValue, fmt.Errorf("createLabelPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLabelPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateLabel: Create or update label

Create or update label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateLabelRequest
*/
func (a *APIClient) CreateLabel(ctx context.Context, projectId string, zoneId string) ApiCreateLabelRequest {
	return CreateLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateLabelExecute(ctx context.Context, projectId string, zoneId string) (*CreateLabelResponse, error) {
	r := CreateLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type CreateMoveCodeRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r CreateMoveCodeRequest) Execute() (*MoveCodeResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MoveCodeResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMoveCode")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/move-code"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateMoveCode: request a move code to move zone to another project

move zone from one project to another

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateMoveCodeRequest
*/
func (a *APIClient) CreateMoveCode(ctx context.Context, projectId string, zoneId string) ApiCreateMoveCodeRequest {
	return CreateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*MoveCodeResponse, error) {
	r := CreateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type CreateRecordSetRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	zoneId                 string
	createRecordSetPayload *CreateRecordSetPayload
}

// record set to create

func (r CreateRecordSetRequest) CreateRecordSetPayload(createRecordSetPayload CreateRecordSetPayload) ApiCreateRecordSetRequest {
	r.createRecordSetPayload = &createRecordSetPayload
	return r
}

func (r CreateRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("createRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRecordSetPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateRecordSet: Post record set

Post record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateRecordSetRequest
*/
func (a *APIClient) CreateRecordSet(ctx context.Context, projectId string, zoneId string) ApiCreateRecordSetRequest {
	return CreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateRecordSetExecute(ctx context.Context, projectId string, zoneId string) (*RecordSetResponse, error) {
	r := CreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type CreateZoneRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	createZonePayload *CreateZonePayload
}

// zone to create

func (r CreateZoneRequest) CreateZonePayload(createZonePayload CreateZonePayload) ApiCreateZoneRequest {
	r.createZonePayload = &createZonePayload
	return r
}

func (r CreateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("createZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createZonePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateZone: Post create a new zone

Post zone create a new zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiCreateZoneRequest
*/
func (a *APIClient) CreateZone(ctx context.Context, projectId string) ApiCreateZoneRequest {
	return CreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) CreateZoneExecute(ctx context.Context, projectId string) (*ZoneResponse, error) {
	r := CreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type DeleteLabelRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	key        string
}

func (r DeleteLabelRequest) Execute() (*DeleteLabelResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteLabelResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteLabel")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(ParameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteLabel: Delete a label

Delete a label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param key key of the label
	@return ApiDeleteLabelRequest
*/
func (a *APIClient) DeleteLabel(ctx context.Context, projectId string, zoneId string, key string) ApiDeleteLabelRequest {
	return DeleteLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		key:        key,
	}
}

func (a *APIClient) DeleteLabelExecute(ctx context.Context, projectId string, zoneId string, key string) (*DeleteLabelResponse, error) {
	r := DeleteLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		key:        key,
	}
	return r.Execute()
}

type DeleteMoveCodeRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r DeleteMoveCodeRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteMoveCode")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/move-code"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteMoveCode: delete/invalidate a move code

delete/invalidate a move code

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiDeleteMoveCodeRequest
*/
func (a *APIClient) DeleteMoveCode(ctx context.Context, projectId string, zoneId string) ApiDeleteMoveCodeRequest {
	return DeleteMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) DeleteMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := DeleteMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type DeleteRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r DeleteRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteRecordSet: Delete a record set

Delete a record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiDeleteRecordSetRequest
*/
func (a *APIClient) DeleteRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiDeleteRecordSetRequest {
	return DeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) DeleteRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := DeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type DeleteZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r DeleteZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteZone: Delete a zone

Delete a zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiDeleteZoneRequest
*/
func (a *APIClient) DeleteZone(ctx context.Context, projectId string, zoneId string) ApiDeleteZoneRequest {
	return DeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) DeleteZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := DeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ExportRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	exportRecordSetsPayload *ExportRecordSetsPayload
}

// export configuration

func (r ExportRecordSetsRequest) ExportRecordSetsPayload(exportRecordSetsPayload ExportRecordSetsPayload) ApiExportRecordSetsRequest {
	r.exportRecordSetsPayload = &exportRecordSetsPayload
	return r
}

func (r ExportRecordSetsRequest) Execute() (*ZoneDataExchange, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneDataExchange
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ExportRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exportRecordSetsPayload == nil {
		return localVarReturnValue, fmt.Errorf("exportRecordSetsPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportRecordSetsPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ExportRecordSets: Export all records in a single zone

Export Zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiExportRecordSetsRequest
*/
func (a *APIClient) ExportRecordSets(ctx context.Context, projectId string, zoneId string) ApiExportRecordSetsRequest {
	return ExportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ExportRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ZoneDataExchange, error) {
	r := ExportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type GetRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r GetRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRecordSet: Get a single rrset

Get rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiGetRecordSetRequest
*/
func (a *APIClient) GetRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiGetRecordSetRequest {
	return GetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) GetRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*RecordSetResponse, error) {
	r := GetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type GetZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r GetZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetZone: Get a single zone

Get zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiGetZoneRequest
*/
func (a *APIClient) GetZone(ctx context.Context, projectId string, zoneId string) ApiGetZoneRequest {
	return GetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) GetZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := GetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ImportRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	importRecordSetsPayload *ImportRecordSetsPayload
	format                  *string
	importType              *string
}

// accepts all response bodies for the export endpoint

func (r ImportRecordSetsRequest) ImportRecordSetsPayload(importRecordSetsPayload ImportRecordSetsPayload) ApiImportRecordSetsRequest {
	r.importRecordSetsPayload = &importRecordSetsPayload
	return r
}

// format of the data to import

func (r ImportRecordSetsRequest) Format(format string) ApiImportRecordSetsRequest {
	r.format = &format
	return r
}

// type of the zone import

func (r ImportRecordSetsRequest) ImportType(importType string) ApiImportRecordSetsRequest {
	r.importType = &importType
	return r
}

func (r ImportRecordSetsRequest) Execute() (*ImportRecordSetsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImportRecordSetsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ImportRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/import"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importRecordSetsPayload == nil {
		return localVarReturnValue, fmt.Errorf("importRecordSetsPayload is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.importType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importType", r.importType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importRecordSetsPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ImportRecordSets: Imports a zone

Imports a zone and overwrites/deletes/inserts all desired records

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiImportRecordSetsRequest
*/
func (a *APIClient) ImportRecordSets(ctx context.Context, projectId string, zoneId string) ApiImportRecordSetsRequest {
	return ImportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ImportRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ImportRecordSetsResponse, error) {
	r := ImportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ListLabelsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ListLabelsRequest) Execute() (*ListLabelsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListLabelsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListLabels")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListLabels: Get all labels

All Labels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiListLabelsRequest
*/
func (a *APIClient) ListLabels(ctx context.Context, projectId string, zoneId string) ApiListLabelsRequest {
	return ListLabelsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ListLabelsExecute(ctx context.Context, projectId string, zoneId string) (*ListLabelsResponse, error) {
	r := ListLabelsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ListRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	page                    *int32
	pageSize                *int32
	nameEq                  *string
	nameLike                *string
	typeEq                  *string
	stateEq                 *string
	stateNeq                *string
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	orderByName             *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
	orderByType             *string
	orderByState            *string
	orderByRecordCount      *string
}

// page

func (r ListRecordSetsRequest) Page(page int32) ApiListRecordSetsRequest {
	r.page = &page
	return r
}

// page size

func (r ListRecordSetsRequest) PageSize(pageSize int32) ApiListRecordSetsRequest {
	r.pageSize = &pageSize
	return r
}

// filter name equal

func (r ListRecordSetsRequest) NameEq(nameEq string) ApiListRecordSetsRequest {
	r.nameEq = &nameEq
	return r
}

// filter name like

func (r ListRecordSetsRequest) NameLike(nameLike string) ApiListRecordSetsRequest {
	r.nameLike = &nameLike
	return r
}

// filter type

func (r ListRecordSetsRequest) TypeEq(typeEq string) ApiListRecordSetsRequest {
	r.typeEq = &typeEq
	return r
}

// filter state

func (r ListRecordSetsRequest) StateEq(stateEq string) ApiListRecordSetsRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ListRecordSetsRequest) StateNeq(stateNeq string) ApiListRecordSetsRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter active equal

func (r ListRecordSetsRequest) ActiveEq(activeEq bool) ApiListRecordSetsRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ListRecordSetsRequest) CreationStartedGt(creationStartedGt string) ApiListRecordSetsRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ListRecordSetsRequest) CreationStartedLt(creationStartedLt string) ApiListRecordSetsRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ListRecordSetsRequest) CreationStartedGte(creationStartedGte string) ApiListRecordSetsRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ListRecordSetsRequest) CreationStartedLte(creationStartedLte string) ApiListRecordSetsRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ListRecordSetsRequest) CreationFinishedGt(creationFinishedGt string) ApiListRecordSetsRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ListRecordSetsRequest) CreationFinishedLt(creationFinishedLt string) ApiListRecordSetsRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ListRecordSetsRequest) CreationFinishedGte(creationFinishedGte string) ApiListRecordSetsRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ListRecordSetsRequest) CreationFinishedLte(creationFinishedLte string) ApiListRecordSetsRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ListRecordSetsRequest) UpdateStartedGt(updateStartedGt string) ApiListRecordSetsRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ListRecordSetsRequest) UpdateStartedLt(updateStartedLt string) ApiListRecordSetsRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ListRecordSetsRequest) UpdateStartedGte(updateStartedGte string) ApiListRecordSetsRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ListRecordSetsRequest) UpdateStartedLte(updateStartedLte string) ApiListRecordSetsRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ListRecordSetsRequest) UpdateFinishedGt(updateFinishedGt string) ApiListRecordSetsRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ListRecordSetsRequest) UpdateFinishedLt(updateFinishedLt string) ApiListRecordSetsRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ListRecordSetsRequest) UpdateFinishedGte(updateFinishedGte string) ApiListRecordSetsRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ListRecordSetsRequest) UpdateFinishedLte(updateFinishedLte string) ApiListRecordSetsRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// order by name

func (r ListRecordSetsRequest) OrderByName(orderByName string) ApiListRecordSetsRequest {
	r.orderByName = &orderByName
	return r
}

// order by creationStarted

func (r ListRecordSetsRequest) OrderByCreationStarted(orderByCreationStarted string) ApiListRecordSetsRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ListRecordSetsRequest) OrderByCreationFinished(orderByCreationFinished string) ApiListRecordSetsRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ListRecordSetsRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiListRecordSetsRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ListRecordSetsRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiListRecordSetsRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

// order by type

func (r ListRecordSetsRequest) OrderByType(orderByType string) ApiListRecordSetsRequest {
	r.orderByType = &orderByType
	return r
}

// order by state

func (r ListRecordSetsRequest) OrderByState(orderByState string) ApiListRecordSetsRequest {
	r.orderByState = &orderByState
	return r
}

// order by record count

func (r ListRecordSetsRequest) OrderByRecordCount(orderByRecordCount string) ApiListRecordSetsRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

func (r ListRecordSetsRequest) Execute() (*ListRecordSetsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRecordSetsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[state]", r.orderByState, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRecordSets: All get selected RRSets

All RRSet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiListRecordSetsRequest
*/
func (a *APIClient) ListRecordSets(ctx context.Context, projectId string, zoneId string) ApiListRecordSetsRequest {
	return ListRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ListRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ListRecordSetsResponse, error) {
	r := ListRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ListZonesRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	page                    *int32
	pageSize                *int32
	dnsNameEq               *string
	dnsNameLike             *string
	typeEq                  *string
	nameEq                  *string
	nameNeq                 *string
	nameLike                *string
	descriptionEq           *string
	descriptionNeq          *string
	descriptionLike         *string
	stateEq                 *string
	stateNeq                *string
	primaryNameServerEq     *string
	primaryNameServerLike   *string
	isReverseZoneEq         *bool
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	labelKeyEq              *[]string
	labelValueEq            *[]string
	orderByDnsName          *string
	orderByName             *string
	orderByRecordCount      *string
	orderByType             *string
	orderByDescription      *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
}

// page

func (r ListZonesRequest) Page(page int32) ApiListZonesRequest {
	r.page = &page
	return r
}

// page size

func (r ListZonesRequest) PageSize(pageSize int32) ApiListZonesRequest {
	r.pageSize = &pageSize
	return r
}

// filter dns name equal

func (r ListZonesRequest) DnsNameEq(dnsNameEq string) ApiListZonesRequest {
	r.dnsNameEq = &dnsNameEq
	return r
}

// filter dns name like

func (r ListZonesRequest) DnsNameLike(dnsNameLike string) ApiListZonesRequest {
	r.dnsNameLike = &dnsNameLike
	return r
}

// filter type

func (r ListZonesRequest) TypeEq(typeEq string) ApiListZonesRequest {
	r.typeEq = &typeEq
	return r
}

// filter name equal

func (r ListZonesRequest) NameEq(nameEq string) ApiListZonesRequest {
	r.nameEq = &nameEq
	return r
}

// filter name not equal

func (r ListZonesRequest) NameNeq(nameNeq string) ApiListZonesRequest {
	r.nameNeq = &nameNeq
	return r
}

// filter name like

func (r ListZonesRequest) NameLike(nameLike string) ApiListZonesRequest {
	r.nameLike = &nameLike
	return r
}

// filter description equal

func (r ListZonesRequest) DescriptionEq(descriptionEq string) ApiListZonesRequest {
	r.descriptionEq = &descriptionEq
	return r
}

// filter description not equal

func (r ListZonesRequest) DescriptionNeq(descriptionNeq string) ApiListZonesRequest {
	r.descriptionNeq = &descriptionNeq
	return r
}

// filter description like

func (r ListZonesRequest) DescriptionLike(descriptionLike string) ApiListZonesRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// filter state

func (r ListZonesRequest) StateEq(stateEq string) ApiListZonesRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ListZonesRequest) StateNeq(stateNeq string) ApiListZonesRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter primary name server equal

func (r ListZonesRequest) PrimaryNameServerEq(primaryNameServerEq string) ApiListZonesRequest {
	r.primaryNameServerEq = &primaryNameServerEq
	return r
}

// filter primary name server like

func (r ListZonesRequest) PrimaryNameServerLike(primaryNameServerLike string) ApiListZonesRequest {
	r.primaryNameServerLike = &primaryNameServerLike
	return r
}

// filter reverse zone equal

func (r ListZonesRequest) IsReverseZoneEq(isReverseZoneEq bool) ApiListZonesRequest {
	r.isReverseZoneEq = &isReverseZoneEq
	return r
}

// filter active equal

func (r ListZonesRequest) ActiveEq(activeEq bool) ApiListZonesRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ListZonesRequest) CreationStartedGt(creationStartedGt string) ApiListZonesRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ListZonesRequest) CreationStartedLt(creationStartedLt string) ApiListZonesRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ListZonesRequest) CreationStartedGte(creationStartedGte string) ApiListZonesRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ListZonesRequest) CreationStartedLte(creationStartedLte string) ApiListZonesRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ListZonesRequest) CreationFinishedGt(creationFinishedGt string) ApiListZonesRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ListZonesRequest) CreationFinishedLt(creationFinishedLt string) ApiListZonesRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ListZonesRequest) CreationFinishedGte(creationFinishedGte string) ApiListZonesRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ListZonesRequest) CreationFinishedLte(creationFinishedLte string) ApiListZonesRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ListZonesRequest) UpdateStartedGt(updateStartedGt string) ApiListZonesRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ListZonesRequest) UpdateStartedLt(updateStartedLt string) ApiListZonesRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ListZonesRequest) UpdateStartedGte(updateStartedGte string) ApiListZonesRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ListZonesRequest) UpdateStartedLte(updateStartedLte string) ApiListZonesRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ListZonesRequest) UpdateFinishedGt(updateFinishedGt string) ApiListZonesRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ListZonesRequest) UpdateFinishedLt(updateFinishedLt string) ApiListZonesRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ListZonesRequest) UpdateFinishedGte(updateFinishedGte string) ApiListZonesRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ListZonesRequest) UpdateFinishedLte(updateFinishedLte string) ApiListZonesRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// filter zones according to the zone label keys.

func (r ListZonesRequest) LabelKeyEq(labelKeyEq []string) ApiListZonesRequest {
	r.labelKeyEq = &labelKeyEq
	return r
}

// filter zones according to the zone label values.

func (r ListZonesRequest) LabelValueEq(labelValueEq []string) ApiListZonesRequest {
	r.labelValueEq = &labelValueEq
	return r
}

// order by dns name

func (r ListZonesRequest) OrderByDnsName(orderByDnsName string) ApiListZonesRequest {
	r.orderByDnsName = &orderByDnsName
	return r
}

// order by name

func (r ListZonesRequest) OrderByName(orderByName string) ApiListZonesRequest {
	r.orderByName = &orderByName
	return r
}

// order by record count

func (r ListZonesRequest) OrderByRecordCount(orderByRecordCount string) ApiListZonesRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

// order by type

func (r ListZonesRequest) OrderByType(orderByType string) ApiListZonesRequest {
	r.orderByType = &orderByType
	return r
}

// order by description

func (r ListZonesRequest) OrderByDescription(orderByDescription string) ApiListZonesRequest {
	r.orderByDescription = &orderByDescription
	return r
}

// order by creationStarted

func (r ListZonesRequest) OrderByCreationStarted(orderByCreationStarted string) ApiListZonesRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ListZonesRequest) OrderByCreationFinished(orderByCreationFinished string) ApiListZonesRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ListZonesRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiListZonesRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ListZonesRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiListZonesRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

func (r ListZonesRequest) Execute() (*ListZonesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListZonesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListZones")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.dnsNameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[eq]", r.dnsNameEq, "")
	}
	if r.dnsNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[like]", r.dnsNameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[neq]", r.nameNeq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.descriptionEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[eq]", r.descriptionEq, "")
	}
	if r.descriptionNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[neq]", r.descriptionNeq, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[like]", r.descriptionLike, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.primaryNameServerEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[eq]", r.primaryNameServerEq, "")
	}
	if r.primaryNameServerLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[like]", r.primaryNameServerLike, "")
	}
	if r.isReverseZoneEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isReverseZone[eq]", r.isReverseZoneEq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.labelKeyEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelKey[eq]", r.labelKeyEq, "csv")
	}
	if r.labelValueEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelValue[eq]", r.labelValueEq, "csv")
	}
	if r.orderByDnsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[dnsName]", r.orderByDnsName, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[description]", r.orderByDescription, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListZones: All get selected zones

All zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiListZonesRequest
*/
func (a *APIClient) ListZones(ctx context.Context, projectId string) ApiListZonesRequest {
	return ListZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListZonesExecute(ctx context.Context, projectId string) (*ListZonesResponse, error) {
	r := ListZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type MoveZoneRequest struct {
	ctx             context.Context
	apiService      *DefaultApiService
	projectId       string
	moveZonePayload *MoveZonePayload
}

// information about the move

func (r MoveZoneRequest) MoveZonePayload(moveZonePayload MoveZonePayload) ApiMoveZoneRequest {
	r.moveZonePayload = &moveZonePayload
	return r
}

func (r MoveZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MoveZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/move-zone"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("moveZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveZonePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
MoveZone: move zone from one project to another

move zone from one project to another

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiMoveZoneRequest
*/
func (a *APIClient) MoveZone(ctx context.Context, projectId string) ApiMoveZoneRequest {
	return MoveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) MoveZoneExecute(ctx context.Context, projectId string) (*Message, error) {
	r := MoveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type PartialUpdateRecordRequest struct {
	ctx                        context.Context
	apiService                 *DefaultApiService
	projectId                  string
	zoneId                     string
	rrSetId                    string
	partialUpdateRecordPayload *PartialUpdateRecordPayload
}

// rrset to update

func (r PartialUpdateRecordRequest) PartialUpdateRecordPayload(partialUpdateRecordPayload PartialUpdateRecordPayload) ApiPartialUpdateRecordRequest {
	r.partialUpdateRecordPayload = &partialUpdateRecordPayload
	return r
}

func (r PartialUpdateRecordRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateRecord")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateRecordPayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateRecordPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateRecordPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateRecord: PatchRecords updates a record in a rrset

PatchRecords rrset updates a record in a rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiPartialUpdateRecordRequest
*/
func (a *APIClient) PartialUpdateRecord(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordRequest {
	return PartialUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) PartialUpdateRecordExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := PartialUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type PartialUpdateRecordSetRequest struct {
	ctx                           context.Context
	apiService                    *DefaultApiService
	projectId                     string
	zoneId                        string
	rrSetId                       string
	partialUpdateRecordSetPayload *PartialUpdateRecordSetPayload
}

// record set to patch

func (r PartialUpdateRecordSetRequest) PartialUpdateRecordSetPayload(partialUpdateRecordSetPayload PartialUpdateRecordSetPayload) ApiPartialUpdateRecordSetRequest {
	r.partialUpdateRecordSetPayload = &partialUpdateRecordSetPayload
	return r
}

func (r PartialUpdateRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateRecordSetPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateRecordSet: Patch updates a record set

Patch record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiPartialUpdateRecordSetRequest
*/
func (a *APIClient) PartialUpdateRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordSetRequest {
	return PartialUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) PartialUpdateRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := PartialUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type PartialUpdateZoneRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	zoneId                   string
	partialUpdateZonePayload *PartialUpdateZonePayload
}

// zone to update

func (r PartialUpdateZoneRequest) PartialUpdateZonePayload(partialUpdateZonePayload PartialUpdateZonePayload) ApiPartialUpdateZoneRequest {
	r.partialUpdateZonePayload = &partialUpdateZonePayload
	return r
}

func (r PartialUpdateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateZonePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateZone: Patch update an existing zone

Patch update an existing zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiPartialUpdateZoneRequest
*/
func (a *APIClient) PartialUpdateZone(ctx context.Context, projectId string, zoneId string) ApiPartialUpdateZoneRequest {
	return PartialUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) PartialUpdateZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := PartialUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type RestoreRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r RestoreRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RestoreRecordSet: Restore record set

Restore record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiRestoreRecordSetRequest
*/
func (a *APIClient) RestoreRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiRestoreRecordSetRequest {
	return RestoreRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) RestoreRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := RestoreRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type RestoreZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r RestoreZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RestoreZone: Restore  an inactive zone

Restore  an inactive zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiRestoreZoneRequest
*/
func (a *APIClient) RestoreZone(ctx context.Context, projectId string, zoneId string) ApiRestoreZoneRequest {
	return RestoreZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) RestoreZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := RestoreZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type RetrieveZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r RetrieveZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RetrieveZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/retrieve"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RetrieveZone: Queue secondary zone for a zone transfer request.

The zone transfer will usually be performed within a few seconds, and will be tried only once by randomly choosing one of the configured primary name servers. If that single attempt fails, no further attempt will be performed. The zone will be transferred to our inbound name server regardless of its serial, but the internal zone distribution is only reliable if the zone's serial on the customer's primary name server is higher than on the STACKIT name server. <br>NOTE: As said above, this endpoint is not a reliable way to decrease a zone's serial. To guarantee consistent zones over all STACKIT location, the zone's serial MUST always be increased on zone changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiRetrieveZoneRequest
*/
func (a *APIClient) RetrieveZone(ctx context.Context, projectId string, zoneId string) ApiRetrieveZoneRequest {
	return RetrieveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) RetrieveZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := RetrieveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ValidateMoveCodeRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	validateMoveCodePayload *ValidateMoveCodePayload
}

// information about the move

func (r ValidateMoveCodeRequest) ValidateMoveCodePayload(validateMoveCodePayload ValidateMoveCodePayload) ApiValidateMoveCodeRequest {
	r.validateMoveCodePayload = &validateMoveCodePayload
	return r
}

func (r ValidateMoveCodeRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ValidateMoveCode")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/move-code-validation"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateMoveCodePayload == nil {
		return localVarReturnValue, fmt.Errorf("validateMoveCodePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateMoveCodePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ValidateMoveCode: validate the move code is still valid for the zone

validate the move code is still valid for the zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiValidateMoveCodeRequest
*/
func (a *APIClient) ValidateMoveCode(ctx context.Context, projectId string, zoneId string) ApiValidateMoveCodeRequest {
	return ValidateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ValidateMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ValidateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}
