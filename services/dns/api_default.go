/*
STACKIT DNS API

This api provides dns

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateRecordSetRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	zoneId                 string
	createRecordSetPayload *CreateRecordSetPayload
}

// record set to create

func (r ApiCreateRecordSetRequest) CreateRecordSetPayload(createRecordSetPayload CreateRecordSetPayload) ApiCreateRecordSetRequest {
	r.createRecordSetPayload = &createRecordSetPayload
	return r
}

func (r ApiCreateRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateRecordSet")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("createRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRecordSetPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateRecordSet Post record set

Post record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateRecordSetRequest
*/
func (a *APIClient) CreateRecordSet(ctx context.Context, projectId string, zoneId string) ApiCreateRecordSetRequest {
	return ApiCreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateRecordSetExecute(ctx context.Context, projectId string, zoneId string) (*RecordSetResponse, error) {
	r := ApiCreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiCreateZoneRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	createZonePayload *CreateZonePayload
}

// zone to create

func (r ApiCreateZoneRequest) CreateZonePayload(createZonePayload CreateZonePayload) ApiCreateZoneRequest {
	r.createZonePayload = &createZonePayload
	return r
}

func (r ApiCreateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateZone")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("createZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateZone Post create a new zone

Post zone create a new zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiCreateZoneRequest
*/
func (a *APIClient) CreateZone(ctx context.Context, projectId string) ApiCreateZoneRequest {
	return ApiCreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) CreateZoneExecute(ctx context.Context, projectId string) (*ZoneResponse, error) {
	r := ApiCreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiDeleteRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiDeleteRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordSet")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteRecordSet Delete a record set

Delete a record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiDeleteRecordSetRequest
*/
func (a *APIClient) DeleteRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiDeleteRecordSetRequest {
	return ApiDeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) DeleteRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiDeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiDeleteZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiDeleteZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteZone")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteZone Delete a zone

Delete a zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiDeleteZoneRequest
*/
func (a *APIClient) DeleteZone(ctx context.Context, projectId string, zoneId string) ApiDeleteZoneRequest {
	return ApiDeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) DeleteZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiDeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiGetRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiGetRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRecordSet")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRecordSet Get a single rrset

Get rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiGetRecordSetRequest
*/
func (a *APIClient) GetRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiGetRecordSetRequest {
	return ApiGetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) GetRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*RecordSetResponse, error) {
	r := ApiGetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiGetRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	page                    *int32
	pageSize                *int32
	nameEq                  *string
	nameLike                *string
	typeEq                  *string
	stateEq                 *string
	stateNeq                *string
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	orderByName             *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
	orderByType             *string
	orderByState            *string
	orderByRecordCount      *string
}

// page

func (r ApiGetRecordSetsRequest) Page(page int32) ApiGetRecordSetsRequest {
	r.page = &page
	return r
}

// page size

func (r ApiGetRecordSetsRequest) PageSize(pageSize int32) ApiGetRecordSetsRequest {
	r.pageSize = &pageSize
	return r
}

// filter name equal

func (r ApiGetRecordSetsRequest) NameEq(nameEq string) ApiGetRecordSetsRequest {
	r.nameEq = &nameEq
	return r
}

// filter name like

func (r ApiGetRecordSetsRequest) NameLike(nameLike string) ApiGetRecordSetsRequest {
	r.nameLike = &nameLike
	return r
}

// filter type

func (r ApiGetRecordSetsRequest) TypeEq(typeEq string) ApiGetRecordSetsRequest {
	r.typeEq = &typeEq
	return r
}

// filter state

func (r ApiGetRecordSetsRequest) StateEq(stateEq string) ApiGetRecordSetsRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ApiGetRecordSetsRequest) StateNeq(stateNeq string) ApiGetRecordSetsRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter active equal

func (r ApiGetRecordSetsRequest) ActiveEq(activeEq bool) ApiGetRecordSetsRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ApiGetRecordSetsRequest) CreationStartedGt(creationStartedGt string) ApiGetRecordSetsRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ApiGetRecordSetsRequest) CreationStartedLt(creationStartedLt string) ApiGetRecordSetsRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ApiGetRecordSetsRequest) CreationStartedGte(creationStartedGte string) ApiGetRecordSetsRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ApiGetRecordSetsRequest) CreationStartedLte(creationStartedLte string) ApiGetRecordSetsRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ApiGetRecordSetsRequest) CreationFinishedGt(creationFinishedGt string) ApiGetRecordSetsRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ApiGetRecordSetsRequest) CreationFinishedLt(creationFinishedLt string) ApiGetRecordSetsRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ApiGetRecordSetsRequest) CreationFinishedGte(creationFinishedGte string) ApiGetRecordSetsRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ApiGetRecordSetsRequest) CreationFinishedLte(creationFinishedLte string) ApiGetRecordSetsRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateStartedGt(updateStartedGt string) ApiGetRecordSetsRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateStartedLt(updateStartedLt string) ApiGetRecordSetsRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateStartedGte(updateStartedGte string) ApiGetRecordSetsRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateStartedLte(updateStartedLte string) ApiGetRecordSetsRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateFinishedGt(updateFinishedGt string) ApiGetRecordSetsRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateFinishedLt(updateFinishedLt string) ApiGetRecordSetsRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateFinishedGte(updateFinishedGte string) ApiGetRecordSetsRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ApiGetRecordSetsRequest) UpdateFinishedLte(updateFinishedLte string) ApiGetRecordSetsRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// order by name

func (r ApiGetRecordSetsRequest) OrderByName(orderByName string) ApiGetRecordSetsRequest {
	r.orderByName = &orderByName
	return r
}

// order by creationStarted

func (r ApiGetRecordSetsRequest) OrderByCreationStarted(orderByCreationStarted string) ApiGetRecordSetsRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ApiGetRecordSetsRequest) OrderByCreationFinished(orderByCreationFinished string) ApiGetRecordSetsRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ApiGetRecordSetsRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiGetRecordSetsRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ApiGetRecordSetsRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiGetRecordSetsRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

// order by type

func (r ApiGetRecordSetsRequest) OrderByType(orderByType string) ApiGetRecordSetsRequest {
	r.orderByType = &orderByType
	return r
}

// order by state

func (r ApiGetRecordSetsRequest) OrderByState(orderByState string) ApiGetRecordSetsRequest {
	r.orderByState = &orderByState
	return r
}

// order by record count

func (r ApiGetRecordSetsRequest) OrderByRecordCount(orderByRecordCount string) ApiGetRecordSetsRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

func (r ApiGetRecordSetsRequest) Execute() (*RecordSetsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetsResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRecordSets")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[state]", r.orderByState, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRecordSets All get selected RRSets

All RRSet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiGetRecordSetsRequest
*/
func (a *APIClient) GetRecordSets(ctx context.Context, projectId string, zoneId string) ApiGetRecordSetsRequest {
	return ApiGetRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) GetRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*RecordSetsResponse, error) {
	r := ApiGetRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiGetZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiGetZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetZone")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetZone Get a single zone

Get zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiGetZoneRequest
*/
func (a *APIClient) GetZone(ctx context.Context, projectId string, zoneId string) ApiGetZoneRequest {
	return ApiGetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) GetZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiGetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiGetZonesRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	page                    *int32
	pageSize                *int32
	dnsNameEq               *string
	dnsNameLike             *string
	typeEq                  *string
	nameEq                  *string
	nameNeq                 *string
	nameLike                *string
	descriptionEq           *string
	descriptionNeq          *string
	descriptionLike         *string
	stateEq                 *string
	stateNeq                *string
	primaryNameServerEq     *string
	primaryNameServerLike   *string
	isReverseZoneEq         *bool
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	orderByDnsName          *string
	orderByName             *string
	orderByRecordCount      *string
	orderByType             *string
	orderByDescription      *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
}

// page

func (r ApiGetZonesRequest) Page(page int32) ApiGetZonesRequest {
	r.page = &page
	return r
}

// page size

func (r ApiGetZonesRequest) PageSize(pageSize int32) ApiGetZonesRequest {
	r.pageSize = &pageSize
	return r
}

// filter dns name equal

func (r ApiGetZonesRequest) DnsNameEq(dnsNameEq string) ApiGetZonesRequest {
	r.dnsNameEq = &dnsNameEq
	return r
}

// filter dns name like

func (r ApiGetZonesRequest) DnsNameLike(dnsNameLike string) ApiGetZonesRequest {
	r.dnsNameLike = &dnsNameLike
	return r
}

// filter type

func (r ApiGetZonesRequest) TypeEq(typeEq string) ApiGetZonesRequest {
	r.typeEq = &typeEq
	return r
}

// filter name equal

func (r ApiGetZonesRequest) NameEq(nameEq string) ApiGetZonesRequest {
	r.nameEq = &nameEq
	return r
}

// filter name not equal

func (r ApiGetZonesRequest) NameNeq(nameNeq string) ApiGetZonesRequest {
	r.nameNeq = &nameNeq
	return r
}

// filter name like

func (r ApiGetZonesRequest) NameLike(nameLike string) ApiGetZonesRequest {
	r.nameLike = &nameLike
	return r
}

// filter description equal

func (r ApiGetZonesRequest) DescriptionEq(descriptionEq string) ApiGetZonesRequest {
	r.descriptionEq = &descriptionEq
	return r
}

// filter description not equal

func (r ApiGetZonesRequest) DescriptionNeq(descriptionNeq string) ApiGetZonesRequest {
	r.descriptionNeq = &descriptionNeq
	return r
}

// filter description like

func (r ApiGetZonesRequest) DescriptionLike(descriptionLike string) ApiGetZonesRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// filter state

func (r ApiGetZonesRequest) StateEq(stateEq string) ApiGetZonesRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ApiGetZonesRequest) StateNeq(stateNeq string) ApiGetZonesRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter primary name server equal

func (r ApiGetZonesRequest) PrimaryNameServerEq(primaryNameServerEq string) ApiGetZonesRequest {
	r.primaryNameServerEq = &primaryNameServerEq
	return r
}

// filter primary name server like

func (r ApiGetZonesRequest) PrimaryNameServerLike(primaryNameServerLike string) ApiGetZonesRequest {
	r.primaryNameServerLike = &primaryNameServerLike
	return r
}

// filter reverse zone equal

func (r ApiGetZonesRequest) IsReverseZoneEq(isReverseZoneEq bool) ApiGetZonesRequest {
	r.isReverseZoneEq = &isReverseZoneEq
	return r
}

// filter active equal

func (r ApiGetZonesRequest) ActiveEq(activeEq bool) ApiGetZonesRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ApiGetZonesRequest) CreationStartedGt(creationStartedGt string) ApiGetZonesRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ApiGetZonesRequest) CreationStartedLt(creationStartedLt string) ApiGetZonesRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ApiGetZonesRequest) CreationStartedGte(creationStartedGte string) ApiGetZonesRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ApiGetZonesRequest) CreationStartedLte(creationStartedLte string) ApiGetZonesRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ApiGetZonesRequest) CreationFinishedGt(creationFinishedGt string) ApiGetZonesRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ApiGetZonesRequest) CreationFinishedLt(creationFinishedLt string) ApiGetZonesRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ApiGetZonesRequest) CreationFinishedGte(creationFinishedGte string) ApiGetZonesRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ApiGetZonesRequest) CreationFinishedLte(creationFinishedLte string) ApiGetZonesRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ApiGetZonesRequest) UpdateStartedGt(updateStartedGt string) ApiGetZonesRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ApiGetZonesRequest) UpdateStartedLt(updateStartedLt string) ApiGetZonesRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ApiGetZonesRequest) UpdateStartedGte(updateStartedGte string) ApiGetZonesRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ApiGetZonesRequest) UpdateStartedLte(updateStartedLte string) ApiGetZonesRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ApiGetZonesRequest) UpdateFinishedGt(updateFinishedGt string) ApiGetZonesRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ApiGetZonesRequest) UpdateFinishedLt(updateFinishedLt string) ApiGetZonesRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ApiGetZonesRequest) UpdateFinishedGte(updateFinishedGte string) ApiGetZonesRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ApiGetZonesRequest) UpdateFinishedLte(updateFinishedLte string) ApiGetZonesRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// order by dns name

func (r ApiGetZonesRequest) OrderByDnsName(orderByDnsName string) ApiGetZonesRequest {
	r.orderByDnsName = &orderByDnsName
	return r
}

// order by name

func (r ApiGetZonesRequest) OrderByName(orderByName string) ApiGetZonesRequest {
	r.orderByName = &orderByName
	return r
}

// order by record count

func (r ApiGetZonesRequest) OrderByRecordCount(orderByRecordCount string) ApiGetZonesRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

// order by type

func (r ApiGetZonesRequest) OrderByType(orderByType string) ApiGetZonesRequest {
	r.orderByType = &orderByType
	return r
}

// order by description

func (r ApiGetZonesRequest) OrderByDescription(orderByDescription string) ApiGetZonesRequest {
	r.orderByDescription = &orderByDescription
	return r
}

// order by creationStarted

func (r ApiGetZonesRequest) OrderByCreationStarted(orderByCreationStarted string) ApiGetZonesRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ApiGetZonesRequest) OrderByCreationFinished(orderByCreationFinished string) ApiGetZonesRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ApiGetZonesRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiGetZonesRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ApiGetZonesRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiGetZonesRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

func (r ApiGetZonesRequest) Execute() (*ZonesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZonesResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetZones")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.dnsNameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[eq]", r.dnsNameEq, "")
	}
	if r.dnsNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[like]", r.dnsNameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[neq]", r.nameNeq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.descriptionEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[eq]", r.descriptionEq, "")
	}
	if r.descriptionNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[neq]", r.descriptionNeq, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[like]", r.descriptionLike, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.primaryNameServerEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[eq]", r.primaryNameServerEq, "")
	}
	if r.primaryNameServerLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[like]", r.primaryNameServerLike, "")
	}
	if r.isReverseZoneEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isReverseZone[eq]", r.isReverseZoneEq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.orderByDnsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[dnsName]", r.orderByDnsName, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[description]", r.orderByDescription, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetZones All get selected zones

All zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiGetZonesRequest
*/
func (a *APIClient) GetZones(ctx context.Context, projectId string) ApiGetZonesRequest {
	return ApiGetZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) GetZonesExecute(ctx context.Context, projectId string) (*ZonesResponse, error) {
	r := ApiGetZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiUpdateRecordRequest struct {
	ctx                 context.Context
	apiService          *DefaultApiService
	projectId           string
	zoneId              string
	rrSetId             string
	updateRecordPayload *UpdateRecordPayload
}

// rrset to update

func (r ApiUpdateRecordRequest) UpdateRecordPayload(updateRecordPayload UpdateRecordPayload) ApiUpdateRecordRequest {
	r.updateRecordPayload = &updateRecordPayload
	return r
}

func (r ApiUpdateRecordRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateRecord")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateRecordPayload == nil {
		return localVarReturnValue, fmt.Errorf("updateRecordPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRecordPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateRecord PatchRecords updates a record in a rrset

PatchRecords rrset updates a record in a rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiUpdateRecordRequest
*/
func (a *APIClient) UpdateRecord(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiUpdateRecordRequest {
	return ApiUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) UpdateRecordExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiUpdateRecordSetRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	zoneId                 string
	rrSetId                string
	updateRecordSetPayload *UpdateRecordSetPayload
}

// record set to patch

func (r ApiUpdateRecordSetRequest) UpdateRecordSetPayload(updateRecordSetPayload UpdateRecordSetPayload) ApiUpdateRecordSetRequest {
	r.updateRecordSetPayload = &updateRecordSetPayload
	return r
}

func (r ApiUpdateRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateRecordSet")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("updateRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRecordSetPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateRecordSet Patch updates a record set

Patch record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiUpdateRecordSetRequest
*/
func (a *APIClient) UpdateRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiUpdateRecordSetRequest {
	return ApiUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) UpdateRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiUpdateZoneRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	zoneId            string
	updateZonePayload *UpdateZonePayload
}

// zone to update

func (r ApiUpdateZoneRequest) UpdateZonePayload(updateZonePayload UpdateZonePayload) ApiUpdateZoneRequest {
	r.updateZonePayload = &updateZonePayload
	return r
}

func (r ApiUpdateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateZone")
	if err != nil {
		return localVarReturnValue, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("updateZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			statusCode: localVarHTTPResponse.StatusCode,
			body:       localVarBody,
			error:      err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateZone Patch update an existing zone

Patch update an existing zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiUpdateZoneRequest
*/
func (a *APIClient) UpdateZone(ctx context.Context, projectId string, zoneId string) ApiUpdateZoneRequest {
	return ApiUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) UpdateZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}
