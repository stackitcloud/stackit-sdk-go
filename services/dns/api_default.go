/*
STACKIT DNS API

This api provides dns

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateRecordSetRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	zoneId                 string
	createRecordSetPayload *CreateRecordSetPayload
}

// record set to create

func (r ApiCreateRecordSetRequest) CreateRecordSetPayload(createRecordSetPayload CreateRecordSetPayload) ApiCreateRecordSetRequest {
	r.createRecordSetPayload = &createRecordSetPayload
	return r
}

func (r ApiCreateRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("createRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRecordSetPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateRecordSet Post record set

Post record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateRecordSetRequest
*/
func (a *APIClient) CreateRecordSet(ctx context.Context, projectId string, zoneId string) ApiCreateRecordSetRequest {
	return ApiCreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateRecordSetExecute(ctx context.Context, projectId string, zoneId string) (*RecordSetResponse, error) {
	r := ApiCreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiCreateZoneRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	createZonePayload *CreateZonePayload
}

// zone to create

func (r ApiCreateZoneRequest) CreateZonePayload(createZonePayload CreateZonePayload) ApiCreateZoneRequest {
	r.createZonePayload = &createZonePayload
	return r
}

func (r ApiCreateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("createZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateZone Post create a new zone

Post zone create a new zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiCreateZoneRequest
*/
func (a *APIClient) CreateZone(ctx context.Context, projectId string) ApiCreateZoneRequest {
	return ApiCreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) CreateZoneExecute(ctx context.Context, projectId string) (*ZoneResponse, error) {
	r := ApiCreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiDeleteRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiDeleteRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteRecordSet Delete a record set

Delete a record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiDeleteRecordSetRequest
*/
func (a *APIClient) DeleteRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiDeleteRecordSetRequest {
	return ApiDeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) DeleteRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiDeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiDeleteZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiDeleteZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteZone Delete a zone

Delete a zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiDeleteZoneRequest
*/
func (a *APIClient) DeleteZone(ctx context.Context, projectId string, zoneId string) ApiDeleteZoneRequest {
	return ApiDeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) DeleteZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiDeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiGetRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiGetRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRecordSet Get a single rrset

Get rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiGetRecordSetRequest
*/
func (a *APIClient) GetRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiGetRecordSetRequest {
	return ApiGetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) GetRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*RecordSetResponse, error) {
	r := ApiGetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiGetZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiGetZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetZone Get a single zone

Get zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiGetZoneRequest
*/
func (a *APIClient) GetZone(ctx context.Context, projectId string, zoneId string) ApiGetZoneRequest {
	return ApiGetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) GetZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiGetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiListRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	page                    *int32
	pageSize                *int32
	nameEq                  *string
	nameLike                *string
	typeEq                  *string
	stateEq                 *string
	stateNeq                *string
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	orderByName             *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
	orderByType             *string
	orderByState            *string
	orderByRecordCount      *string
}

// page

func (r ApiListRecordSetsRequest) Page(page int32) ApiListRecordSetsRequest {
	r.page = &page
	return r
}

// page size

func (r ApiListRecordSetsRequest) PageSize(pageSize int32) ApiListRecordSetsRequest {
	r.pageSize = &pageSize
	return r
}

// filter name equal

func (r ApiListRecordSetsRequest) NameEq(nameEq string) ApiListRecordSetsRequest {
	r.nameEq = &nameEq
	return r
}

// filter name like

func (r ApiListRecordSetsRequest) NameLike(nameLike string) ApiListRecordSetsRequest {
	r.nameLike = &nameLike
	return r
}

// filter type

func (r ApiListRecordSetsRequest) TypeEq(typeEq string) ApiListRecordSetsRequest {
	r.typeEq = &typeEq
	return r
}

// filter state

func (r ApiListRecordSetsRequest) StateEq(stateEq string) ApiListRecordSetsRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ApiListRecordSetsRequest) StateNeq(stateNeq string) ApiListRecordSetsRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter active equal

func (r ApiListRecordSetsRequest) ActiveEq(activeEq bool) ApiListRecordSetsRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedGt(creationStartedGt string) ApiListRecordSetsRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedLt(creationStartedLt string) ApiListRecordSetsRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedGte(creationStartedGte string) ApiListRecordSetsRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedLte(creationStartedLte string) ApiListRecordSetsRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedGt(creationFinishedGt string) ApiListRecordSetsRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedLt(creationFinishedLt string) ApiListRecordSetsRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedGte(creationFinishedGte string) ApiListRecordSetsRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedLte(creationFinishedLte string) ApiListRecordSetsRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedGt(updateStartedGt string) ApiListRecordSetsRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedLt(updateStartedLt string) ApiListRecordSetsRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedGte(updateStartedGte string) ApiListRecordSetsRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedLte(updateStartedLte string) ApiListRecordSetsRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedGt(updateFinishedGt string) ApiListRecordSetsRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedLt(updateFinishedLt string) ApiListRecordSetsRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedGte(updateFinishedGte string) ApiListRecordSetsRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedLte(updateFinishedLte string) ApiListRecordSetsRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// order by name

func (r ApiListRecordSetsRequest) OrderByName(orderByName string) ApiListRecordSetsRequest {
	r.orderByName = &orderByName
	return r
}

// order by creationStarted

func (r ApiListRecordSetsRequest) OrderByCreationStarted(orderByCreationStarted string) ApiListRecordSetsRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ApiListRecordSetsRequest) OrderByCreationFinished(orderByCreationFinished string) ApiListRecordSetsRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ApiListRecordSetsRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiListRecordSetsRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ApiListRecordSetsRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiListRecordSetsRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

// order by type

func (r ApiListRecordSetsRequest) OrderByType(orderByType string) ApiListRecordSetsRequest {
	r.orderByType = &orderByType
	return r
}

// order by state

func (r ApiListRecordSetsRequest) OrderByState(orderByState string) ApiListRecordSetsRequest {
	r.orderByState = &orderByState
	return r
}

// order by record count

func (r ApiListRecordSetsRequest) OrderByRecordCount(orderByRecordCount string) ApiListRecordSetsRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

func (r ApiListRecordSetsRequest) Execute() (*ListRecordSetsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRecordSetsResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[state]", r.orderByState, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRecordSets All get selected RRSets

All RRSet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiListRecordSetsRequest
*/
func (a *APIClient) ListRecordSets(ctx context.Context, projectId string, zoneId string) ApiListRecordSetsRequest {
	return ApiListRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ListRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ListRecordSetsResponse, error) {
	r := ApiListRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiListZonesRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	page                    *int32
	pageSize                *int32
	dnsNameEq               *string
	dnsNameLike             *string
	typeEq                  *string
	nameEq                  *string
	nameNeq                 *string
	nameLike                *string
	descriptionEq           *string
	descriptionNeq          *string
	descriptionLike         *string
	stateEq                 *string
	stateNeq                *string
	primaryNameServerEq     *string
	primaryNameServerLike   *string
	isReverseZoneEq         *bool
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	orderByDnsName          *string
	orderByName             *string
	orderByRecordCount      *string
	orderByType             *string
	orderByDescription      *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
}

// page

func (r ApiListZonesRequest) Page(page int32) ApiListZonesRequest {
	r.page = &page
	return r
}

// page size

func (r ApiListZonesRequest) PageSize(pageSize int32) ApiListZonesRequest {
	r.pageSize = &pageSize
	return r
}

// filter dns name equal

func (r ApiListZonesRequest) DnsNameEq(dnsNameEq string) ApiListZonesRequest {
	r.dnsNameEq = &dnsNameEq
	return r
}

// filter dns name like

func (r ApiListZonesRequest) DnsNameLike(dnsNameLike string) ApiListZonesRequest {
	r.dnsNameLike = &dnsNameLike
	return r
}

// filter type

func (r ApiListZonesRequest) TypeEq(typeEq string) ApiListZonesRequest {
	r.typeEq = &typeEq
	return r
}

// filter name equal

func (r ApiListZonesRequest) NameEq(nameEq string) ApiListZonesRequest {
	r.nameEq = &nameEq
	return r
}

// filter name not equal

func (r ApiListZonesRequest) NameNeq(nameNeq string) ApiListZonesRequest {
	r.nameNeq = &nameNeq
	return r
}

// filter name like

func (r ApiListZonesRequest) NameLike(nameLike string) ApiListZonesRequest {
	r.nameLike = &nameLike
	return r
}

// filter description equal

func (r ApiListZonesRequest) DescriptionEq(descriptionEq string) ApiListZonesRequest {
	r.descriptionEq = &descriptionEq
	return r
}

// filter description not equal

func (r ApiListZonesRequest) DescriptionNeq(descriptionNeq string) ApiListZonesRequest {
	r.descriptionNeq = &descriptionNeq
	return r
}

// filter description like

func (r ApiListZonesRequest) DescriptionLike(descriptionLike string) ApiListZonesRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// filter state

func (r ApiListZonesRequest) StateEq(stateEq string) ApiListZonesRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ApiListZonesRequest) StateNeq(stateNeq string) ApiListZonesRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter primary name server equal

func (r ApiListZonesRequest) PrimaryNameServerEq(primaryNameServerEq string) ApiListZonesRequest {
	r.primaryNameServerEq = &primaryNameServerEq
	return r
}

// filter primary name server like

func (r ApiListZonesRequest) PrimaryNameServerLike(primaryNameServerLike string) ApiListZonesRequest {
	r.primaryNameServerLike = &primaryNameServerLike
	return r
}

// filter reverse zone equal

func (r ApiListZonesRequest) IsReverseZoneEq(isReverseZoneEq bool) ApiListZonesRequest {
	r.isReverseZoneEq = &isReverseZoneEq
	return r
}

// filter active equal

func (r ApiListZonesRequest) ActiveEq(activeEq bool) ApiListZonesRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ApiListZonesRequest) CreationStartedGt(creationStartedGt string) ApiListZonesRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ApiListZonesRequest) CreationStartedLt(creationStartedLt string) ApiListZonesRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ApiListZonesRequest) CreationStartedGte(creationStartedGte string) ApiListZonesRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ApiListZonesRequest) CreationStartedLte(creationStartedLte string) ApiListZonesRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ApiListZonesRequest) CreationFinishedGt(creationFinishedGt string) ApiListZonesRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ApiListZonesRequest) CreationFinishedLt(creationFinishedLt string) ApiListZonesRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ApiListZonesRequest) CreationFinishedGte(creationFinishedGte string) ApiListZonesRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ApiListZonesRequest) CreationFinishedLte(creationFinishedLte string) ApiListZonesRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ApiListZonesRequest) UpdateStartedGt(updateStartedGt string) ApiListZonesRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ApiListZonesRequest) UpdateStartedLt(updateStartedLt string) ApiListZonesRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ApiListZonesRequest) UpdateStartedGte(updateStartedGte string) ApiListZonesRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ApiListZonesRequest) UpdateStartedLte(updateStartedLte string) ApiListZonesRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedGt(updateFinishedGt string) ApiListZonesRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedLt(updateFinishedLt string) ApiListZonesRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedGte(updateFinishedGte string) ApiListZonesRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedLte(updateFinishedLte string) ApiListZonesRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// order by dns name

func (r ApiListZonesRequest) OrderByDnsName(orderByDnsName string) ApiListZonesRequest {
	r.orderByDnsName = &orderByDnsName
	return r
}

// order by name

func (r ApiListZonesRequest) OrderByName(orderByName string) ApiListZonesRequest {
	r.orderByName = &orderByName
	return r
}

// order by record count

func (r ApiListZonesRequest) OrderByRecordCount(orderByRecordCount string) ApiListZonesRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

// order by type

func (r ApiListZonesRequest) OrderByType(orderByType string) ApiListZonesRequest {
	r.orderByType = &orderByType
	return r
}

// order by description

func (r ApiListZonesRequest) OrderByDescription(orderByDescription string) ApiListZonesRequest {
	r.orderByDescription = &orderByDescription
	return r
}

// order by creationStarted

func (r ApiListZonesRequest) OrderByCreationStarted(orderByCreationStarted string) ApiListZonesRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ApiListZonesRequest) OrderByCreationFinished(orderByCreationFinished string) ApiListZonesRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ApiListZonesRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiListZonesRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ApiListZonesRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiListZonesRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

func (r ApiListZonesRequest) Execute() (*ListZonesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListZonesResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListZones")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.dnsNameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[eq]", r.dnsNameEq, "")
	}
	if r.dnsNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[like]", r.dnsNameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[neq]", r.nameNeq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.descriptionEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[eq]", r.descriptionEq, "")
	}
	if r.descriptionNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[neq]", r.descriptionNeq, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[like]", r.descriptionLike, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.primaryNameServerEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[eq]", r.primaryNameServerEq, "")
	}
	if r.primaryNameServerLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[like]", r.primaryNameServerLike, "")
	}
	if r.isReverseZoneEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isReverseZone[eq]", r.isReverseZoneEq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.orderByDnsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[dnsName]", r.orderByDnsName, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[description]", r.orderByDescription, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListZones All get selected zones

All zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiListZonesRequest
*/
func (a *APIClient) ListZones(ctx context.Context, projectId string) ApiListZonesRequest {
	return ApiListZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListZonesExecute(ctx context.Context, projectId string) (*ListZonesResponse, error) {
	r := ApiListZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiPartialUpdateRecordRequest struct {
	ctx                        context.Context
	apiService                 *DefaultApiService
	projectId                  string
	zoneId                     string
	rrSetId                    string
	partialUpdateRecordPayload *PartialUpdateRecordPayload
}

// rrset to update

func (r ApiPartialUpdateRecordRequest) PartialUpdateRecordPayload(partialUpdateRecordPayload PartialUpdateRecordPayload) ApiPartialUpdateRecordRequest {
	r.partialUpdateRecordPayload = &partialUpdateRecordPayload
	return r
}

func (r ApiPartialUpdateRecordRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateRecord")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateRecordPayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateRecordPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateRecordPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateRecord PatchRecords updates a record in a rrset

PatchRecords rrset updates a record in a rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiPartialUpdateRecordRequest
*/
func (a *APIClient) PartialUpdateRecord(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordRequest {
	return ApiPartialUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) PartialUpdateRecordExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiPartialUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiPartialUpdateRecordSetRequest struct {
	ctx                           context.Context
	apiService                    *DefaultApiService
	projectId                     string
	zoneId                        string
	rrSetId                       string
	partialUpdateRecordSetPayload *PartialUpdateRecordSetPayload
}

// record set to patch

func (r ApiPartialUpdateRecordSetRequest) PartialUpdateRecordSetPayload(partialUpdateRecordSetPayload PartialUpdateRecordSetPayload) ApiPartialUpdateRecordSetRequest {
	r.partialUpdateRecordSetPayload = &partialUpdateRecordSetPayload
	return r
}

func (r ApiPartialUpdateRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateRecordSetPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateRecordSet Patch updates a record set

Patch record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiPartialUpdateRecordSetRequest
*/
func (a *APIClient) PartialUpdateRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordSetRequest {
	return ApiPartialUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) PartialUpdateRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiPartialUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiPartialUpdateZoneRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	zoneId                   string
	partialUpdateZonePayload *PartialUpdateZonePayload
}

// zone to update

func (r ApiPartialUpdateZoneRequest) PartialUpdateZonePayload(partialUpdateZonePayload PartialUpdateZonePayload) ApiPartialUpdateZoneRequest {
	r.partialUpdateZonePayload = &partialUpdateZonePayload
	return r
}

func (r ApiPartialUpdateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateZone Patch update an existing zone

Patch update an existing zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiPartialUpdateZoneRequest
*/
func (a *APIClient) PartialUpdateZone(ctx context.Context, projectId string, zoneId string) ApiPartialUpdateZoneRequest {
	return ApiPartialUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) PartialUpdateZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiPartialUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}
