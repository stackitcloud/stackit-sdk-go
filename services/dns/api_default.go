/*
STACKIT DNS API

This api provides dns

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCloneZoneRequest struct {
	ctx              context.Context
	apiService       *DefaultApiService
	projectId        string
	zoneId           string
	cloneZonePayload *CloneZonePayload
}

// zone to clone

func (r ApiCloneZoneRequest) CloneZonePayload(cloneZonePayload CloneZonePayload) ApiCloneZoneRequest {
	r.cloneZonePayload = &cloneZonePayload
	return r
}

func (r ApiCloneZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CloneZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloneZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("cloneZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloneZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CloneZone: Clone an existing zone with all record sets to a new zone with a different name

Clone an existing zone with all record sets to a new zone with a different name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCloneZoneRequest
*/
func (a *APIClient) CloneZone(ctx context.Context, projectId string, zoneId string) ApiCloneZoneRequest {
	return ApiCloneZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CloneZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiCloneZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiCreateLabelRequest struct {
	ctx                context.Context
	apiService         *DefaultApiService
	projectId          string
	zoneId             string
	createLabelPayload *CreateLabelPayload
}

// record set to create

func (r ApiCreateLabelRequest) CreateLabelPayload(createLabelPayload CreateLabelPayload) ApiCreateLabelRequest {
	r.createLabelPayload = &createLabelPayload
	return r
}

func (r ApiCreateLabelRequest) Execute() (*CreateLabelResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateLabelResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateLabel")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLabelPayload == nil {
		return localVarReturnValue, fmt.Errorf("createLabelPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLabelPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateLabel: Create or update label

Create or update label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateLabelRequest
*/
func (a *APIClient) CreateLabel(ctx context.Context, projectId string, zoneId string) ApiCreateLabelRequest {
	return ApiCreateLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateLabelExecute(ctx context.Context, projectId string, zoneId string) (*CreateLabelResponse, error) {
	r := ApiCreateLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiCreateMoveCodeRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiCreateMoveCodeRequest) Execute() (*MoveCodeResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MoveCodeResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMoveCode")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/move-code"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateMoveCode: request a move code to move zone to another project

move zone from one project to another

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateMoveCodeRequest
*/
func (a *APIClient) CreateMoveCode(ctx context.Context, projectId string, zoneId string) ApiCreateMoveCodeRequest {
	return ApiCreateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*MoveCodeResponse, error) {
	r := ApiCreateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiCreateRecordSetRequest struct {
	ctx                    context.Context
	apiService             *DefaultApiService
	projectId              string
	zoneId                 string
	createRecordSetPayload *CreateRecordSetPayload
}

// record set to create

func (r ApiCreateRecordSetRequest) CreateRecordSetPayload(createRecordSetPayload CreateRecordSetPayload) ApiCreateRecordSetRequest {
	r.createRecordSetPayload = &createRecordSetPayload
	return r
}

func (r ApiCreateRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("createRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRecordSetPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateRecordSet: Post record set

Post record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiCreateRecordSetRequest
*/
func (a *APIClient) CreateRecordSet(ctx context.Context, projectId string, zoneId string) ApiCreateRecordSetRequest {
	return ApiCreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) CreateRecordSetExecute(ctx context.Context, projectId string, zoneId string) (*RecordSetResponse, error) {
	r := ApiCreateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiCreateZoneRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	createZonePayload *CreateZonePayload
}

// zone to create

func (r ApiCreateZoneRequest) CreateZonePayload(createZonePayload CreateZonePayload) ApiCreateZoneRequest {
	r.createZonePayload = &createZonePayload
	return r
}

func (r ApiCreateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("createZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateZone: Post create a new zone

Post zone create a new zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiCreateZoneRequest
*/
func (a *APIClient) CreateZone(ctx context.Context, projectId string) ApiCreateZoneRequest {
	return ApiCreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) CreateZoneExecute(ctx context.Context, projectId string) (*ZoneResponse, error) {
	r := ApiCreateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiDeleteLabelRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	key        string
}

func (r ApiDeleteLabelRequest) Execute() (*DeleteLabelResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteLabelResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteLabel")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/labels/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(ParameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteLabel: Delete a label

Delete a label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param key key of the label
	@return ApiDeleteLabelRequest
*/
func (a *APIClient) DeleteLabel(ctx context.Context, projectId string, zoneId string, key string) ApiDeleteLabelRequest {
	return ApiDeleteLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		key:        key,
	}
}

func (a *APIClient) DeleteLabelExecute(ctx context.Context, projectId string, zoneId string, key string) (*DeleteLabelResponse, error) {
	r := ApiDeleteLabelRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		key:        key,
	}
	return r.Execute()
}

type ApiDeleteMoveCodeRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiDeleteMoveCodeRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteMoveCode")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/move-code"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteMoveCode: delete/invalidate a move code

delete/invalidate a move code

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiDeleteMoveCodeRequest
*/
func (a *APIClient) DeleteMoveCode(ctx context.Context, projectId string, zoneId string) ApiDeleteMoveCodeRequest {
	return ApiDeleteMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) DeleteMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiDeleteMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiDeleteRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiDeleteRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteRecordSet: Delete a record set

Delete a record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiDeleteRecordSetRequest
*/
func (a *APIClient) DeleteRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiDeleteRecordSetRequest {
	return ApiDeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) DeleteRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiDeleteRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiDeleteZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiDeleteZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
DeleteZone: Delete a zone

Delete a zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiDeleteZoneRequest
*/
func (a *APIClient) DeleteZone(ctx context.Context, projectId string, zoneId string) ApiDeleteZoneRequest {
	return ApiDeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) DeleteZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiDeleteZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiExportRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	exportRecordSetsPayload *ExportRecordSetsPayload
}

// export configuration

func (r ApiExportRecordSetsRequest) ExportRecordSetsPayload(exportRecordSetsPayload ExportRecordSetsPayload) ApiExportRecordSetsRequest {
	r.exportRecordSetsPayload = &exportRecordSetsPayload
	return r
}

func (r ApiExportRecordSetsRequest) Execute() (*ZoneDataExchange, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneDataExchange
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ExportRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exportRecordSetsPayload == nil {
		return localVarReturnValue, fmt.Errorf("exportRecordSetsPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportRecordSetsPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ExportRecordSets: Export all records in a single zone

Export Zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiExportRecordSetsRequest
*/
func (a *APIClient) ExportRecordSets(ctx context.Context, projectId string, zoneId string) ApiExportRecordSetsRequest {
	return ApiExportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ExportRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ZoneDataExchange, error) {
	r := ApiExportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiGetRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiGetRecordSetRequest) Execute() (*RecordSetResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RecordSetResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetRecordSet: Get a single rrset

Get rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiGetRecordSetRequest
*/
func (a *APIClient) GetRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiGetRecordSetRequest {
	return ApiGetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) GetRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*RecordSetResponse, error) {
	r := ApiGetRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiGetZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiGetZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetZone: Get a single zone

Get zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiGetZoneRequest
*/
func (a *APIClient) GetZone(ctx context.Context, projectId string, zoneId string) ApiGetZoneRequest {
	return ApiGetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) GetZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiGetZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiImportRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	importRecordSetsPayload *ImportRecordSetsPayload
	format                  *string
	importType              *string
}

// accepts all response bodies for the export endpoint

func (r ApiImportRecordSetsRequest) ImportRecordSetsPayload(importRecordSetsPayload ImportRecordSetsPayload) ApiImportRecordSetsRequest {
	r.importRecordSetsPayload = &importRecordSetsPayload
	return r
}

// format of the data to import

func (r ApiImportRecordSetsRequest) Format(format string) ApiImportRecordSetsRequest {
	r.format = &format
	return r
}

// type of the zone import

func (r ApiImportRecordSetsRequest) ImportType(importType string) ApiImportRecordSetsRequest {
	r.importType = &importType
	return r
}

func (r ApiImportRecordSetsRequest) Execute() (*ImportRecordSetsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImportRecordSetsResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ImportRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/import"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importRecordSetsPayload == nil {
		return localVarReturnValue, fmt.Errorf("importRecordSetsPayload is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.importType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importType", r.importType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importRecordSetsPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ImportRecordSets: Imports a zone

Imports a zone and overwrites/deletes/inserts all desired records

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiImportRecordSetsRequest
*/
func (a *APIClient) ImportRecordSets(ctx context.Context, projectId string, zoneId string) ApiImportRecordSetsRequest {
	return ApiImportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ImportRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ImportRecordSetsResponse, error) {
	r := ApiImportRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiListLabelsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiListLabelsRequest) Execute() (*ListLabelsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListLabelsResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListLabels")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListLabels: Get all labels

All Labels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiListLabelsRequest
*/
func (a *APIClient) ListLabels(ctx context.Context, projectId string, zoneId string) ApiListLabelsRequest {
	return ApiListLabelsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ListLabelsExecute(ctx context.Context, projectId string, zoneId string) (*ListLabelsResponse, error) {
	r := ApiListLabelsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiListRecordSetsRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	page                    *int32
	pageSize                *int32
	nameEq                  *string
	nameLike                *string
	typeEq                  *string
	stateEq                 *string
	stateNeq                *string
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	orderByName             *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
	orderByType             *string
	orderByState            *string
	orderByRecordCount      *string
}

// page

func (r ApiListRecordSetsRequest) Page(page int32) ApiListRecordSetsRequest {
	r.page = &page
	return r
}

// page size

func (r ApiListRecordSetsRequest) PageSize(pageSize int32) ApiListRecordSetsRequest {
	r.pageSize = &pageSize
	return r
}

// filter name equal

func (r ApiListRecordSetsRequest) NameEq(nameEq string) ApiListRecordSetsRequest {
	r.nameEq = &nameEq
	return r
}

// filter name like

func (r ApiListRecordSetsRequest) NameLike(nameLike string) ApiListRecordSetsRequest {
	r.nameLike = &nameLike
	return r
}

// filter type

func (r ApiListRecordSetsRequest) TypeEq(typeEq string) ApiListRecordSetsRequest {
	r.typeEq = &typeEq
	return r
}

// filter state

func (r ApiListRecordSetsRequest) StateEq(stateEq string) ApiListRecordSetsRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ApiListRecordSetsRequest) StateNeq(stateNeq string) ApiListRecordSetsRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter active equal

func (r ApiListRecordSetsRequest) ActiveEq(activeEq bool) ApiListRecordSetsRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedGt(creationStartedGt string) ApiListRecordSetsRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedLt(creationStartedLt string) ApiListRecordSetsRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedGte(creationStartedGte string) ApiListRecordSetsRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationStartedLte(creationStartedLte string) ApiListRecordSetsRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedGt(creationFinishedGt string) ApiListRecordSetsRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedLt(creationFinishedLt string) ApiListRecordSetsRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedGte(creationFinishedGte string) ApiListRecordSetsRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) CreationFinishedLte(creationFinishedLte string) ApiListRecordSetsRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedGt(updateStartedGt string) ApiListRecordSetsRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedLt(updateStartedLt string) ApiListRecordSetsRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedGte(updateStartedGte string) ApiListRecordSetsRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateStartedLte(updateStartedLte string) ApiListRecordSetsRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedGt(updateFinishedGt string) ApiListRecordSetsRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedLt(updateFinishedLt string) ApiListRecordSetsRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedGte(updateFinishedGte string) ApiListRecordSetsRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ApiListRecordSetsRequest) UpdateFinishedLte(updateFinishedLte string) ApiListRecordSetsRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// order by name

func (r ApiListRecordSetsRequest) OrderByName(orderByName string) ApiListRecordSetsRequest {
	r.orderByName = &orderByName
	return r
}

// order by creationStarted

func (r ApiListRecordSetsRequest) OrderByCreationStarted(orderByCreationStarted string) ApiListRecordSetsRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ApiListRecordSetsRequest) OrderByCreationFinished(orderByCreationFinished string) ApiListRecordSetsRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ApiListRecordSetsRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiListRecordSetsRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ApiListRecordSetsRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiListRecordSetsRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

// order by type

func (r ApiListRecordSetsRequest) OrderByType(orderByType string) ApiListRecordSetsRequest {
	r.orderByType = &orderByType
	return r
}

// order by state

func (r ApiListRecordSetsRequest) OrderByState(orderByState string) ApiListRecordSetsRequest {
	r.orderByState = &orderByState
	return r
}

// order by record count

func (r ApiListRecordSetsRequest) OrderByRecordCount(orderByRecordCount string) ApiListRecordSetsRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

func (r ApiListRecordSetsRequest) Execute() (*ListRecordSetsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRecordSetsResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecordSets")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[state]", r.orderByState, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRecordSets: All get selected RRSets

All RRSet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiListRecordSetsRequest
*/
func (a *APIClient) ListRecordSets(ctx context.Context, projectId string, zoneId string) ApiListRecordSetsRequest {
	return ApiListRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ListRecordSetsExecute(ctx context.Context, projectId string, zoneId string) (*ListRecordSetsResponse, error) {
	r := ApiListRecordSetsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiListZonesRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	page                    *int32
	pageSize                *int32
	dnsNameEq               *string
	dnsNameLike             *string
	typeEq                  *string
	nameEq                  *string
	nameNeq                 *string
	nameLike                *string
	descriptionEq           *string
	descriptionNeq          *string
	descriptionLike         *string
	stateEq                 *string
	stateNeq                *string
	primaryNameServerEq     *string
	primaryNameServerLike   *string
	isReverseZoneEq         *bool
	activeEq                *bool
	creationStartedGt       *string
	creationStartedLt       *string
	creationStartedGte      *string
	creationStartedLte      *string
	creationFinishedGt      *string
	creationFinishedLt      *string
	creationFinishedGte     *string
	creationFinishedLte     *string
	updateStartedGt         *string
	updateStartedLt         *string
	updateStartedGte        *string
	updateStartedLte        *string
	updateFinishedGt        *string
	updateFinishedLt        *string
	updateFinishedGte       *string
	updateFinishedLte       *string
	labelKeyEq              *[]string
	labelValueEq            *[]string
	orderByDnsName          *string
	orderByName             *string
	orderByRecordCount      *string
	orderByType             *string
	orderByDescription      *string
	orderByCreationStarted  *string
	orderByCreationFinished *string
	orderByUpdateStarted    *string
	orderByUpdateFinished   *string
}

// page

func (r ApiListZonesRequest) Page(page int32) ApiListZonesRequest {
	r.page = &page
	return r
}

// page size

func (r ApiListZonesRequest) PageSize(pageSize int32) ApiListZonesRequest {
	r.pageSize = &pageSize
	return r
}

// filter dns name equal

func (r ApiListZonesRequest) DnsNameEq(dnsNameEq string) ApiListZonesRequest {
	r.dnsNameEq = &dnsNameEq
	return r
}

// filter dns name like

func (r ApiListZonesRequest) DnsNameLike(dnsNameLike string) ApiListZonesRequest {
	r.dnsNameLike = &dnsNameLike
	return r
}

// filter type

func (r ApiListZonesRequest) TypeEq(typeEq string) ApiListZonesRequest {
	r.typeEq = &typeEq
	return r
}

// filter name equal

func (r ApiListZonesRequest) NameEq(nameEq string) ApiListZonesRequest {
	r.nameEq = &nameEq
	return r
}

// filter name not equal

func (r ApiListZonesRequest) NameNeq(nameNeq string) ApiListZonesRequest {
	r.nameNeq = &nameNeq
	return r
}

// filter name like

func (r ApiListZonesRequest) NameLike(nameLike string) ApiListZonesRequest {
	r.nameLike = &nameLike
	return r
}

// filter description equal

func (r ApiListZonesRequest) DescriptionEq(descriptionEq string) ApiListZonesRequest {
	r.descriptionEq = &descriptionEq
	return r
}

// filter description not equal

func (r ApiListZonesRequest) DescriptionNeq(descriptionNeq string) ApiListZonesRequest {
	r.descriptionNeq = &descriptionNeq
	return r
}

// filter description like

func (r ApiListZonesRequest) DescriptionLike(descriptionLike string) ApiListZonesRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// filter state

func (r ApiListZonesRequest) StateEq(stateEq string) ApiListZonesRequest {
	r.stateEq = &stateEq
	return r
}

// filter state

func (r ApiListZonesRequest) StateNeq(stateNeq string) ApiListZonesRequest {
	r.stateNeq = &stateNeq
	return r
}

// filter primary name server equal

func (r ApiListZonesRequest) PrimaryNameServerEq(primaryNameServerEq string) ApiListZonesRequest {
	r.primaryNameServerEq = &primaryNameServerEq
	return r
}

// filter primary name server like

func (r ApiListZonesRequest) PrimaryNameServerLike(primaryNameServerLike string) ApiListZonesRequest {
	r.primaryNameServerLike = &primaryNameServerLike
	return r
}

// filter reverse zone equal

func (r ApiListZonesRequest) IsReverseZoneEq(isReverseZoneEq bool) ApiListZonesRequest {
	r.isReverseZoneEq = &isReverseZoneEq
	return r
}

// filter active equal

func (r ApiListZonesRequest) ActiveEq(activeEq bool) ApiListZonesRequest {
	r.activeEq = &activeEq
	return r
}

// filter creation started greater with utc timestamp

func (r ApiListZonesRequest) CreationStartedGt(creationStartedGt string) ApiListZonesRequest {
	r.creationStartedGt = &creationStartedGt
	return r
}

// filter creation started lesser with utc timestamp

func (r ApiListZonesRequest) CreationStartedLt(creationStartedLt string) ApiListZonesRequest {
	r.creationStartedLt = &creationStartedLt
	return r
}

// filter creation started greater equal with utc timestamp

func (r ApiListZonesRequest) CreationStartedGte(creationStartedGte string) ApiListZonesRequest {
	r.creationStartedGte = &creationStartedGte
	return r
}

// filter creation started lesser equal with utc timestamp

func (r ApiListZonesRequest) CreationStartedLte(creationStartedLte string) ApiListZonesRequest {
	r.creationStartedLte = &creationStartedLte
	return r
}

// filter creation finished greater with utc timestamp

func (r ApiListZonesRequest) CreationFinishedGt(creationFinishedGt string) ApiListZonesRequest {
	r.creationFinishedGt = &creationFinishedGt
	return r
}

// filter creation finished lesser with utc timestamp

func (r ApiListZonesRequest) CreationFinishedLt(creationFinishedLt string) ApiListZonesRequest {
	r.creationFinishedLt = &creationFinishedLt
	return r
}

// filter creation finished greater equal with utc timestamp

func (r ApiListZonesRequest) CreationFinishedGte(creationFinishedGte string) ApiListZonesRequest {
	r.creationFinishedGte = &creationFinishedGte
	return r
}

// filter creation finished lesser equal with utc timestamp

func (r ApiListZonesRequest) CreationFinishedLte(creationFinishedLte string) ApiListZonesRequest {
	r.creationFinishedLte = &creationFinishedLte
	return r
}

// filter update started greater with utc timestamp

func (r ApiListZonesRequest) UpdateStartedGt(updateStartedGt string) ApiListZonesRequest {
	r.updateStartedGt = &updateStartedGt
	return r
}

// filter update started lesser with utc timestamp

func (r ApiListZonesRequest) UpdateStartedLt(updateStartedLt string) ApiListZonesRequest {
	r.updateStartedLt = &updateStartedLt
	return r
}

// filter update started greater equal with utc timestamp

func (r ApiListZonesRequest) UpdateStartedGte(updateStartedGte string) ApiListZonesRequest {
	r.updateStartedGte = &updateStartedGte
	return r
}

// filter update started lesser equal with utc timestamp

func (r ApiListZonesRequest) UpdateStartedLte(updateStartedLte string) ApiListZonesRequest {
	r.updateStartedLte = &updateStartedLte
	return r
}

// filter update finished greater with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedGt(updateFinishedGt string) ApiListZonesRequest {
	r.updateFinishedGt = &updateFinishedGt
	return r
}

// filter update finished lesser with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedLt(updateFinishedLt string) ApiListZonesRequest {
	r.updateFinishedLt = &updateFinishedLt
	return r
}

// filter update finished greater equal with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedGte(updateFinishedGte string) ApiListZonesRequest {
	r.updateFinishedGte = &updateFinishedGte
	return r
}

// filter update finished lesser equal with utc timestamp

func (r ApiListZonesRequest) UpdateFinishedLte(updateFinishedLte string) ApiListZonesRequest {
	r.updateFinishedLte = &updateFinishedLte
	return r
}

// filter zones according to the zone label keys.

func (r ApiListZonesRequest) LabelKeyEq(labelKeyEq []string) ApiListZonesRequest {
	r.labelKeyEq = &labelKeyEq
	return r
}

// filter zones according to the zone label values.

func (r ApiListZonesRequest) LabelValueEq(labelValueEq []string) ApiListZonesRequest {
	r.labelValueEq = &labelValueEq
	return r
}

// order by dns name

func (r ApiListZonesRequest) OrderByDnsName(orderByDnsName string) ApiListZonesRequest {
	r.orderByDnsName = &orderByDnsName
	return r
}

// order by name

func (r ApiListZonesRequest) OrderByName(orderByName string) ApiListZonesRequest {
	r.orderByName = &orderByName
	return r
}

// order by record count

func (r ApiListZonesRequest) OrderByRecordCount(orderByRecordCount string) ApiListZonesRequest {
	r.orderByRecordCount = &orderByRecordCount
	return r
}

// order by type

func (r ApiListZonesRequest) OrderByType(orderByType string) ApiListZonesRequest {
	r.orderByType = &orderByType
	return r
}

// order by description

func (r ApiListZonesRequest) OrderByDescription(orderByDescription string) ApiListZonesRequest {
	r.orderByDescription = &orderByDescription
	return r
}

// order by creationStarted

func (r ApiListZonesRequest) OrderByCreationStarted(orderByCreationStarted string) ApiListZonesRequest {
	r.orderByCreationStarted = &orderByCreationStarted
	return r
}

// order by creationFinished

func (r ApiListZonesRequest) OrderByCreationFinished(orderByCreationFinished string) ApiListZonesRequest {
	r.orderByCreationFinished = &orderByCreationFinished
	return r
}

// order by updateStarted

func (r ApiListZonesRequest) OrderByUpdateStarted(orderByUpdateStarted string) ApiListZonesRequest {
	r.orderByUpdateStarted = &orderByUpdateStarted
	return r
}

// order by updateFinished

func (r ApiListZonesRequest) OrderByUpdateFinished(orderByUpdateFinished string) ApiListZonesRequest {
	r.orderByUpdateFinished = &orderByUpdateFinished
	return r
}

func (r ApiListZonesRequest) Execute() (*ListZonesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListZonesResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListZones")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.dnsNameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[eq]", r.dnsNameEq, "")
	}
	if r.dnsNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnsName[like]", r.dnsNameLike, "")
	}
	if r.typeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type[eq]", r.typeEq, "")
	}
	if r.nameEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[eq]", r.nameEq, "")
	}
	if r.nameNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[neq]", r.nameNeq, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name[like]", r.nameLike, "")
	}
	if r.descriptionEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[eq]", r.descriptionEq, "")
	}
	if r.descriptionNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[neq]", r.descriptionNeq, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description[like]", r.descriptionLike, "")
	}
	if r.stateEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[eq]", r.stateEq, "")
	}
	if r.stateNeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state[neq]", r.stateNeq, "")
	}
	if r.primaryNameServerEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[eq]", r.primaryNameServerEq, "")
	}
	if r.primaryNameServerLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServer[like]", r.primaryNameServerLike, "")
	}
	if r.isReverseZoneEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isReverseZone[eq]", r.isReverseZoneEq, "")
	}
	if r.activeEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active[eq]", r.activeEq, "")
	}
	if r.creationStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gt]", r.creationStartedGt, "")
	}
	if r.creationStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lt]", r.creationStartedLt, "")
	}
	if r.creationStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[gte]", r.creationStartedGte, "")
	}
	if r.creationStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStarted[lte]", r.creationStartedLte, "")
	}
	if r.creationFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gt]", r.creationFinishedGt, "")
	}
	if r.creationFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lt]", r.creationFinishedLt, "")
	}
	if r.creationFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[gte]", r.creationFinishedGte, "")
	}
	if r.creationFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationFinished[lte]", r.creationFinishedLte, "")
	}
	if r.updateStartedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gt]", r.updateStartedGt, "")
	}
	if r.updateStartedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lt]", r.updateStartedLt, "")
	}
	if r.updateStartedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[gte]", r.updateStartedGte, "")
	}
	if r.updateStartedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStarted[lte]", r.updateStartedLte, "")
	}
	if r.updateFinishedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gt]", r.updateFinishedGt, "")
	}
	if r.updateFinishedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lt]", r.updateFinishedLt, "")
	}
	if r.updateFinishedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[gte]", r.updateFinishedGte, "")
	}
	if r.updateFinishedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateFinished[lte]", r.updateFinishedLte, "")
	}
	if r.labelKeyEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelKey[eq]", r.labelKeyEq, "csv")
	}
	if r.labelValueEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelValue[eq]", r.labelValueEq, "csv")
	}
	if r.orderByDnsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[dnsName]", r.orderByDnsName, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[name]", r.orderByName, "")
	}
	if r.orderByRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[recordCount]", r.orderByRecordCount, "")
	}
	if r.orderByType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[type]", r.orderByType, "")
	}
	if r.orderByDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[description]", r.orderByDescription, "")
	}
	if r.orderByCreationStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationStarted]", r.orderByCreationStarted, "")
	}
	if r.orderByCreationFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[creationFinished]", r.orderByCreationFinished, "")
	}
	if r.orderByUpdateStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateStarted]", r.orderByUpdateStarted, "")
	}
	if r.orderByUpdateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy[updateFinished]", r.orderByUpdateFinished, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListZones: All get selected zones

All zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiListZonesRequest
*/
func (a *APIClient) ListZones(ctx context.Context, projectId string) ApiListZonesRequest {
	return ApiListZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) ListZonesExecute(ctx context.Context, projectId string) (*ListZonesResponse, error) {
	r := ApiListZonesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiMoveZoneRequest struct {
	ctx             context.Context
	apiService      *DefaultApiService
	projectId       string
	moveZonePayload *MoveZonePayload
}

// information about the move

func (r ApiMoveZoneRequest) MoveZonePayload(moveZonePayload MoveZonePayload) ApiMoveZoneRequest {
	r.moveZonePayload = &moveZonePayload
	return r
}

func (r ApiMoveZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MoveZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/move-zone"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("moveZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
MoveZone: move zone from one project to another

move zone from one project to another

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@return ApiMoveZoneRequest
*/
func (a *APIClient) MoveZone(ctx context.Context, projectId string) ApiMoveZoneRequest {
	return ApiMoveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
}

func (a *APIClient) MoveZoneExecute(ctx context.Context, projectId string) (*Message, error) {
	r := ApiMoveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
	}
	return r.Execute()
}

type ApiPartialUpdateRecordRequest struct {
	ctx                        context.Context
	apiService                 *DefaultApiService
	projectId                  string
	zoneId                     string
	rrSetId                    string
	partialUpdateRecordPayload *PartialUpdateRecordPayload
}

// rrset to update

func (r ApiPartialUpdateRecordRequest) PartialUpdateRecordPayload(partialUpdateRecordPayload PartialUpdateRecordPayload) ApiPartialUpdateRecordRequest {
	r.partialUpdateRecordPayload = &partialUpdateRecordPayload
	return r
}

func (r ApiPartialUpdateRecordRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateRecord")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateRecordPayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateRecordPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateRecordPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateRecord: PatchRecords updates a record in a rrset

PatchRecords rrset updates a record in a rrset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiPartialUpdateRecordRequest
*/
func (a *APIClient) PartialUpdateRecord(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordRequest {
	return ApiPartialUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) PartialUpdateRecordExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiPartialUpdateRecordRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiPartialUpdateRecordSetRequest struct {
	ctx                           context.Context
	apiService                    *DefaultApiService
	projectId                     string
	zoneId                        string
	rrSetId                       string
	partialUpdateRecordSetPayload *PartialUpdateRecordSetPayload
}

// record set to patch

func (r ApiPartialUpdateRecordSetRequest) PartialUpdateRecordSetPayload(partialUpdateRecordSetPayload PartialUpdateRecordSetPayload) ApiPartialUpdateRecordSetRequest {
	r.partialUpdateRecordSetPayload = &partialUpdateRecordSetPayload
	return r
}

func (r ApiPartialUpdateRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateRecordSetPayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateRecordSetPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateRecordSetPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateRecordSet: Patch updates a record set

Patch record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiPartialUpdateRecordSetRequest
*/
func (a *APIClient) PartialUpdateRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiPartialUpdateRecordSetRequest {
	return ApiPartialUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) PartialUpdateRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiPartialUpdateRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiPartialUpdateZoneRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	zoneId                   string
	partialUpdateZonePayload *PartialUpdateZonePayload
}

// zone to update

func (r ApiPartialUpdateZoneRequest) PartialUpdateZonePayload(partialUpdateZonePayload PartialUpdateZonePayload) ApiPartialUpdateZoneRequest {
	r.partialUpdateZonePayload = &partialUpdateZonePayload
	return r
}

func (r ApiPartialUpdateZoneRequest) Execute() (*ZoneResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ZoneResponse
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateZonePayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateZonePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateZonePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateZone: Patch update an existing zone

Patch update an existing zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiPartialUpdateZoneRequest
*/
func (a *APIClient) PartialUpdateZone(ctx context.Context, projectId string, zoneId string) ApiPartialUpdateZoneRequest {
	return ApiPartialUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) PartialUpdateZoneExecute(ctx context.Context, projectId string, zoneId string) (*ZoneResponse, error) {
	r := ApiPartialUpdateZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiRestoreRecordSetRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
	rrSetId    string
}

func (r ApiRestoreRecordSetRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreRecordSet")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rrSetId"+"}", url.PathEscape(ParameterValueToString(r.rrSetId, "rrSetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RestoreRecordSet: Restore record set

Restore record set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@param rrSetId record set id
	@return ApiRestoreRecordSetRequest
*/
func (a *APIClient) RestoreRecordSet(ctx context.Context, projectId string, zoneId string, rrSetId string) ApiRestoreRecordSetRequest {
	return ApiRestoreRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
}

func (a *APIClient) RestoreRecordSetExecute(ctx context.Context, projectId string, zoneId string, rrSetId string) (*Message, error) {
	r := ApiRestoreRecordSetRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
		rrSetId:    rrSetId,
	}
	return r.Execute()
}

type ApiRestoreZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiRestoreZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RestoreZone: Restore  an inactive zone

Restore  an inactive zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiRestoreZoneRequest
*/
func (a *APIClient) RestoreZone(ctx context.Context, projectId string, zoneId string) ApiRestoreZoneRequest {
	return ApiRestoreZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) RestoreZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiRestoreZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiRetrieveZoneRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	zoneId     string
}

func (r ApiRetrieveZoneRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RetrieveZone")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/retrieve"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RetrieveZone: Queue secondary zone for a zone transfer request.

The zone transfer will usually be performed within a few seconds, and will be tried only once by randomly choosing one of the configured primary name servers. If that single attempt fails, no further attempt will be performed. The zone will be transferred to our inbound name server regardless of its serial, but the internal zone distribution is only reliable if the zone's serial on the customer's primary name server is higher than on the STACKIT name server. <br>NOTE: As said above, this endpoint is not a reliable way to decrease a zone's serial. To guarantee consistent zones over all STACKIT location, the zone's serial MUST always be increased on zone changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiRetrieveZoneRequest
*/
func (a *APIClient) RetrieveZone(ctx context.Context, projectId string, zoneId string) ApiRetrieveZoneRequest {
	return ApiRetrieveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) RetrieveZoneExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiRetrieveZoneRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}

type ApiValidateMoveCodeRequest struct {
	ctx                     context.Context
	apiService              *DefaultApiService
	projectId               string
	zoneId                  string
	validateMoveCodePayload *ValidateMoveCodePayload
}

// information about the move

func (r ApiValidateMoveCodeRequest) ValidateMoveCodePayload(validateMoveCodePayload ValidateMoveCodePayload) ApiValidateMoveCodeRequest {
	r.validateMoveCodePayload = &validateMoveCodePayload
	return r
}

func (r ApiValidateMoveCodeRequest) Execute() (*Message, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ValidateMoveCode")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/zones/{zoneId}/move-code-validation"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", url.PathEscape(ParameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateMoveCodePayload == nil {
		return localVarReturnValue, fmt.Errorf("validateMoveCodePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateMoveCodePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v Message
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ValidateMoveCode: validate the move code is still valid for the zone

validate the move code is still valid for the zone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId project id
	@param zoneId zone id
	@return ApiValidateMoveCodeRequest
*/
func (a *APIClient) ValidateMoveCode(ctx context.Context, projectId string, zoneId string) ApiValidateMoveCodeRequest {
	return ApiValidateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
}

func (a *APIClient) ValidateMoveCodeExecute(ctx context.Context, projectId string, zoneId string) (*Message, error) {
	r := ApiValidateMoveCodeRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		zoneId:     zoneId,
	}
	return r.Execute()
}
