/*
STACKIT Key Management Service API

This API provides endpoints for managing keys and key rings.

API version: 1beta.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kms

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateKeyRequest struct {
	ctx              context.Context
	apiService       *DefaultApiService
	projectId        string
	regionId         string
	keyRingId        string
	createKeyPayload *CreateKeyPayload
}

func (r ApiCreateKeyRequest) CreateKeyPayload(createKeyPayload CreateKeyPayload) ApiCreateKeyRequest {
	r.createKeyPayload = &createKeyPayload
	return r
}

func (r ApiCreateKeyRequest) Execute() (*Key, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Key
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateKey")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createKeyPayload == nil {
		return localVarReturnValue, fmt.Errorf("createKeyPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createKeyPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateKey: Create key

Creates a new key for the given key ring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@return ApiCreateKeyRequest
*/
func (a *APIClient) CreateKey(ctx context.Context, projectId string, regionId string, keyRingId string) ApiCreateKeyRequest {
	return ApiCreateKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
}

func (a *APIClient) CreateKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string) (*Key, error) {
	r := ApiCreateKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
	return r.Execute()
}

type ApiCreateKeyRingRequest struct {
	ctx                  context.Context
	apiService           *DefaultApiService
	projectId            string
	regionId             string
	createKeyRingPayload *CreateKeyRingPayload
}

func (r ApiCreateKeyRingRequest) CreateKeyRingPayload(createKeyRingPayload CreateKeyRingPayload) ApiCreateKeyRingRequest {
	r.createKeyRingPayload = &createKeyRingPayload
	return r
}

func (r ApiCreateKeyRingRequest) Execute() (*KeyRing, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyRing
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateKeyRing")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createKeyRingPayload == nil {
		return localVarReturnValue, fmt.Errorf("createKeyRingPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createKeyRingPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateKeyRing: Create key ring

Creates a new key ring within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@return ApiCreateKeyRingRequest
*/
func (a *APIClient) CreateKeyRing(ctx context.Context, projectId string, regionId string) ApiCreateKeyRingRequest {
	return ApiCreateKeyRingRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) CreateKeyRingExecute(ctx context.Context, projectId string, regionId string) (*KeyRing, error) {
	r := ApiCreateKeyRingRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type ApiCreateWrappingKeyRequest struct {
	ctx                      context.Context
	apiService               *DefaultApiService
	projectId                string
	regionId                 string
	keyRingId                string
	createWrappingKeyPayload *CreateWrappingKeyPayload
}

func (r ApiCreateWrappingKeyRequest) CreateWrappingKeyPayload(createWrappingKeyPayload CreateWrappingKeyPayload) ApiCreateWrappingKeyRequest {
	r.createWrappingKeyPayload = &createWrappingKeyPayload
	return r
}

func (r ApiCreateWrappingKeyRequest) Execute() (*WrappingKey, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WrappingKey
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateWrappingKey")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/wrappingkeys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createWrappingKeyPayload == nil {
		return localVarReturnValue, fmt.Errorf("createWrappingKeyPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createWrappingKeyPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateWrappingKey: Create wrapping key

Creates a new wrapping key for the given key ring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@return ApiCreateWrappingKeyRequest
*/
func (a *APIClient) CreateWrappingKey(ctx context.Context, projectId string, regionId string, keyRingId string) ApiCreateWrappingKeyRequest {
	return ApiCreateWrappingKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
}

func (a *APIClient) CreateWrappingKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string) (*WrappingKey, error) {
	r := ApiCreateWrappingKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
	return r.Execute()
}

type ApiDecryptRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	regionId       string
	keyRingId      string
	keyId          string
	versionNumber  int64
	decryptPayload *DecryptPayload
}

func (r ApiDecryptRequest) DecryptPayload(decryptPayload DecryptPayload) ApiDecryptRequest {
	r.decryptPayload = &decryptPayload
	return r
}

func (r ApiDecryptRequest) Execute() (*DecryptedData, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DecryptedData
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Decrypt")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/decrypt"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.decryptPayload == nil {
		return localVarReturnValue, fmt.Errorf("decryptPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.decryptPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
Decrypt: Decrypt

Decrypts data using the given key version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiDecryptRequest
*/
func (a *APIClient) Decrypt(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiDecryptRequest {
	return ApiDecryptRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) DecryptExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) (*DecryptedData, error) {
	r := ApiDecryptRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiDeleteKeyRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
	keyId      string
}

func (r ApiDeleteKeyRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteKey")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteKey: Delete key

Schedules the deletion of the given key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@return ApiDeleteKeyRequest
*/
func (a *APIClient) DeleteKey(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) ApiDeleteKeyRequest {
	return ApiDeleteKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
}

func (a *APIClient) DeleteKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) error {
	r := ApiDeleteKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
	return r.Execute()
}

type ApiDeleteKeyRingRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
}

func (r ApiDeleteKeyRingRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteKeyRing")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteKeyRing: Delete keyring

Deletes the given key ring if it is empty

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@return ApiDeleteKeyRingRequest
*/
func (a *APIClient) DeleteKeyRing(ctx context.Context, projectId string, regionId string, keyRingId string) ApiDeleteKeyRingRequest {
	return ApiDeleteKeyRingRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
}

func (a *APIClient) DeleteKeyRingExecute(ctx context.Context, projectId string, regionId string, keyRingId string) error {
	r := ApiDeleteKeyRingRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
	return r.Execute()
}

type ApiDestroyVersionRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
}

func (r ApiDestroyVersionRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DestroyVersion")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/destroy"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DestroyVersion: Destroy version

Removes the key material of a version permanently.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiDestroyVersionRequest
*/
func (a *APIClient) DestroyVersion(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiDestroyVersionRequest {
	return ApiDestroyVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) DestroyVersionExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) error {
	r := ApiDestroyVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiDisableVersionRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
}

func (r ApiDisableVersionRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DisableVersion")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DisableVersion: Disable version

Disables the given version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiDisableVersionRequest
*/
func (a *APIClient) DisableVersion(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiDisableVersionRequest {
	return ApiDisableVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) DisableVersionExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) error {
	r := ApiDisableVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiEnableVersionRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
}

func (r ApiEnableVersionRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EnableVersion")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
EnableVersion: Enable version

Enables the given version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiEnableVersionRequest
*/
func (a *APIClient) EnableVersion(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiEnableVersionRequest {
	return ApiEnableVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) EnableVersionExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) error {
	r := ApiEnableVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiEncryptRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	projectId      string
	regionId       string
	keyRingId      string
	keyId          string
	versionNumber  int64
	encryptPayload *EncryptPayload
}

func (r ApiEncryptRequest) EncryptPayload(encryptPayload EncryptPayload) ApiEncryptRequest {
	r.encryptPayload = &encryptPayload
	return r
}

func (r ApiEncryptRequest) Execute() (*EncryptedData, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EncryptedData
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Encrypt")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/encrypt"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.encryptPayload == nil {
		return localVarReturnValue, fmt.Errorf("encryptPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.encryptPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
Encrypt: Encrypt

Encrypts data using the given key version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiEncryptRequest
*/
func (a *APIClient) Encrypt(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiEncryptRequest {
	return ApiEncryptRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) EncryptExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) (*EncryptedData, error) {
	r := ApiEncryptRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiGetKeyRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
	keyId      string
}

func (r ApiGetKeyRequest) Execute() (*Key, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Key
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetKey")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetKey: Get key

Returns the details for the given key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@return ApiGetKeyRequest
*/
func (a *APIClient) GetKey(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) ApiGetKeyRequest {
	return ApiGetKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
}

func (a *APIClient) GetKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) (*Key, error) {
	r := ApiGetKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
	return r.Execute()
}

type ApiGetKeyRingRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
}

func (r ApiGetKeyRingRequest) Execute() (*KeyRing, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyRing
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetKeyRing")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetKeyRing: Get key ring

Returns the details for the given key ring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@return ApiGetKeyRingRequest
*/
func (a *APIClient) GetKeyRing(ctx context.Context, projectId string, regionId string, keyRingId string) ApiGetKeyRingRequest {
	return ApiGetKeyRingRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
}

func (a *APIClient) GetKeyRingExecute(ctx context.Context, projectId string, regionId string, keyRingId string) (*KeyRing, error) {
	r := ApiGetKeyRingRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
	return r.Execute()
}

type ApiGetVersionRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
}

func (r ApiGetVersionRequest) Execute() (*Version, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Version
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVersion")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetVersion: Get version

Returns the details for the given version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiGetVersionRequest
*/
func (a *APIClient) GetVersion(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiGetVersionRequest {
	return ApiGetVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) GetVersionExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) (*Version, error) {
	r := ApiGetVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiGetWrappingKeyRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	wrappingKeyId string
}

func (r ApiGetWrappingKeyRequest) Execute() (*WrappingKey, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WrappingKey
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWrappingKey")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/wrappingkeys/{wrappingKeyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wrappingKeyId"+"}", url.PathEscape(ParameterValueToString(r.wrappingKeyId, "wrappingKeyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetWrappingKey: Get wrapping key

Returns the details for the given wrapping key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param wrappingKeyId The wrapping key UUID.
	@return ApiGetWrappingKeyRequest
*/
func (a *APIClient) GetWrappingKey(ctx context.Context, projectId string, regionId string, keyRingId string, wrappingKeyId string) ApiGetWrappingKeyRequest {
	return ApiGetWrappingKeyRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		wrappingKeyId: wrappingKeyId,
	}
}

func (a *APIClient) GetWrappingKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, wrappingKeyId string) (*WrappingKey, error) {
	r := ApiGetWrappingKeyRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		wrappingKeyId: wrappingKeyId,
	}
	return r.Execute()
}

type ApiImportKeyRequest struct {
	ctx              context.Context
	apiService       *DefaultApiService
	projectId        string
	regionId         string
	keyRingId        string
	keyId            string
	importKeyPayload *ImportKeyPayload
}

func (r ApiImportKeyRequest) ImportKeyPayload(importKeyPayload ImportKeyPayload) ApiImportKeyRequest {
	r.importKeyPayload = &importKeyPayload
	return r
}

func (r ApiImportKeyRequest) Execute() (*Key, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Key
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ImportKey")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/import"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importKeyPayload == nil {
		return localVarReturnValue, fmt.Errorf("importKeyPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importKeyPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ImportKey: Import key

Imports a new version to the given key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@return ApiImportKeyRequest
*/
func (a *APIClient) ImportKey(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) ApiImportKeyRequest {
	return ApiImportKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
}

func (a *APIClient) ImportKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) (*Key, error) {
	r := ApiImportKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
	return r.Execute()
}

type ApiListKeyRingsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
}

func (r ApiListKeyRingsRequest) Execute() (*KeyRingList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyRingList
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListKeyRings")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListKeyRings: List key rings

Returns a list of all key rings within the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@return ApiListKeyRingsRequest
*/
func (a *APIClient) ListKeyRings(ctx context.Context, projectId string, regionId string) ApiListKeyRingsRequest {
	return ApiListKeyRingsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
}

func (a *APIClient) ListKeyRingsExecute(ctx context.Context, projectId string, regionId string) (*KeyRingList, error) {
	r := ApiListKeyRingsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
	}
	return r.Execute()
}

type ApiListKeysRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
}

func (r ApiListKeysRequest) Execute() (*KeyList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyList
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListKeys")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListKeys: List keys

Returns the keys for the given key ring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@return ApiListKeysRequest
*/
func (a *APIClient) ListKeys(ctx context.Context, projectId string, regionId string, keyRingId string) ApiListKeysRequest {
	return ApiListKeysRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
}

func (a *APIClient) ListKeysExecute(ctx context.Context, projectId string, regionId string, keyRingId string) (*KeyList, error) {
	r := ApiListKeysRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
	return r.Execute()
}

type ApiListVersionsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
	keyId      string
}

func (r ApiListVersionsRequest) Execute() (*VersionList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VersionList
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListVersions")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListVersions: List versions

Returns a list of all versions of a given key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@return ApiListVersionsRequest
*/
func (a *APIClient) ListVersions(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) ApiListVersionsRequest {
	return ApiListVersionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
}

func (a *APIClient) ListVersionsExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) (*VersionList, error) {
	r := ApiListVersionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
	return r.Execute()
}

type ApiListWrappingKeysRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
}

func (r ApiListWrappingKeysRequest) Execute() (*WrappingKeyList, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WrappingKeyList
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListWrappingKeys")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/wrappingkeys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListWrappingKeys: List wrapping keys

Returns the wrapping keys for the given key ring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@return ApiListWrappingKeysRequest
*/
func (a *APIClient) ListWrappingKeys(ctx context.Context, projectId string, regionId string, keyRingId string) ApiListWrappingKeysRequest {
	return ApiListWrappingKeysRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
}

func (a *APIClient) ListWrappingKeysExecute(ctx context.Context, projectId string, regionId string, keyRingId string) (*WrappingKeyList, error) {
	r := ApiListWrappingKeysRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
	}
	return r.Execute()
}

type ApiRestoreKeyRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
	keyId      string
}

func (r ApiRestoreKeyRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreKey")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
RestoreKey: Restore deleted key

Restores the given key from being deleted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@return ApiRestoreKeyRequest
*/
func (a *APIClient) RestoreKey(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) ApiRestoreKeyRequest {
	return ApiRestoreKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
}

func (a *APIClient) RestoreKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) error {
	r := ApiRestoreKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
	return r.Execute()
}

type ApiRestoreVersionRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
}

func (r ApiRestoreVersionRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreVersion")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
RestoreVersion: Restore version

Restores the given version from being destroyed

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiRestoreVersionRequest
*/
func (a *APIClient) RestoreVersion(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiRestoreVersionRequest {
	return ApiRestoreVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) RestoreVersionExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) error {
	r := ApiRestoreVersionRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiRotateKeyRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	regionId   string
	keyRingId  string
	keyId      string
}

func (r ApiRotateKeyRequest) Execute() (*Key, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Key
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RotateKey")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
RotateKey: Rotate key

Rotates the given key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@return ApiRotateKeyRequest
*/
func (a *APIClient) RotateKey(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) ApiRotateKeyRequest {
	return ApiRotateKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
}

func (a *APIClient) RotateKeyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string) (*Key, error) {
	r := ApiRotateKeyRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		regionId:   regionId,
		keyRingId:  keyRingId,
		keyId:      keyId,
	}
	return r.Execute()
}

type ApiSignRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
	signPayload   *SignPayload
}

func (r ApiSignRequest) SignPayload(signPayload SignPayload) ApiSignRequest {
	r.signPayload = &signPayload
	return r
}

func (r ApiSignRequest) Execute() (*SignedData, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SignedData
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Sign")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/sign"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signPayload == nil {
		return localVarReturnValue, fmt.Errorf("signPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
Sign: Sign

Sign data using the given key version as secret.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiSignRequest
*/
func (a *APIClient) Sign(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiSignRequest {
	return ApiSignRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) SignExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) (*SignedData, error) {
	r := ApiSignRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}

type ApiVerifyRequest struct {
	ctx           context.Context
	apiService    *DefaultApiService
	projectId     string
	regionId      string
	keyRingId     string
	keyId         string
	versionNumber int64
	verifyPayload *VerifyPayload
}

func (r ApiVerifyRequest) VerifyPayload(verifyPayload VerifyPayload) ApiVerifyRequest {
	r.verifyPayload = &verifyPayload
	return r
}

func (r ApiVerifyRequest) Execute() (*VerifiedData, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VerifiedData
	)
	a := r.apiService
	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Verify")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta/projects/{projectId}/regions/{regionId}/keyrings/{keyRingId}/keys/{keyId}/versions/{versionNumber}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(ParameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyRingId"+"}", url.PathEscape(ParameterValueToString(r.keyRingId, "keyRingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(ParameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionNumber"+"}", url.PathEscape(ParameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyPayload == nil {
		return localVarReturnValue, fmt.Errorf("verifyPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HttpError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
Verify: Verify

Verify data using the given key version as secret.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The STACKIT portal project UUID the key ring is part of.
	@param regionId The STACKIT region name the key ring is located in.
	@param keyRingId The key ring UUID.
	@param keyId The key UUID.
	@param versionNumber The version number.
	@return ApiVerifyRequest
*/
func (a *APIClient) Verify(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) ApiVerifyRequest {
	return ApiVerifyRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
}

func (a *APIClient) VerifyExecute(ctx context.Context, projectId string, regionId string, keyRingId string, keyId string, versionNumber int64) (*VerifiedData, error) {
	r := ApiVerifyRequest{
		apiService:    a.defaultApi,
		ctx:           ctx,
		projectId:     projectId,
		regionId:      regionId,
		keyRingId:     keyRingId,
		keyId:         keyId,
		versionNumber: versionNumber,
	}
	return r.Execute()
}
