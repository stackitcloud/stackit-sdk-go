/*
STACKIT Key Management Service API

This API provides endpoints for managing keys and key rings.

API version: 1beta.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kms

import (
	"encoding/json"
)

// checks if the DecryptedData type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &DecryptedData{}

/*
	types and functions for data
*/

// isByteArray
type DecryptedDataGetDataAttributeType = *[]byte
type DecryptedDataGetDataArgType = []byte
type DecryptedDataGetDataRetType = []byte

func getDecryptedDataGetDataAttributeTypeOk(arg DecryptedDataGetDataAttributeType) (ret DecryptedDataGetDataRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setDecryptedDataGetDataAttributeType(arg *DecryptedDataGetDataAttributeType, val DecryptedDataGetDataRetType) {
	*arg = &val
}

// DecryptedData struct for DecryptedData
type DecryptedData struct {
	// The decrypted data. Encoded in base64.
	// REQUIRED
	Data DecryptedDataGetDataAttributeType `json:"data" required:"true"`
}

type _DecryptedData DecryptedData

// NewDecryptedData instantiates a new DecryptedData object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewDecryptedData(data DecryptedDataGetDataArgType) *DecryptedData {
	this := DecryptedData{}
	setDecryptedDataGetDataAttributeType(&this.Data, data)
	return &this
}

// NewDecryptedDataWithDefaults instantiates a new DecryptedData object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewDecryptedDataWithDefaults() *DecryptedData {
	this := DecryptedData{}
	return &this
}

// GetData returns the Data field value
func (o *DecryptedData) GetData() (ret DecryptedDataGetDataRetType) {
	ret, _ = o.GetDataOk()
	return ret
}

// GetDataOk returns a tuple with the Data field value
// and a boolean to check if the value has been set.
func (o *DecryptedData) GetDataOk() (ret DecryptedDataGetDataRetType, ok bool) {
	return getDecryptedDataGetDataAttributeTypeOk(o.Data)
}

// SetData sets field value
func (o *DecryptedData) SetData(v DecryptedDataGetDataRetType) {
	setDecryptedDataGetDataAttributeType(&o.Data, v)
}

func (o DecryptedData) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if val, ok := getDecryptedDataGetDataAttributeTypeOk(o.Data); ok {
		toSerialize["Data"] = val
	}
	return toSerialize, nil
}

type NullableDecryptedData struct {
	value *DecryptedData
	isSet bool
}

func (v NullableDecryptedData) Get() *DecryptedData {
	return v.value
}

func (v *NullableDecryptedData) Set(val *DecryptedData) {
	v.value = val
	v.isSet = true
}

func (v NullableDecryptedData) IsSet() bool {
	return v.isSet
}

func (v *NullableDecryptedData) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDecryptedData(val *DecryptedData) *NullableDecryptedData {
	return &NullableDecryptedData{value: val, isSet: true}
}

func (v NullableDecryptedData) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDecryptedData) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
