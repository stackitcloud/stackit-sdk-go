/*
STACKIT MSSQL Service API

This is the documentation for the STACKIT MSSQL service

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sqlserverflex

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateDatabase Create a Database
		Create a Database for an instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiCreateDatabaseRequest
	*/
	CreateDatabase(ctx context.Context, projectId string, instanceId string, region string) ApiCreateDatabaseRequest
	/*
		CreateDatabaseExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return CreateDatabaseResponse

	*/
	CreateDatabaseExecute(ctx context.Context, projectId string, instanceId string, region string) (*CreateDatabaseResponse, error)
	/*
		CreateInstance Create Instance
		Create a new instance of a sqlServerCRD database

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ApiCreateInstanceRequest
	*/
	CreateInstance(ctx context.Context, projectId string, region string) ApiCreateInstanceRequest
	/*
		CreateInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return CreateInstanceResponse

	*/
	CreateInstanceExecute(ctx context.Context, projectId string, region string) (*CreateInstanceResponse, error)
	/*
		CreateUser Create User
		Create user for an instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiCreateUserRequest
	*/
	CreateUser(ctx context.Context, projectId string, instanceId string, region string) ApiCreateUserRequest
	/*
		CreateUserExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return CreateUserResponse

	*/
	CreateUserExecute(ctx context.Context, projectId string, instanceId string, region string) (*CreateUserResponse, error)
	/*
		DeleteDatabase Delete Database
		Delete Database for an instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param databaseName Database Name
		@param region The region which should be addressed
		@return ApiDeleteDatabaseRequest
	*/
	DeleteDatabase(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiDeleteDatabaseRequest
	/*
		DeleteDatabaseExecute executes the request

	*/
	DeleteDatabaseExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) error
	/*
		DeleteInstance Delete Instance
		Delete available instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiDeleteInstanceRequest
	*/
	DeleteInstance(ctx context.Context, projectId string, instanceId string, region string) ApiDeleteInstanceRequest
	/*
		DeleteInstanceExecute executes the request

	*/
	DeleteInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) error
	/*
		DeleteUser Delete User
		Delete user for an instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param userId User ID
		@param region The region which should be addressed
		@return ApiDeleteUserRequest
	*/
	DeleteUser(ctx context.Context, projectId string, instanceId string, userId string, region string) ApiDeleteUserRequest
	/*
		DeleteUserExecute executes the request

	*/
	DeleteUserExecute(ctx context.Context, projectId string, instanceId string, userId string, region string) error
	/*
		GetBackup Get specific backup
		Get specific available backup

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param backupId Backup ID
		@param region The region which should be addressed
		@return ApiGetBackupRequest
	*/
	GetBackup(ctx context.Context, projectId string, instanceId string, backupId string, region string) ApiGetBackupRequest
	/*
		GetBackupExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param backupId Backup ID
		@param region The region which should be addressed
		@return GetBackupResponse

	*/
	GetBackupExecute(ctx context.Context, projectId string, instanceId string, backupId string, region string) (*GetBackupResponse, error)
	/*
		GetDatabase Get specific Database
		Get specific available database

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param databaseName Database Name
		@param region The region which should be addressed
		@return ApiGetDatabaseRequest
	*/
	GetDatabase(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiGetDatabaseRequest
	/*
		GetDatabaseExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param databaseName Database Name
		@param region The region which should be addressed
		@return GetDatabaseResponse

	*/
	GetDatabaseExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) (*GetDatabaseResponse, error)
	/*
		GetInstance Get specific instance
		Get specific available instances

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiGetInstanceRequest
	*/
	GetInstance(ctx context.Context, projectId string, instanceId string, region string) ApiGetInstanceRequest
	/*
		GetInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return GetInstanceResponse

	*/
	GetInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) (*GetInstanceResponse, error)
	/*
		GetUser Get User
		Get specific available user for an instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param userId User ID
		@param region The region which should be addressed
		@return ApiGetUserRequest
	*/
	GetUser(ctx context.Context, projectId string, instanceId string, userId string, region string) ApiGetUserRequest
	/*
		GetUserExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param userId User ID
		@param region The region which should be addressed
		@return GetUserResponse

	*/
	GetUserExecute(ctx context.Context, projectId string, instanceId string, userId string, region string) (*GetUserResponse, error)
	/*
		ListBackups List backups
		List all backups which are available for a specific instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiListBackupsRequest
	*/
	ListBackups(ctx context.Context, projectId string, instanceId string, region string) ApiListBackupsRequest
	/*
		ListBackupsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ListBackupsResponse

	*/
	ListBackupsExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListBackupsResponse, error)
	/*
		ListCollations Get database collation list
		Returns a list of collations

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The ID of the STACKIT project
		@param instanceId The ID of the instance
		@param region The region which should be addressed
		@return ApiListCollationsRequest
	*/
	ListCollations(ctx context.Context, projectId string, instanceId string, region string) ApiListCollationsRequest
	/*
		ListCollationsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The ID of the STACKIT project
		@param instanceId The ID of the instance
		@param region The region which should be addressed
		@return ListCollationsResponse

	*/
	ListCollationsExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListCollationsResponse, error)
	/*
		ListCompatibility Get database compatibility list
		Returns a list of compatibility levels for creating a new database

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The ID of the STACKIT project
		@param instanceId The ID of the instance
		@param region The region which should be addressed
		@return ApiListCompatibilityRequest
	*/
	ListCompatibility(ctx context.Context, projectId string, instanceId string, region string) ApiListCompatibilityRequest
	/*
		ListCompatibilityExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The ID of the STACKIT project
		@param instanceId The ID of the instance
		@param region The region which should be addressed
		@return ListCompatibilityResponse

	*/
	ListCompatibilityExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListCompatibilityResponse, error)
	/*
		ListDatabases Get list of databases
		Get list of all databases in the instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiListDatabasesRequest
	*/
	ListDatabases(ctx context.Context, projectId string, instanceId string, region string) ApiListDatabasesRequest
	/*
		ListDatabasesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ListDatabasesResponse

	*/
	ListDatabasesExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListDatabasesResponse, error)
	/*
		ListFlavors Get Flavors
		Get available flavors for a specific projectID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ApiListFlavorsRequest
	*/
	ListFlavors(ctx context.Context, projectId string, region string) ApiListFlavorsRequest
	/*
		ListFlavorsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ListFlavorsResponse

	*/
	ListFlavorsExecute(ctx context.Context, projectId string, region string) (*ListFlavorsResponse, error)
	/*
		ListInstances List Instances
		List available instances

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ApiListInstancesRequest
	*/
	ListInstances(ctx context.Context, projectId string, region string) ApiListInstancesRequest
	/*
		ListInstancesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ListInstancesResponse

	*/
	ListInstancesExecute(ctx context.Context, projectId string, region string) (*ListInstancesResponse, error)
	/*
		ListMetrics Get Metric
		Returns a metric for an instance. The metric will only be for the master pod if needed. Granularity parameter is always needed. If start and end time is provided, period is not considered in max-connections and disk-use. If you provide start time, you have to provide end time as well and vice versa.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The UUID of the project.
		@param instanceId The UUID of the instance.
		@param metric The name of the metric. Valid metrics are 'cpu', 'memory', 'data-disk-size', 'data-disk-use','log-disk-size', 'log-disk-use', 'life-expectancy' and 'connections'.
		@return ApiListMetricsRequest
	*/
	ListMetrics(ctx context.Context, projectId string, instanceId string, metric string) ApiListMetricsRequest
	/*
		ListMetricsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId The UUID of the project.
		@param instanceId The UUID of the instance.
		@param metric The name of the metric. Valid metrics are 'cpu', 'memory', 'data-disk-size', 'data-disk-use','log-disk-size', 'log-disk-use', 'life-expectancy' and 'connections'.
		@return ListMetricsResponse

	*/
	ListMetricsExecute(ctx context.Context, projectId string, instanceId string, metric string) (*ListMetricsResponse, error)
	/*
		ListRestoreJobs List current running restore jobs
		List all currently running restore jobs which are available for a specific instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiListRestoreJobsRequest
	*/
	ListRestoreJobs(ctx context.Context, projectId string, instanceId string, region string) ApiListRestoreJobsRequest
	/*
		ListRestoreJobsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ListRestoreJobsResponse

	*/
	ListRestoreJobsExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListRestoreJobsResponse, error)
	/*
		ListRoles List Roles
		List available roles for an instance that can be assigned to a user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiListRolesRequest
	*/
	ListRoles(ctx context.Context, projectId string, instanceId string, region string) ApiListRolesRequest
	/*
		ListRolesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ListRolesResponse

	*/
	ListRolesExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListRolesResponse, error)
	/*
		ListStorages Get Storages
		Get available storages for a specific flavor

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param flavorId Flavor ID
		@param region The region which should be addressed
		@return ApiListStoragesRequest
	*/
	ListStorages(ctx context.Context, projectId string, flavorId string, region string) ApiListStoragesRequest
	/*
		ListStoragesExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param flavorId Flavor ID
		@param region The region which should be addressed
		@return ListStoragesResponse

	*/
	ListStoragesExecute(ctx context.Context, projectId string, flavorId string, region string) (*ListStoragesResponse, error)
	/*
		ListUsers List Users
		List available users for an instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiListUsersRequest
	*/
	ListUsers(ctx context.Context, projectId string, instanceId string, region string) ApiListUsersRequest
	/*
		ListUsersExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ListUsersResponse

	*/
	ListUsersExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListUsersResponse, error)
	/*
		ListVersions Get Versions
		Get available versions for mssql database

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ApiListVersionsRequest
	*/
	ListVersions(ctx context.Context, projectId string, region string) ApiListVersionsRequest
	/*
		ListVersionsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ListVersionsResponse

	*/
	ListVersionsExecute(ctx context.Context, projectId string, region string) (*ListVersionsResponse, error)
	/*
		PartialUpdateInstance Update Instance
		Update available instance of a mssql database.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiPartialUpdateInstanceRequest
	*/
	PartialUpdateInstance(ctx context.Context, projectId string, instanceId string, region string) ApiPartialUpdateInstanceRequest
	/*
		PartialUpdateInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return UpdateInstanceResponse

	*/
	PartialUpdateInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) (*UpdateInstanceResponse, error)
	/*
		ResetUser Reset User
		Reset user password for a mssql instance

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param userId user ID
		@param region The region which should be addressed
		@return ApiResetUserRequest
	*/
	ResetUser(ctx context.Context, projectId string, instanceId string, userId string, region string) ApiResetUserRequest
	/*
		ResetUserExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param userId user ID
		@param region The region which should be addressed
		@return ResetUserResponse

	*/
	ResetUserExecute(ctx context.Context, projectId string, instanceId string, userId string, region string) (*ResetUserResponse, error)
	/*
		TerminateProject Terminate the Project
		Termination is the deletion of a whole project which causes the deletion of all instances for this project. Only System with permission system.databases-project.remove is able to call this resource

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param region The region which should be addressed
		@return ApiTerminateProjectRequest
	*/
	TerminateProject(ctx context.Context, projectId string, region string) ApiTerminateProjectRequest
	/*
		TerminateProjectExecute executes the request

	*/
	TerminateProjectExecute(ctx context.Context, projectId string, region string) error
	/*
		TriggerDatabaseBackup Trigger backup for a specific Database
		Trigger backup for a specific Database

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param databaseName Database Name
		@param region The region which should be addressed
		@return ApiTriggerDatabaseBackupRequest
	*/
	TriggerDatabaseBackup(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiTriggerDatabaseBackupRequest
	/*
		TriggerDatabaseBackupExecute executes the request

	*/
	TriggerDatabaseBackupExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) error
	/*
		TriggerDatabaseRestore Trigger restore for a specific Database
		Trigger restore for a specific Database

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param databaseName Database Name
		@param region The region which should be addressed
		@return ApiTriggerDatabaseRestoreRequest
	*/
	TriggerDatabaseRestore(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiTriggerDatabaseRestoreRequest
	/*
		TriggerDatabaseRestoreExecute executes the request

	*/
	TriggerDatabaseRestoreExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) error
	/*
		UpdateInstance Update Instance
		Update available instance of a mssql database.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return ApiUpdateInstanceRequest
	*/
	UpdateInstance(ctx context.Context, projectId string, instanceId string, region string) ApiUpdateInstanceRequest
	/*
		UpdateInstanceExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param projectId Project ID
		@param instanceId Instance ID
		@param region The region which should be addressed
		@return UpdateInstanceResponse

	*/
	UpdateInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) (*UpdateInstanceResponse, error)
}

type ApiCreateDatabaseRequest interface {
	// Body
	CreateDatabasePayload(createDatabasePayload CreateDatabasePayload) ApiCreateDatabaseRequest
	Execute() (*CreateDatabaseResponse, error)
}

type ApiCreateInstanceRequest interface {
	// Body
	CreateInstancePayload(createInstancePayload CreateInstancePayload) ApiCreateInstanceRequest
	Execute() (*CreateInstanceResponse, error)
}

type ApiCreateUserRequest interface {
	// The request body contains a username, a list of roles and database. The possible roles  can be fetched from the ListRoles endpoint.
	CreateUserPayload(createUserPayload CreateUserPayload) ApiCreateUserRequest
	Execute() (*CreateUserResponse, error)
}

type ApiDeleteDatabaseRequest interface {
	Execute() error
}

type ApiDeleteInstanceRequest interface {
	Execute() error
}

type ApiDeleteUserRequest interface {
	Execute() error
}

type ApiGetBackupRequest interface {
	Execute() (*GetBackupResponse, error)
}

type ApiGetDatabaseRequest interface {
	Execute() (*GetDatabaseResponse, error)
}

type ApiGetInstanceRequest interface {
	Execute() (*GetInstanceResponse, error)
}

type ApiGetUserRequest interface {
	Execute() (*GetUserResponse, error)
}

type ApiListBackupsRequest interface {
	Execute() (*ListBackupsResponse, error)
}

type ApiListCollationsRequest interface {
	Execute() (*ListCollationsResponse, error)
}

type ApiListCompatibilityRequest interface {
	Execute() (*ListCompatibilityResponse, error)
}

type ApiListDatabasesRequest interface {
	Execute() (*ListDatabasesResponse, error)
}

type ApiListFlavorsRequest interface {
	Execute() (*ListFlavorsResponse, error)
}

type ApiListInstancesRequest interface {
	Execute() (*ListInstancesResponse, error)
}

type ApiListMetricsRequest interface {
	// The granularity in ISO8601 e.g. 5 minutes are &#39;PT5M&#39;.
	Granularity(granularity string) ApiListMetricsRequest
	// The period in ISO8601 format e.g. 5 minutes are &#39;PT5M&#39;. If no period is provided, the standard value of 5 minutes is used.
	Period(period string) ApiListMetricsRequest
	// The start of the timeframe as timestamp in ISO8601 (RFC3339) e.g. &#39;2023-08-28T07:10:52.536Z&#39;. If no start time is provided, current server time as UTC is used.
	Start(start string) ApiListMetricsRequest
	// The end of the timeframe as timestamp in ISO8601 (RFC3339) e.g. &#39;2023-08-28T07:10:52.536Z&#39;.
	End(end string) ApiListMetricsRequest
	Execute() (*ListMetricsResponse, error)
}

type ApiListRestoreJobsRequest interface {
	Execute() (*ListRestoreJobsResponse, error)
}

type ApiListRolesRequest interface {
	Execute() (*ListRolesResponse, error)
}

type ApiListStoragesRequest interface {
	Execute() (*ListStoragesResponse, error)
}

type ApiListUsersRequest interface {
	Execute() (*ListUsersResponse, error)
}

type ApiListVersionsRequest interface {
	// Instance ID
	InstanceId(instanceId string) ApiListVersionsRequest
	Execute() (*ListVersionsResponse, error)
}

type ApiPartialUpdateInstanceRequest interface {
	// Body
	PartialUpdateInstancePayload(partialUpdateInstancePayload PartialUpdateInstancePayload) ApiPartialUpdateInstanceRequest
	Execute() (*UpdateInstanceResponse, error)
}

type ApiResetUserRequest interface {
	Execute() (*ResetUserResponse, error)
}

type ApiTerminateProjectRequest interface {
	Execute() error
}

type ApiTriggerDatabaseBackupRequest interface {
	Execute() error
}

type ApiTriggerDatabaseRestoreRequest interface {
	// Body
	TriggerDatabaseRestorePayload(triggerDatabaseRestorePayload TriggerDatabaseRestorePayload) ApiTriggerDatabaseRestoreRequest
	Execute() error
}

type ApiUpdateInstanceRequest interface {
	// Body
	UpdateInstancePayload(updateInstancePayload UpdateInstancePayload) ApiUpdateInstanceRequest
	Execute() (*UpdateInstanceResponse, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateDatabaseRequest struct {
	ctx                   context.Context
	apiService            *DefaultApiService
	projectId             string
	instanceId            string
	region                string
	createDatabasePayload *CreateDatabasePayload
}

// Body

func (r CreateDatabaseRequest) CreateDatabasePayload(createDatabasePayload CreateDatabasePayload) ApiCreateDatabaseRequest {
	r.createDatabasePayload = &createDatabasePayload
	return r
}

func (r CreateDatabaseRequest) Execute() (*CreateDatabaseResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateDatabaseResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateDatabase")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/databases"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDatabasePayload == nil {
		return localVarReturnValue, fmt.Errorf("createDatabasePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDatabasePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateDatabase: Create a Database

Create a Database for an instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiCreateDatabaseRequest
*/
func (a *APIClient) CreateDatabase(ctx context.Context, projectId string, instanceId string, region string) ApiCreateDatabaseRequest {
	return CreateDatabaseRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) CreateDatabaseExecute(ctx context.Context, projectId string, instanceId string, region string) (*CreateDatabaseResponse, error) {
	r := CreateDatabaseRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type CreateInstanceRequest struct {
	ctx                   context.Context
	apiService            *DefaultApiService
	projectId             string
	region                string
	createInstancePayload *CreateInstancePayload
}

// Body

func (r CreateInstanceRequest) CreateInstancePayload(createInstancePayload CreateInstancePayload) ApiCreateInstanceRequest {
	r.createInstancePayload = &createInstancePayload
	return r
}

func (r CreateInstanceRequest) Execute() (*CreateInstanceResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateInstanceResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createInstancePayload == nil {
		return localVarReturnValue, fmt.Errorf("createInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateInstance: Create Instance

Create a new instance of a sqlServerCRD database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param region The region which should be addressed
	@return ApiCreateInstanceRequest
*/
func (a *APIClient) CreateInstance(ctx context.Context, projectId string, region string) ApiCreateInstanceRequest {
	return CreateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) CreateInstanceExecute(ctx context.Context, projectId string, region string) (*CreateInstanceResponse, error) {
	r := CreateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type CreateUserRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	projectId         string
	instanceId        string
	region            string
	createUserPayload *CreateUserPayload
}

// The request body contains a username, a list of roles and database. The possible roles  can be fetched from the ListRoles endpoint.

func (r CreateUserRequest) CreateUserPayload(createUserPayload CreateUserPayload) ApiCreateUserRequest {
	r.createUserPayload = &createUserPayload
	return r
}

func (r CreateUserRequest) Execute() (*CreateUserResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateUserResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateUser")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createUserPayload == nil {
		return localVarReturnValue, fmt.Errorf("createUserPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createUserPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateUser: Create User

Create user for an instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiCreateUserRequest
*/
func (a *APIClient) CreateUser(ctx context.Context, projectId string, instanceId string, region string) ApiCreateUserRequest {
	return CreateUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) CreateUserExecute(ctx context.Context, projectId string, instanceId string, region string) (*CreateUserResponse, error) {
	r := CreateUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type DeleteDatabaseRequest struct {
	ctx          context.Context
	apiService   *DefaultApiService
	projectId    string
	instanceId   string
	databaseName string
	region       string
}

func (r DeleteDatabaseRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDatabase")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/databases/{databaseName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"databaseName"+"}", url.PathEscape(ParameterValueToString(r.databaseName, "databaseName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteDatabase: Delete Database

Delete Database for an instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param databaseName Database Name
	@param region The region which should be addressed
	@return ApiDeleteDatabaseRequest
*/
func (a *APIClient) DeleteDatabase(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiDeleteDatabaseRequest {
	return DeleteDatabaseRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
}

func (a *APIClient) DeleteDatabaseExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) error {
	r := DeleteDatabaseRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
	return r.Execute()
}

type DeleteInstanceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r DeleteInstanceRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteInstance")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteInstance: Delete Instance

Delete available instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiDeleteInstanceRequest
*/
func (a *APIClient) DeleteInstance(ctx context.Context, projectId string, instanceId string, region string) ApiDeleteInstanceRequest {
	return DeleteInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) DeleteInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) error {
	r := DeleteInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type DeleteUserRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	userId     string
	region     string
}

func (r DeleteUserRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteUser")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(ParameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		return newErr
	}

	return nil
}

/*
DeleteUser: Delete User

Delete user for an instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param userId User ID
	@param region The region which should be addressed
	@return ApiDeleteUserRequest
*/
func (a *APIClient) DeleteUser(ctx context.Context, projectId string, instanceId string, userId string, region string) ApiDeleteUserRequest {
	return DeleteUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		userId:     userId,
		region:     region,
	}
}

func (a *APIClient) DeleteUserExecute(ctx context.Context, projectId string, instanceId string, userId string, region string) error {
	r := DeleteUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		userId:     userId,
		region:     region,
	}
	return r.Execute()
}

type GetBackupRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	backupId   string
	region     string
}

func (r GetBackupRequest) Execute() (*GetBackupResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetBackupResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBackup")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(ParameterValueToString(r.backupId, "backupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetBackup: Get specific backup

Get specific available backup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param backupId Backup ID
	@param region The region which should be addressed
	@return ApiGetBackupRequest
*/
func (a *APIClient) GetBackup(ctx context.Context, projectId string, instanceId string, backupId string, region string) ApiGetBackupRequest {
	return GetBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		backupId:   backupId,
		region:     region,
	}
}

func (a *APIClient) GetBackupExecute(ctx context.Context, projectId string, instanceId string, backupId string, region string) (*GetBackupResponse, error) {
	r := GetBackupRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		backupId:   backupId,
		region:     region,
	}
	return r.Execute()
}

type GetDatabaseRequest struct {
	ctx          context.Context
	apiService   *DefaultApiService
	projectId    string
	instanceId   string
	databaseName string
	region       string
}

func (r GetDatabaseRequest) Execute() (*GetDatabaseResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDatabaseResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDatabase")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/databases/{databaseName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"databaseName"+"}", url.PathEscape(ParameterValueToString(r.databaseName, "databaseName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetDatabase: Get specific Database

Get specific available database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param databaseName Database Name
	@param region The region which should be addressed
	@return ApiGetDatabaseRequest
*/
func (a *APIClient) GetDatabase(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiGetDatabaseRequest {
	return GetDatabaseRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
}

func (a *APIClient) GetDatabaseExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) (*GetDatabaseResponse, error) {
	r := GetDatabaseRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
	return r.Execute()
}

type GetInstanceRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r GetInstanceRequest) Execute() (*GetInstanceResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetInstanceResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetInstance: Get specific instance

Get specific available instances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiGetInstanceRequest
*/
func (a *APIClient) GetInstance(ctx context.Context, projectId string, instanceId string, region string) ApiGetInstanceRequest {
	return GetInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) GetInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) (*GetInstanceResponse, error) {
	r := GetInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type GetUserRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	userId     string
	region     string
}

func (r GetUserRequest) Execute() (*GetUserResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetUserResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUser")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(ParameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetUser: Get User

Get specific available user for an instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param userId User ID
	@param region The region which should be addressed
	@return ApiGetUserRequest
*/
func (a *APIClient) GetUser(ctx context.Context, projectId string, instanceId string, userId string, region string) ApiGetUserRequest {
	return GetUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		userId:     userId,
		region:     region,
	}
}

func (a *APIClient) GetUserExecute(ctx context.Context, projectId string, instanceId string, userId string, region string) (*GetUserResponse, error) {
	r := GetUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		userId:     userId,
		region:     region,
	}
	return r.Execute()
}

type ListBackupsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListBackupsRequest) Execute() (*ListBackupsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListBackupsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListBackups")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListBackups: List backups

List all backups which are available for a specific instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiListBackupsRequest
*/
func (a *APIClient) ListBackups(ctx context.Context, projectId string, instanceId string, region string) ApiListBackupsRequest {
	return ListBackupsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListBackupsExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListBackupsResponse, error) {
	r := ListBackupsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListCollationsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListCollationsRequest) Execute() (*ListCollationsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCollationsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCollations")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/collation"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListCollations: Get database collation list

Returns a list of collations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The ID of the STACKIT project
	@param instanceId The ID of the instance
	@param region The region which should be addressed
	@return ApiListCollationsRequest
*/
func (a *APIClient) ListCollations(ctx context.Context, projectId string, instanceId string, region string) ApiListCollationsRequest {
	return ListCollationsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListCollationsExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListCollationsResponse, error) {
	r := ListCollationsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListCompatibilityRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListCompatibilityRequest) Execute() (*ListCompatibilityResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCompatibilityResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCompatibility")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/compatibility"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListCompatibility: Get database compatibility list

Returns a list of compatibility levels for creating a new database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The ID of the STACKIT project
	@param instanceId The ID of the instance
	@param region The region which should be addressed
	@return ApiListCompatibilityRequest
*/
func (a *APIClient) ListCompatibility(ctx context.Context, projectId string, instanceId string, region string) ApiListCompatibilityRequest {
	return ListCompatibilityRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListCompatibilityExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListCompatibilityResponse, error) {
	r := ListCompatibilityRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListDatabasesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListDatabasesRequest) Execute() (*ListDatabasesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListDatabasesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListDatabases")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/databases"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListDatabases: Get list of databases

Get list of all databases in the instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiListDatabasesRequest
*/
func (a *APIClient) ListDatabases(ctx context.Context, projectId string, instanceId string, region string) ApiListDatabasesRequest {
	return ListDatabasesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListDatabasesExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListDatabasesResponse, error) {
	r := ListDatabasesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListFlavorsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	region     string
}

func (r ListFlavorsRequest) Execute() (*ListFlavorsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListFlavorsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListFlavors")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/flavors"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListFlavors: Get Flavors

Get available flavors for a specific projectID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param region The region which should be addressed
	@return ApiListFlavorsRequest
*/
func (a *APIClient) ListFlavors(ctx context.Context, projectId string, region string) ApiListFlavorsRequest {
	return ListFlavorsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) ListFlavorsExecute(ctx context.Context, projectId string, region string) (*ListFlavorsResponse, error) {
	r := ListFlavorsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type ListInstancesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	region     string
}

func (r ListInstancesRequest) Execute() (*ListInstancesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListInstancesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListInstances")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListInstances: List Instances

List available instances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param region The region which should be addressed
	@return ApiListInstancesRequest
*/
func (a *APIClient) ListInstances(ctx context.Context, projectId string, region string) ApiListInstancesRequest {
	return ListInstancesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) ListInstancesExecute(ctx context.Context, projectId string, region string) (*ListInstancesResponse, error) {
	r := ListInstancesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type ListMetricsRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	projectId   string
	instanceId  string
	metric      string
	granularity *string
	period      *string
	start       *string
	end         *string
}

// The granularity in ISO8601 e.g. 5 minutes are &#39;PT5M&#39;.

func (r ListMetricsRequest) Granularity(granularity string) ApiListMetricsRequest {
	r.granularity = &granularity
	return r
}

// The period in ISO8601 format e.g. 5 minutes are &#39;PT5M&#39;. If no period is provided, the standard value of 5 minutes is used.

func (r ListMetricsRequest) Period(period string) ApiListMetricsRequest {
	r.period = &period
	return r
}

// The start of the timeframe as timestamp in ISO8601 (RFC3339) e.g. &#39;2023-08-28T07:10:52.536Z&#39;. If no start time is provided, current server time as UTC is used.

func (r ListMetricsRequest) Start(start string) ApiListMetricsRequest {
	r.start = &start
	return r
}

// The end of the timeframe as timestamp in ISO8601 (RFC3339) e.g. &#39;2023-08-28T07:10:52.536Z&#39;.

func (r ListMetricsRequest) End(end string) ApiListMetricsRequest {
	r.end = &end
	return r
}

func (r ListMetricsRequest) Execute() (*ListMetricsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMetricsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListMetrics")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/instances/{instanceId}/metrics/{metric}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(ParameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.granularity == nil {
		return localVarReturnValue, fmt.Errorf("granularity is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListMetrics: Get Metric

Returns a metric for an instance. The metric will only be for the master pod if needed. Granularity parameter is always needed. If start and end time is provided, period is not considered in max-connections and disk-use. If you provide start time, you have to provide end time as well and vice versa.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId The UUID of the project.
	@param instanceId The UUID of the instance.
	@param metric The name of the metric. Valid metrics are 'cpu', 'memory', 'data-disk-size', 'data-disk-use','log-disk-size', 'log-disk-use', 'life-expectancy' and 'connections'.
	@return ApiListMetricsRequest
*/
func (a *APIClient) ListMetrics(ctx context.Context, projectId string, instanceId string, metric string) ApiListMetricsRequest {
	return ListMetricsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		metric:     metric,
	}
}

func (a *APIClient) ListMetricsExecute(ctx context.Context, projectId string, instanceId string, metric string) (*ListMetricsResponse, error) {
	r := ListMetricsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		metric:     metric,
	}
	return r.Execute()
}

type ListRestoreJobsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListRestoreJobsRequest) Execute() (*ListRestoreJobsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRestoreJobsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRestoreJobs")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRestoreJobs: List current running restore jobs

List all currently running restore jobs which are available for a specific instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiListRestoreJobsRequest
*/
func (a *APIClient) ListRestoreJobs(ctx context.Context, projectId string, instanceId string, region string) ApiListRestoreJobsRequest {
	return ListRestoreJobsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListRestoreJobsExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListRestoreJobsResponse, error) {
	r := ListRestoreJobsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListRolesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListRolesRequest) Execute() (*ListRolesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRolesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoles")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListRoles: List Roles

List available roles for an instance that can be assigned to a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiListRolesRequest
*/
func (a *APIClient) ListRoles(ctx context.Context, projectId string, instanceId string, region string) ApiListRolesRequest {
	return ListRolesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListRolesExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListRolesResponse, error) {
	r := ListRolesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListStoragesRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	flavorId   string
	region     string
}

func (r ListStoragesRequest) Execute() (*ListStoragesResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListStoragesResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListStorages")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/storages/{flavorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flavorId"+"}", url.PathEscape(ParameterValueToString(r.flavorId, "flavorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListStorages: Get Storages

Get available storages for a specific flavor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param flavorId Flavor ID
	@param region The region which should be addressed
	@return ApiListStoragesRequest
*/
func (a *APIClient) ListStorages(ctx context.Context, projectId string, flavorId string, region string) ApiListStoragesRequest {
	return ListStoragesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		flavorId:   flavorId,
		region:     region,
	}
}

func (a *APIClient) ListStoragesExecute(ctx context.Context, projectId string, flavorId string, region string) (*ListStoragesResponse, error) {
	r := ListStoragesRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		flavorId:   flavorId,
		region:     region,
	}
	return r.Execute()
}

type ListUsersRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	region     string
}

func (r ListUsersRequest) Execute() (*ListUsersResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListUsersResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsers")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListUsers: List Users

List available users for an instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiListUsersRequest
*/
func (a *APIClient) ListUsers(ctx context.Context, projectId string, instanceId string, region string) ApiListUsersRequest {
	return ListUsersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) ListUsersExecute(ctx context.Context, projectId string, instanceId string, region string) (*ListUsersResponse, error) {
	r := ListUsersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ListVersionsRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	region     string
	instanceId *string
}

// Instance ID

func (r ListVersionsRequest) InstanceId(instanceId string) ApiListVersionsRequest {
	r.instanceId = &instanceId
	return r
}

func (r ListVersionsRequest) Execute() (*ListVersionsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListVersionsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListVersions")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListVersions: Get Versions

Get available versions for mssql database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param region The region which should be addressed
	@return ApiListVersionsRequest
*/
func (a *APIClient) ListVersions(ctx context.Context, projectId string, region string) ApiListVersionsRequest {
	return ListVersionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) ListVersionsExecute(ctx context.Context, projectId string, region string) (*ListVersionsResponse, error) {
	r := ListVersionsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type PartialUpdateInstanceRequest struct {
	ctx                          context.Context
	apiService                   *DefaultApiService
	projectId                    string
	instanceId                   string
	region                       string
	partialUpdateInstancePayload *PartialUpdateInstancePayload
}

// Body

func (r PartialUpdateInstanceRequest) PartialUpdateInstancePayload(partialUpdateInstancePayload PartialUpdateInstancePayload) ApiPartialUpdateInstanceRequest {
	r.partialUpdateInstancePayload = &partialUpdateInstancePayload
	return r
}

func (r PartialUpdateInstanceRequest) Execute() (*UpdateInstanceResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateInstanceResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialUpdateInstancePayload == nil {
		return localVarReturnValue, fmt.Errorf("partialUpdateInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateInstance: Update Instance

Update available instance of a mssql database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiPartialUpdateInstanceRequest
*/
func (a *APIClient) PartialUpdateInstance(ctx context.Context, projectId string, instanceId string, region string) ApiPartialUpdateInstanceRequest {
	return PartialUpdateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) PartialUpdateInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) (*UpdateInstanceResponse, error) {
	r := PartialUpdateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}

type ResetUserRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	instanceId string
	userId     string
	region     string
}

func (r ResetUserRequest) Execute() (*ResetUserResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResetUserResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ResetUser")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/users/{userId}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(ParameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ResetUser: Reset User

Reset user password for a mssql instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param userId user ID
	@param region The region which should be addressed
	@return ApiResetUserRequest
*/
func (a *APIClient) ResetUser(ctx context.Context, projectId string, instanceId string, userId string, region string) ApiResetUserRequest {
	return ResetUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		userId:     userId,
		region:     region,
	}
}

func (a *APIClient) ResetUserExecute(ctx context.Context, projectId string, instanceId string, userId string, region string) (*ResetUserResponse, error) {
	r := ResetUserRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		userId:     userId,
		region:     region,
	}
	return r.Execute()
}

type TerminateProjectRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	projectId  string
	region     string
}

func (r TerminateProjectRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TerminateProject")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
TerminateProject: Terminate the Project

Termination is the deletion of a whole project which causes the deletion of all instances for this project. Only System with permission system.databases-project.remove is able to call this resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param region The region which should be addressed
	@return ApiTerminateProjectRequest
*/
func (a *APIClient) TerminateProject(ctx context.Context, projectId string, region string) ApiTerminateProjectRequest {
	return TerminateProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
}

func (a *APIClient) TerminateProjectExecute(ctx context.Context, projectId string, region string) error {
	r := TerminateProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		region:     region,
	}
	return r.Execute()
}

type TriggerDatabaseBackupRequest struct {
	ctx          context.Context
	apiService   *DefaultApiService
	projectId    string
	instanceId   string
	databaseName string
	region       string
}

func (r TriggerDatabaseBackupRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TriggerDatabaseBackup")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/backups/databases/{databaseName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"databaseName"+"}", url.PathEscape(ParameterValueToString(r.databaseName, "databaseName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
TriggerDatabaseBackup: Trigger backup for a specific Database

Trigger backup for a specific Database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param databaseName Database Name
	@param region The region which should be addressed
	@return ApiTriggerDatabaseBackupRequest
*/
func (a *APIClient) TriggerDatabaseBackup(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiTriggerDatabaseBackupRequest {
	return TriggerDatabaseBackupRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
}

func (a *APIClient) TriggerDatabaseBackupExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) error {
	r := TriggerDatabaseBackupRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
	return r.Execute()
}

type TriggerDatabaseRestoreRequest struct {
	ctx                           context.Context
	apiService                    *DefaultApiService
	projectId                     string
	instanceId                    string
	databaseName                  string
	region                        string
	triggerDatabaseRestorePayload *TriggerDatabaseRestorePayload
}

// Body

func (r TriggerDatabaseRestoreRequest) TriggerDatabaseRestorePayload(triggerDatabaseRestorePayload TriggerDatabaseRestorePayload) ApiTriggerDatabaseRestoreRequest {
	r.triggerDatabaseRestorePayload = &triggerDatabaseRestorePayload
	return r
}

func (r TriggerDatabaseRestoreRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TriggerDatabaseRestore")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}/backups/databases/{databaseName}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"databaseName"+"}", url.PathEscape(ParameterValueToString(r.databaseName, "databaseName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.triggerDatabaseRestorePayload == nil {
		return fmt.Errorf("triggerDatabaseRestorePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.triggerDatabaseRestorePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
TriggerDatabaseRestore: Trigger restore for a specific Database

Trigger restore for a specific Database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param databaseName Database Name
	@param region The region which should be addressed
	@return ApiTriggerDatabaseRestoreRequest
*/
func (a *APIClient) TriggerDatabaseRestore(ctx context.Context, projectId string, instanceId string, databaseName string, region string) ApiTriggerDatabaseRestoreRequest {
	return TriggerDatabaseRestoreRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
}

func (a *APIClient) TriggerDatabaseRestoreExecute(ctx context.Context, projectId string, instanceId string, databaseName string, region string) error {
	r := TriggerDatabaseRestoreRequest{
		apiService:   a.defaultApi,
		ctx:          ctx,
		projectId:    projectId,
		instanceId:   instanceId,
		databaseName: databaseName,
		region:       region,
	}
	return r.Execute()
}

type UpdateInstanceRequest struct {
	ctx                   context.Context
	apiService            *DefaultApiService
	projectId             string
	instanceId            string
	region                string
	updateInstancePayload *UpdateInstancePayload
}

// Body

func (r UpdateInstanceRequest) UpdateInstancePayload(updateInstancePayload UpdateInstancePayload) ApiUpdateInstanceRequest {
	r.updateInstancePayload = &updateInstancePayload
	return r
}

func (r UpdateInstanceRequest) Execute() (*UpdateInstanceResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateInstanceResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateInstance")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/regions/{region}/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(ParameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(ParameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(ParameterValueToString(r.region, "region")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateInstancePayload == nil {
		return localVarReturnValue, fmt.Errorf("updateInstancePayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInstancePayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v InstanceError
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
UpdateInstance: Update Instance

Update available instance of a mssql database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param instanceId Instance ID
	@param region The region which should be addressed
	@return ApiUpdateInstanceRequest
*/
func (a *APIClient) UpdateInstance(ctx context.Context, projectId string, instanceId string, region string) ApiUpdateInstanceRequest {
	return UpdateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
}

func (a *APIClient) UpdateInstanceExecute(ctx context.Context, projectId string, instanceId string, region string) (*UpdateInstanceResponse, error) {
	r := UpdateInstanceRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		projectId:  projectId,
		instanceId: instanceId,
		region:     region,
	}
	return r.Execute()
}
