/*
SKE-API

The SKE API provides endpoints to create, update, delete clusters within STACKIT portal projects and to trigger further cluster management tasks.

API version: 1.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ske

import (
	"encoding/json"
	"fmt"
)

// checks if the RuntimeError type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &RuntimeError{}

/*
	types and functions for code
*/

// isEnum

// RuntimeErrorCode - Code:    `SKE_UNSPECIFIED`   Message: \"An error occurred. Please open a support ticket if this error persists.\" - Code:    `SKE_TMP_AUTH_ERROR`   Message: \"Authentication failed. This is a temporary error. Please wait while the system recovers.\" - Code:    `SKE_QUOTA_EXCEEDED`   Message: \"Your project's resource quotas are exhausted. Please make sure your quota is sufficient for the ordered cluster.\" - Code:    `SKE_ARGUS_INSTANCE_NOT_FOUND`   Message: \"The provided Argus instance could not be found.\" - Code:    `SKE_RATE_LIMITS`   Message: \"While provisioning your cluster, request rate limits where incurred. Please wait while the system recovers.\" - Code:    `SKE_INFRA_ERROR`   Message: \"An error occurred with the underlying infrastructure. Please open a support ticket if this error persists.\" - Code:    `SKE_REMAINING_RESOURCES`   Message: \"There are remaining Kubernetes resources in your cluster that prevent deletion. Please make sure to remove them.\" - Code:    `SKE_CONFIGURATION_PROBLEM`   Message: \"A configuration error occurred. Please open a support ticket if this error persists.\" - Code:    `SKE_UNREADY_NODES`   Message: \"Not all worker nodes are ready. Please open a support ticket if this error persists.\" - Code:    `SKE_API_SERVER_ERROR`   Message: \"The Kubernetes API server is not reporting readiness. Please open a support ticket if this error persists.\" - Code:    `SKE_DNS_ZONE_NOT_FOUND`   Message: \"The provided DNS zone for the STACKIT DNS extension could not be found. Please ensure you defined a valid domain that belongs to a STACKIT DNS zone.\"
// value type for enums
type RuntimeErrorCode string

// List of Code
const (
	RUNTIMEERRORCODE_UNSPECIFIED              RuntimeErrorCode = "SKE_UNSPECIFIED"
	RUNTIMEERRORCODE_TMP_AUTH_ERROR           RuntimeErrorCode = "SKE_TMP_AUTH_ERROR"
	RUNTIMEERRORCODE_QUOTA_EXCEEDED           RuntimeErrorCode = "SKE_QUOTA_EXCEEDED"
	RUNTIMEERRORCODE_ARGUS_INSTANCE_NOT_FOUND RuntimeErrorCode = "SKE_ARGUS_INSTANCE_NOT_FOUND"
	RUNTIMEERRORCODE_RATE_LIMITS              RuntimeErrorCode = "SKE_RATE_LIMITS"
	RUNTIMEERRORCODE_INFRA_ERROR              RuntimeErrorCode = "SKE_INFRA_ERROR"
	RUNTIMEERRORCODE_REMAINING_RESOURCES      RuntimeErrorCode = "SKE_REMAINING_RESOURCES"
	RUNTIMEERRORCODE_CONFIGURATION_PROBLEM    RuntimeErrorCode = "SKE_CONFIGURATION_PROBLEM"
	RUNTIMEERRORCODE_UNREADY_NODES            RuntimeErrorCode = "SKE_UNREADY_NODES"
	RUNTIMEERRORCODE_API_SERVER_ERROR         RuntimeErrorCode = "SKE_API_SERVER_ERROR"
	RUNTIMEERRORCODE_DNS_ZONE_NOT_FOUND       RuntimeErrorCode = "SKE_DNS_ZONE_NOT_FOUND"
)

// All allowed values of RuntimeError enum
var AllowedRuntimeErrorCodeEnumValues = []RuntimeErrorCode{
	"SKE_UNSPECIFIED",
	"SKE_TMP_AUTH_ERROR",
	"SKE_QUOTA_EXCEEDED",
	"SKE_ARGUS_INSTANCE_NOT_FOUND",
	"SKE_RATE_LIMITS",
	"SKE_INFRA_ERROR",
	"SKE_REMAINING_RESOURCES",
	"SKE_CONFIGURATION_PROBLEM",
	"SKE_UNREADY_NODES",
	"SKE_API_SERVER_ERROR",
	"SKE_DNS_ZONE_NOT_FOUND",
}

func (v *RuntimeErrorCode) UnmarshalJSON(src []byte) error {
	// use a type alias to prevent infinite recursion during unmarshal,
	// see https://biscuit.ninja/posts/go-avoid-an-infitine-loop-with-custom-json-unmarshallers
	type TmpJson RuntimeErrorCode
	var value TmpJson
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	// Allow unmarshalling zero value for testing purposes
	var zeroValue TmpJson
	if value == zeroValue {
		return nil
	}
	enumTypeValue := RuntimeErrorCode(value)
	for _, existing := range AllowedRuntimeErrorCodeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid RuntimeError", value)
}

// NewRuntimeErrorCodeFromValue returns a pointer to a valid RuntimeErrorCode
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewRuntimeErrorCodeFromValue(v RuntimeErrorCode) (*RuntimeErrorCode, error) {
	ev := RuntimeErrorCode(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for RuntimeErrorCode: valid values are %v", v, AllowedRuntimeErrorCodeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v RuntimeErrorCode) IsValid() bool {
	for _, existing := range AllowedRuntimeErrorCodeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to CodeCode value
func (v RuntimeErrorCode) Ptr() *RuntimeErrorCode {
	return &v
}

type NullableRuntimeErrorCode struct {
	value *RuntimeErrorCode
	isSet bool
}

func (v NullableRuntimeErrorCode) Get() *RuntimeErrorCode {
	return v.value
}

func (v *NullableRuntimeErrorCode) Set(val *RuntimeErrorCode) {
	v.value = val
	v.isSet = true
}

func (v NullableRuntimeErrorCode) IsSet() bool {
	return v.isSet
}

func (v *NullableRuntimeErrorCode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRuntimeErrorCode(val *RuntimeErrorCode) *NullableRuntimeErrorCode {
	return &NullableRuntimeErrorCode{value: val, isSet: true}
}

func (v NullableRuntimeErrorCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRuntimeErrorCode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

type RuntimeErrorGetCodeAttributeType = *RuntimeErrorCode
type RuntimeErrorGetCodeArgType = RuntimeErrorCode
type RuntimeErrorGetCodeRetType = RuntimeErrorCode

func getRuntimeErrorGetCodeAttributeTypeOk(arg RuntimeErrorGetCodeAttributeType) (ret RuntimeErrorGetCodeRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setRuntimeErrorGetCodeAttributeType(arg *RuntimeErrorGetCodeAttributeType, val RuntimeErrorGetCodeRetType) {
	*arg = &val
}

/*
	types and functions for details
*/

// isNotNullableString
type RuntimeErrorGetDetailsAttributeType = *string

func getRuntimeErrorGetDetailsAttributeTypeOk(arg RuntimeErrorGetDetailsAttributeType) (ret RuntimeErrorGetDetailsRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setRuntimeErrorGetDetailsAttributeType(arg *RuntimeErrorGetDetailsAttributeType, val RuntimeErrorGetDetailsRetType) {
	*arg = &val
}

type RuntimeErrorGetDetailsArgType = string
type RuntimeErrorGetDetailsRetType = string

/*
	types and functions for message
*/

// isNotNullableString
type RuntimeErrorGetMessageAttributeType = *string

func getRuntimeErrorGetMessageAttributeTypeOk(arg RuntimeErrorGetMessageAttributeType) (ret RuntimeErrorGetMessageRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setRuntimeErrorGetMessageAttributeType(arg *RuntimeErrorGetMessageAttributeType, val RuntimeErrorGetMessageRetType) {
	*arg = &val
}

type RuntimeErrorGetMessageArgType = string
type RuntimeErrorGetMessageRetType = string

// RuntimeError struct for RuntimeError
type RuntimeError struct {
	// - Code:    `SKE_UNSPECIFIED`   Message: \"An error occurred. Please open a support ticket if this error persists.\" - Code:    `SKE_TMP_AUTH_ERROR`   Message: \"Authentication failed. This is a temporary error. Please wait while the system recovers.\" - Code:    `SKE_QUOTA_EXCEEDED`   Message: \"Your project's resource quotas are exhausted. Please make sure your quota is sufficient for the ordered cluster.\" - Code:    `SKE_ARGUS_INSTANCE_NOT_FOUND`   Message: \"The provided Argus instance could not be found.\" - Code:    `SKE_RATE_LIMITS`   Message: \"While provisioning your cluster, request rate limits where incurred. Please wait while the system recovers.\" - Code:    `SKE_INFRA_ERROR`   Message: \"An error occurred with the underlying infrastructure. Please open a support ticket if this error persists.\" - Code:    `SKE_REMAINING_RESOURCES`   Message: \"There are remaining Kubernetes resources in your cluster that prevent deletion. Please make sure to remove them.\" - Code:    `SKE_CONFIGURATION_PROBLEM`   Message: \"A configuration error occurred. Please open a support ticket if this error persists.\" - Code:    `SKE_UNREADY_NODES`   Message: \"Not all worker nodes are ready. Please open a support ticket if this error persists.\" - Code:    `SKE_API_SERVER_ERROR`   Message: \"The Kubernetes API server is not reporting readiness. Please open a support ticket if this error persists.\" - Code:    `SKE_DNS_ZONE_NOT_FOUND`   Message: \"The provided DNS zone for the STACKIT DNS extension could not be found. Please ensure you defined a valid domain that belongs to a STACKIT DNS zone.\"
	Code    RuntimeErrorGetCodeAttributeType    `json:"code,omitempty"`
	Details RuntimeErrorGetDetailsAttributeType `json:"details,omitempty"`
	Message RuntimeErrorGetMessageAttributeType `json:"message,omitempty"`
}

// NewRuntimeError instantiates a new RuntimeError object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRuntimeError() *RuntimeError {
	this := RuntimeError{}
	return &this
}

// NewRuntimeErrorWithDefaults instantiates a new RuntimeError object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRuntimeErrorWithDefaults() *RuntimeError {
	this := RuntimeError{}
	return &this
}

// GetCode returns the Code field value if set, zero value otherwise.
func (o *RuntimeError) GetCode() (res RuntimeErrorGetCodeRetType) {
	res, _ = o.GetCodeOk()
	return
}

// GetCodeOk returns a tuple with the Code field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RuntimeError) GetCodeOk() (ret RuntimeErrorGetCodeRetType, ok bool) {
	return getRuntimeErrorGetCodeAttributeTypeOk(o.Code)
}

// HasCode returns a boolean if a field has been set.
func (o *RuntimeError) HasCode() bool {
	_, ok := o.GetCodeOk()
	return ok
}

// SetCode gets a reference to the given string and assigns it to the Code field.
func (o *RuntimeError) SetCode(v RuntimeErrorGetCodeRetType) {
	setRuntimeErrorGetCodeAttributeType(&o.Code, v)
}

// GetDetails returns the Details field value if set, zero value otherwise.
func (o *RuntimeError) GetDetails() (res RuntimeErrorGetDetailsRetType) {
	res, _ = o.GetDetailsOk()
	return
}

// GetDetailsOk returns a tuple with the Details field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RuntimeError) GetDetailsOk() (ret RuntimeErrorGetDetailsRetType, ok bool) {
	return getRuntimeErrorGetDetailsAttributeTypeOk(o.Details)
}

// HasDetails returns a boolean if a field has been set.
func (o *RuntimeError) HasDetails() bool {
	_, ok := o.GetDetailsOk()
	return ok
}

// SetDetails gets a reference to the given string and assigns it to the Details field.
func (o *RuntimeError) SetDetails(v RuntimeErrorGetDetailsRetType) {
	setRuntimeErrorGetDetailsAttributeType(&o.Details, v)
}

// GetMessage returns the Message field value if set, zero value otherwise.
func (o *RuntimeError) GetMessage() (res RuntimeErrorGetMessageRetType) {
	res, _ = o.GetMessageOk()
	return
}

// GetMessageOk returns a tuple with the Message field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *RuntimeError) GetMessageOk() (ret RuntimeErrorGetMessageRetType, ok bool) {
	return getRuntimeErrorGetMessageAttributeTypeOk(o.Message)
}

// HasMessage returns a boolean if a field has been set.
func (o *RuntimeError) HasMessage() bool {
	_, ok := o.GetMessageOk()
	return ok
}

// SetMessage gets a reference to the given string and assigns it to the Message field.
func (o *RuntimeError) SetMessage(v RuntimeErrorGetMessageRetType) {
	setRuntimeErrorGetMessageAttributeType(&o.Message, v)
}

func (o RuntimeError) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if val, ok := getRuntimeErrorGetCodeAttributeTypeOk(o.Code); ok {
		toSerialize["Code"] = val
	}
	if val, ok := getRuntimeErrorGetDetailsAttributeTypeOk(o.Details); ok {
		toSerialize["Details"] = val
	}
	if val, ok := getRuntimeErrorGetMessageAttributeTypeOk(o.Message); ok {
		toSerialize["Message"] = val
	}
	return toSerialize, nil
}

type NullableRuntimeError struct {
	value *RuntimeError
	isSet bool
}

func (v NullableRuntimeError) Get() *RuntimeError {
	return v.value
}

func (v *NullableRuntimeError) Set(val *RuntimeError) {
	v.value = val
	v.isSet = true
}

func (v NullableRuntimeError) IsSet() bool {
	return v.isSet
}

func (v *NullableRuntimeError) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRuntimeError(val *RuntimeError) *NullableRuntimeError {
	return &NullableRuntimeError{value: val, isSet: true}
}

func (v NullableRuntimeError) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRuntimeError) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
