/*
STACKIT Application Load Balancer API

This API offers an interface to provision and manage Application Load Balancers in your STACKIT project.This solution offers modern L7 load balancing. Current features include TLS, path and prefix based routing aswell as routing based on headers, query parameters and keeping connections persistent with cookies and web sockets.  For each Application Load Balancer provided, two VMs are deployed in your STACKIT project and are subject to fees.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package alb

import (
	"encoding/json"
)

// checks if the TlsConfig type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TlsConfig{}

/*
	types and functions for customCa
*/

// isNotNullableString
type TlsConfigGetCustomCaAttributeType = *string

func getTlsConfigGetCustomCaAttributeTypeOk(arg TlsConfigGetCustomCaAttributeType) (ret TlsConfigGetCustomCaRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setTlsConfigGetCustomCaAttributeType(arg *TlsConfigGetCustomCaAttributeType, val TlsConfigGetCustomCaRetType) {
	*arg = &val
}

type TlsConfigGetCustomCaArgType = string
type TlsConfigGetCustomCaRetType = string

/*
	types and functions for enabled
*/

// isBoolean
type TlsConfiggetEnabledAttributeType = *bool
type TlsConfiggetEnabledArgType = bool
type TlsConfiggetEnabledRetType = bool

func getTlsConfiggetEnabledAttributeTypeOk(arg TlsConfiggetEnabledAttributeType) (ret TlsConfiggetEnabledRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setTlsConfiggetEnabledAttributeType(arg *TlsConfiggetEnabledAttributeType, val TlsConfiggetEnabledRetType) {
	*arg = &val
}

/*
	types and functions for skipCertificateValidation
*/

// isBoolean
type TlsConfiggetSkipCertificateValidationAttributeType = *bool
type TlsConfiggetSkipCertificateValidationArgType = bool
type TlsConfiggetSkipCertificateValidationRetType = bool

func getTlsConfiggetSkipCertificateValidationAttributeTypeOk(arg TlsConfiggetSkipCertificateValidationAttributeType) (ret TlsConfiggetSkipCertificateValidationRetType, ok bool) {
	if arg == nil {
		return ret, false
	}
	return *arg, true
}

func setTlsConfiggetSkipCertificateValidationAttributeType(arg *TlsConfiggetSkipCertificateValidationAttributeType, val TlsConfiggetSkipCertificateValidationRetType) {
	*arg = &val
}

// TlsConfig Set this to configure TLS settings.
type TlsConfig struct {
	// Specifies a custom Certificate Authority (CA). When provided, the target pool will trust certificates signed by this CA, in addition to any system-trusted CAs. This is useful for scenarios where the target pool needs to communicate with servers using self-signed or internally-issued certificates. Enabled needs to be set to true and skip validation to false for this option.
	CustomCa TlsConfigGetCustomCaAttributeType `json:"customCa,omitempty"`
	// Enable TLS (Transport Layer Security) bridging for the connection between Application Load Balancer and targets in this pool. When enabled, public CAs are trusted. Can be used in tandem with the options either custom CA or skip validation or alone.
	Enabled TlsConfiggetEnabledAttributeType `json:"enabled,omitempty"`
	// Bypass certificate validation for TLS bridging in this target pool. This option is insecure and can only be used with public CAs by setting enabled true. Meant to be used for testing purposes only!
	SkipCertificateValidation TlsConfiggetSkipCertificateValidationAttributeType `json:"skipCertificateValidation,omitempty"`
}

// NewTlsConfig instantiates a new TlsConfig object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTlsConfig() *TlsConfig {
	this := TlsConfig{}
	return &this
}

// NewTlsConfigWithDefaults instantiates a new TlsConfig object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTlsConfigWithDefaults() *TlsConfig {
	this := TlsConfig{}
	return &this
}

// GetCustomCa returns the CustomCa field value if set, zero value otherwise.
func (o *TlsConfig) GetCustomCa() (res TlsConfigGetCustomCaRetType) {
	res, _ = o.GetCustomCaOk()
	return
}

// GetCustomCaOk returns a tuple with the CustomCa field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TlsConfig) GetCustomCaOk() (ret TlsConfigGetCustomCaRetType, ok bool) {
	return getTlsConfigGetCustomCaAttributeTypeOk(o.CustomCa)
}

// HasCustomCa returns a boolean if a field has been set.
func (o *TlsConfig) HasCustomCa() bool {
	_, ok := o.GetCustomCaOk()
	return ok
}

// SetCustomCa gets a reference to the given string and assigns it to the CustomCa field.
func (o *TlsConfig) SetCustomCa(v TlsConfigGetCustomCaRetType) {
	setTlsConfigGetCustomCaAttributeType(&o.CustomCa, v)
}

// GetEnabled returns the Enabled field value if set, zero value otherwise.
func (o *TlsConfig) GetEnabled() (res TlsConfiggetEnabledRetType) {
	res, _ = o.GetEnabledOk()
	return
}

// GetEnabledOk returns a tuple with the Enabled field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TlsConfig) GetEnabledOk() (ret TlsConfiggetEnabledRetType, ok bool) {
	return getTlsConfiggetEnabledAttributeTypeOk(o.Enabled)
}

// HasEnabled returns a boolean if a field has been set.
func (o *TlsConfig) HasEnabled() bool {
	_, ok := o.GetEnabledOk()
	return ok
}

// SetEnabled gets a reference to the given bool and assigns it to the Enabled field.
func (o *TlsConfig) SetEnabled(v TlsConfiggetEnabledRetType) {
	setTlsConfiggetEnabledAttributeType(&o.Enabled, v)
}

// GetSkipCertificateValidation returns the SkipCertificateValidation field value if set, zero value otherwise.
func (o *TlsConfig) GetSkipCertificateValidation() (res TlsConfiggetSkipCertificateValidationRetType) {
	res, _ = o.GetSkipCertificateValidationOk()
	return
}

// GetSkipCertificateValidationOk returns a tuple with the SkipCertificateValidation field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TlsConfig) GetSkipCertificateValidationOk() (ret TlsConfiggetSkipCertificateValidationRetType, ok bool) {
	return getTlsConfiggetSkipCertificateValidationAttributeTypeOk(o.SkipCertificateValidation)
}

// HasSkipCertificateValidation returns a boolean if a field has been set.
func (o *TlsConfig) HasSkipCertificateValidation() bool {
	_, ok := o.GetSkipCertificateValidationOk()
	return ok
}

// SetSkipCertificateValidation gets a reference to the given bool and assigns it to the SkipCertificateValidation field.
func (o *TlsConfig) SetSkipCertificateValidation(v TlsConfiggetSkipCertificateValidationRetType) {
	setTlsConfiggetSkipCertificateValidationAttributeType(&o.SkipCertificateValidation, v)
}

func (o TlsConfig) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if val, ok := getTlsConfigGetCustomCaAttributeTypeOk(o.CustomCa); ok {
		toSerialize["CustomCa"] = val
	}
	if val, ok := getTlsConfiggetEnabledAttributeTypeOk(o.Enabled); ok {
		toSerialize["Enabled"] = val
	}
	if val, ok := getTlsConfiggetSkipCertificateValidationAttributeTypeOk(o.SkipCertificateValidation); ok {
		toSerialize["SkipCertificateValidation"] = val
	}
	return toSerialize, nil
}

type NullableTlsConfig struct {
	value *TlsConfig
	isSet bool
}

func (v NullableTlsConfig) Get() *TlsConfig {
	return v.value
}

func (v *NullableTlsConfig) Set(val *TlsConfig) {
	v.value = val
	v.isSet = true
}

func (v NullableTlsConfig) IsSet() bool {
	return v.isSet
}

func (v *NullableTlsConfig) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTlsConfig(val *TlsConfig) *NullableTlsConfig {
	return &NullableTlsConfig{value: val, isSet: true}
}

func (v NullableTlsConfig) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTlsConfig) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
